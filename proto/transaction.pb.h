// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transaction.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transaction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transaction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sign.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transaction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transaction_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transaction_2eproto;
class CTransaction;
struct CTransactionDefaultTypeInternal;
extern CTransactionDefaultTypeInternal _CTransaction_default_instance_;
class CTxInput;
struct CTxInputDefaultTypeInternal;
extern CTxInputDefaultTypeInternal _CTxInput_default_instance_;
class CTxOutput;
struct CTxOutputDefaultTypeInternal;
extern CTxOutputDefaultTypeInternal _CTxOutput_default_instance_;
class CTxPrevOutput;
struct CTxPrevOutputDefaultTypeInternal;
extern CTxPrevOutputDefaultTypeInternal _CTxPrevOutput_default_instance_;
class CTxUtxo;
struct CTxUtxoDefaultTypeInternal;
extern CTxUtxoDefaultTypeInternal _CTxUtxo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CTransaction* Arena::CreateMaybeMessage<::CTransaction>(Arena*);
template<> ::CTxInput* Arena::CreateMaybeMessage<::CTxInput>(Arena*);
template<> ::CTxOutput* Arena::CreateMaybeMessage<::CTxOutput>(Arena*);
template<> ::CTxPrevOutput* Arena::CreateMaybeMessage<::CTxPrevOutput>(Arena*);
template<> ::CTxUtxo* Arena::CreateMaybeMessage<::CTxUtxo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class CTxPrevOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTxPrevOutput) */ {
 public:
  inline CTxPrevOutput() : CTxPrevOutput(nullptr) {}
  ~CTxPrevOutput() override;
  explicit PROTOBUF_CONSTEXPR CTxPrevOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTxPrevOutput(const CTxPrevOutput& from);
  CTxPrevOutput(CTxPrevOutput&& from) noexcept
    : CTxPrevOutput() {
    *this = ::std::move(from);
  }

  inline CTxPrevOutput& operator=(const CTxPrevOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTxPrevOutput& operator=(CTxPrevOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTxPrevOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTxPrevOutput* internal_default_instance() {
    return reinterpret_cast<const CTxPrevOutput*>(
               &_CTxPrevOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CTxPrevOutput& a, CTxPrevOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(CTxPrevOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTxPrevOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTxPrevOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTxPrevOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTxPrevOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CTxPrevOutput& from) {
    CTxPrevOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTxPrevOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTxPrevOutput";
  }
  protected:
  explicit CTxPrevOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kNFieldNumber = 2,
  };
  // string hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // uint32 n = 2;
  void clear_n();
  uint32_t n() const;
  void set_n(uint32_t value);
  private:
  uint32_t _internal_n() const;
  void _internal_set_n(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTxPrevOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    uint32_t n_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transaction_2eproto;
};
// -------------------------------------------------------------------

class CTxInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTxInput) */ {
 public:
  inline CTxInput() : CTxInput(nullptr) {}
  ~CTxInput() override;
  explicit PROTOBUF_CONSTEXPR CTxInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTxInput(const CTxInput& from);
  CTxInput(CTxInput&& from) noexcept
    : CTxInput() {
    *this = ::std::move(from);
  }

  inline CTxInput& operator=(const CTxInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTxInput& operator=(CTxInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTxInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTxInput* internal_default_instance() {
    return reinterpret_cast<const CTxInput*>(
               &_CTxInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CTxInput& a, CTxInput& b) {
    a.Swap(&b);
  }
  inline void Swap(CTxInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTxInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTxInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTxInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTxInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CTxInput& from) {
    CTxInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTxInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTxInput";
  }
  protected:
  explicit CTxInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrevOutFieldNumber = 1,
    kContractAddrFieldNumber = 4,
    kVinSignFieldNumber = 2,
    kSequenceFieldNumber = 3,
  };
  // repeated .CTxPrevOutput prevOut = 1;
  int prevout_size() const;
  private:
  int _internal_prevout_size() const;
  public:
  void clear_prevout();
  ::CTxPrevOutput* mutable_prevout(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxPrevOutput >*
      mutable_prevout();
  private:
  const ::CTxPrevOutput& _internal_prevout(int index) const;
  ::CTxPrevOutput* _internal_add_prevout();
  public:
  const ::CTxPrevOutput& prevout(int index) const;
  ::CTxPrevOutput* add_prevout();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxPrevOutput >&
      prevout() const;

  // string contractAddr = 4;
  void clear_contractaddr();
  const std::string& contractaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contractaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contractaddr();
  PROTOBUF_NODISCARD std::string* release_contractaddr();
  void set_allocated_contractaddr(std::string* contractaddr);
  private:
  const std::string& _internal_contractaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contractaddr(const std::string& value);
  std::string* _internal_mutable_contractaddr();
  public:

  // .CSign vinSign = 2;
  bool has_vinsign() const;
  private:
  bool _internal_has_vinsign() const;
  public:
  void clear_vinsign();
  const ::CSign& vinsign() const;
  PROTOBUF_NODISCARD ::CSign* release_vinsign();
  ::CSign* mutable_vinsign();
  void set_allocated_vinsign(::CSign* vinsign);
  private:
  const ::CSign& _internal_vinsign() const;
  ::CSign* _internal_mutable_vinsign();
  public:
  void unsafe_arena_set_allocated_vinsign(
      ::CSign* vinsign);
  ::CSign* unsafe_arena_release_vinsign();

  // uint32 sequence = 3;
  void clear_sequence();
  uint32_t sequence() const;
  void set_sequence(uint32_t value);
  private:
  uint32_t _internal_sequence() const;
  void _internal_set_sequence(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTxInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxPrevOutput > prevout_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contractaddr_;
    ::CSign* vinsign_;
    uint32_t sequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transaction_2eproto;
};
// -------------------------------------------------------------------

class CTxOutput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTxOutput) */ {
 public:
  inline CTxOutput() : CTxOutput(nullptr) {}
  ~CTxOutput() override;
  explicit PROTOBUF_CONSTEXPR CTxOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTxOutput(const CTxOutput& from);
  CTxOutput(CTxOutput&& from) noexcept
    : CTxOutput() {
    *this = ::std::move(from);
  }

  inline CTxOutput& operator=(const CTxOutput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTxOutput& operator=(CTxOutput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTxOutput& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTxOutput* internal_default_instance() {
    return reinterpret_cast<const CTxOutput*>(
               &_CTxOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CTxOutput& a, CTxOutput& b) {
    a.Swap(&b);
  }
  inline void Swap(CTxOutput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTxOutput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTxOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTxOutput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTxOutput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CTxOutput& from) {
    CTxOutput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTxOutput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTxOutput";
  }
  protected:
  explicit CTxOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // int64 value = 1;
  void clear_value();
  int64_t value() const;
  void set_value(int64_t value);
  private:
  int64_t _internal_value() const;
  void _internal_set_value(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTxOutput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    int64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transaction_2eproto;
};
// -------------------------------------------------------------------

class CTxUtxo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTxUtxo) */ {
 public:
  inline CTxUtxo() : CTxUtxo(nullptr) {}
  ~CTxUtxo() override;
  explicit PROTOBUF_CONSTEXPR CTxUtxo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTxUtxo(const CTxUtxo& from);
  CTxUtxo(CTxUtxo&& from) noexcept
    : CTxUtxo() {
    *this = ::std::move(from);
  }

  inline CTxUtxo& operator=(const CTxUtxo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTxUtxo& operator=(CTxUtxo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTxUtxo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTxUtxo* internal_default_instance() {
    return reinterpret_cast<const CTxUtxo*>(
               &_CTxUtxo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CTxUtxo& a, CTxUtxo& b) {
    a.Swap(&b);
  }
  inline void Swap(CTxUtxo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTxUtxo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTxUtxo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTxUtxo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTxUtxo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CTxUtxo& from) {
    CTxUtxo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTxUtxo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTxUtxo";
  }
  protected:
  explicit CTxUtxo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnerFieldNumber = 1,
    kVinFieldNumber = 2,
    kVoutFieldNumber = 3,
    kMultiSignFieldNumber = 4,
  };
  // repeated string owner = 1;
  int owner_size() const;
  private:
  int _internal_owner_size() const;
  public:
  void clear_owner();
  const std::string& owner(int index) const;
  std::string* mutable_owner(int index);
  void set_owner(int index, const std::string& value);
  void set_owner(int index, std::string&& value);
  void set_owner(int index, const char* value);
  void set_owner(int index, const char* value, size_t size);
  std::string* add_owner();
  void add_owner(const std::string& value);
  void add_owner(std::string&& value);
  void add_owner(const char* value);
  void add_owner(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owner() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owner();
  private:
  const std::string& _internal_owner(int index) const;
  std::string* _internal_add_owner();
  public:

  // repeated .CTxInput vin = 2;
  int vin_size() const;
  private:
  int _internal_vin_size() const;
  public:
  void clear_vin();
  ::CTxInput* mutable_vin(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxInput >*
      mutable_vin();
  private:
  const ::CTxInput& _internal_vin(int index) const;
  ::CTxInput* _internal_add_vin();
  public:
  const ::CTxInput& vin(int index) const;
  ::CTxInput* add_vin();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxInput >&
      vin() const;

  // repeated .CTxOutput vout = 3;
  int vout_size() const;
  private:
  int _internal_vout_size() const;
  public:
  void clear_vout();
  ::CTxOutput* mutable_vout(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxOutput >*
      mutable_vout();
  private:
  const ::CTxOutput& _internal_vout(int index) const;
  ::CTxOutput* _internal_add_vout();
  public:
  const ::CTxOutput& vout(int index) const;
  ::CTxOutput* add_vout();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxOutput >&
      vout() const;

  // repeated .CSign multiSign = 4;
  int multisign_size() const;
  private:
  int _internal_multisign_size() const;
  public:
  void clear_multisign();
  ::CSign* mutable_multisign(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >*
      mutable_multisign();
  private:
  const ::CSign& _internal_multisign(int index) const;
  ::CSign* _internal_add_multisign();
  public:
  const ::CSign& multisign(int index) const;
  ::CSign* add_multisign();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >&
      multisign() const;

  // @@protoc_insertion_point(class_scope:CTxUtxo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owner_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxInput > vin_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxOutput > vout_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign > multisign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transaction_2eproto;
};
// -------------------------------------------------------------------

class CTransaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTransaction) */ {
 public:
  inline CTransaction() : CTransaction(nullptr) {}
  ~CTransaction() override;
  explicit PROTOBUF_CONSTEXPR CTransaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTransaction(const CTransaction& from);
  CTransaction(CTransaction&& from) noexcept
    : CTransaction() {
    *this = ::std::move(from);
  }

  inline CTransaction& operator=(const CTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTransaction& operator=(CTransaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTransaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTransaction* internal_default_instance() {
    return reinterpret_cast<const CTransaction*>(
               &_CTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CTransaction& a, CTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(CTransaction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTransaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTransaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CTransaction& from) {
    CTransaction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTransaction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTransaction";
  }
  protected:
  explicit CTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerifySignFieldNumber = 12,
    kIdentityFieldNumber = 4,
    kHashFieldNumber = 5,
    kTypeFieldNumber = 7,
    kDataFieldNumber = 10,
    kInfoFieldNumber = 11,
    kReserve0FieldNumber = 13,
    kReserve1FieldNumber = 14,
    kUtxoFieldNumber = 6,
    kTimeFieldNumber = 2,
    kVersionFieldNumber = 1,
    kNFieldNumber = 3,
    kConsensusFieldNumber = 8,
    kTxTypeFieldNumber = 9,
  };
  // repeated .CSign verifySign = 12;
  int verifysign_size() const;
  private:
  int _internal_verifysign_size() const;
  public:
  void clear_verifysign();
  ::CSign* mutable_verifysign(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >*
      mutable_verifysign();
  private:
  const ::CSign& _internal_verifysign(int index) const;
  ::CSign* _internal_add_verifysign();
  public:
  const ::CSign& verifysign(int index) const;
  ::CSign* add_verifysign();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >&
      verifysign() const;

  // string identity = 4;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string hash = 5;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // string type = 7;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string data = 10;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string info = 11;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // string reserve0 = 13;
  void clear_reserve0();
  const std::string& reserve0() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reserve0(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reserve0();
  PROTOBUF_NODISCARD std::string* release_reserve0();
  void set_allocated_reserve0(std::string* reserve0);
  private:
  const std::string& _internal_reserve0() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reserve0(const std::string& value);
  std::string* _internal_mutable_reserve0();
  public:

  // string reserve1 = 14;
  void clear_reserve1();
  const std::string& reserve1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reserve1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reserve1();
  PROTOBUF_NODISCARD std::string* release_reserve1();
  void set_allocated_reserve1(std::string* reserve1);
  private:
  const std::string& _internal_reserve1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reserve1(const std::string& value);
  std::string* _internal_mutable_reserve1();
  public:

  // .CTxUtxo utxo = 6;
  bool has_utxo() const;
  private:
  bool _internal_has_utxo() const;
  public:
  void clear_utxo();
  const ::CTxUtxo& utxo() const;
  PROTOBUF_NODISCARD ::CTxUtxo* release_utxo();
  ::CTxUtxo* mutable_utxo();
  void set_allocated_utxo(::CTxUtxo* utxo);
  private:
  const ::CTxUtxo& _internal_utxo() const;
  ::CTxUtxo* _internal_mutable_utxo();
  public:
  void unsafe_arena_set_allocated_utxo(
      ::CTxUtxo* utxo);
  ::CTxUtxo* unsafe_arena_release_utxo();

  // uint64 time = 2;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // uint32 n = 3;
  void clear_n();
  uint32_t n() const;
  void set_n(uint32_t value);
  private:
  uint32_t _internal_n() const;
  void _internal_set_n(uint32_t value);
  public:

  // uint32 consensus = 8;
  void clear_consensus();
  uint32_t consensus() const;
  void set_consensus(uint32_t value);
  private:
  uint32_t _internal_consensus() const;
  void _internal_set_consensus(uint32_t value);
  public:

  // uint32 txType = 9;
  void clear_txtype();
  uint32_t txtype() const;
  void set_txtype(uint32_t value);
  private:
  uint32_t _internal_txtype() const;
  void _internal_set_txtype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign > verifysign_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reserve0_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reserve1_;
    ::CTxUtxo* utxo_;
    uint64_t time_;
    uint32_t version_;
    uint32_t n_;
    uint32_t consensus_;
    uint32_t txtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_transaction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CTxPrevOutput

// string hash = 1;
inline void CTxPrevOutput::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& CTxPrevOutput::hash() const {
  // @@protoc_insertion_point(field_get:CTxPrevOutput.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTxPrevOutput::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTxPrevOutput.hash)
}
inline std::string* CTxPrevOutput::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:CTxPrevOutput.hash)
  return _s;
}
inline const std::string& CTxPrevOutput::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void CTxPrevOutput::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CTxPrevOutput::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* CTxPrevOutput::release_hash() {
  // @@protoc_insertion_point(field_release:CTxPrevOutput.hash)
  return _impl_.hash_.Release();
}
inline void CTxPrevOutput::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTxPrevOutput.hash)
}

// uint32 n = 2;
inline void CTxPrevOutput::clear_n() {
  _impl_.n_ = 0u;
}
inline uint32_t CTxPrevOutput::_internal_n() const {
  return _impl_.n_;
}
inline uint32_t CTxPrevOutput::n() const {
  // @@protoc_insertion_point(field_get:CTxPrevOutput.n)
  return _internal_n();
}
inline void CTxPrevOutput::_internal_set_n(uint32_t value) {
  
  _impl_.n_ = value;
}
inline void CTxPrevOutput::set_n(uint32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:CTxPrevOutput.n)
}

// -------------------------------------------------------------------

// CTxInput

// repeated .CTxPrevOutput prevOut = 1;
inline int CTxInput::_internal_prevout_size() const {
  return _impl_.prevout_.size();
}
inline int CTxInput::prevout_size() const {
  return _internal_prevout_size();
}
inline void CTxInput::clear_prevout() {
  _impl_.prevout_.Clear();
}
inline ::CTxPrevOutput* CTxInput::mutable_prevout(int index) {
  // @@protoc_insertion_point(field_mutable:CTxInput.prevOut)
  return _impl_.prevout_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxPrevOutput >*
CTxInput::mutable_prevout() {
  // @@protoc_insertion_point(field_mutable_list:CTxInput.prevOut)
  return &_impl_.prevout_;
}
inline const ::CTxPrevOutput& CTxInput::_internal_prevout(int index) const {
  return _impl_.prevout_.Get(index);
}
inline const ::CTxPrevOutput& CTxInput::prevout(int index) const {
  // @@protoc_insertion_point(field_get:CTxInput.prevOut)
  return _internal_prevout(index);
}
inline ::CTxPrevOutput* CTxInput::_internal_add_prevout() {
  return _impl_.prevout_.Add();
}
inline ::CTxPrevOutput* CTxInput::add_prevout() {
  ::CTxPrevOutput* _add = _internal_add_prevout();
  // @@protoc_insertion_point(field_add:CTxInput.prevOut)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxPrevOutput >&
CTxInput::prevout() const {
  // @@protoc_insertion_point(field_list:CTxInput.prevOut)
  return _impl_.prevout_;
}

// .CSign vinSign = 2;
inline bool CTxInput::_internal_has_vinsign() const {
  return this != internal_default_instance() && _impl_.vinsign_ != nullptr;
}
inline bool CTxInput::has_vinsign() const {
  return _internal_has_vinsign();
}
inline const ::CSign& CTxInput::_internal_vinsign() const {
  const ::CSign* p = _impl_.vinsign_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSign&>(
      ::_CSign_default_instance_);
}
inline const ::CSign& CTxInput::vinsign() const {
  // @@protoc_insertion_point(field_get:CTxInput.vinSign)
  return _internal_vinsign();
}
inline void CTxInput::unsafe_arena_set_allocated_vinsign(
    ::CSign* vinsign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vinsign_);
  }
  _impl_.vinsign_ = vinsign;
  if (vinsign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CTxInput.vinSign)
}
inline ::CSign* CTxInput::release_vinsign() {
  
  ::CSign* temp = _impl_.vinsign_;
  _impl_.vinsign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSign* CTxInput::unsafe_arena_release_vinsign() {
  // @@protoc_insertion_point(field_release:CTxInput.vinSign)
  
  ::CSign* temp = _impl_.vinsign_;
  _impl_.vinsign_ = nullptr;
  return temp;
}
inline ::CSign* CTxInput::_internal_mutable_vinsign() {
  
  if (_impl_.vinsign_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSign>(GetArenaForAllocation());
    _impl_.vinsign_ = p;
  }
  return _impl_.vinsign_;
}
inline ::CSign* CTxInput::mutable_vinsign() {
  ::CSign* _msg = _internal_mutable_vinsign();
  // @@protoc_insertion_point(field_mutable:CTxInput.vinSign)
  return _msg;
}
inline void CTxInput::set_allocated_vinsign(::CSign* vinsign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vinsign_);
  }
  if (vinsign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vinsign));
    if (message_arena != submessage_arena) {
      vinsign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vinsign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vinsign_ = vinsign;
  // @@protoc_insertion_point(field_set_allocated:CTxInput.vinSign)
}

// uint32 sequence = 3;
inline void CTxInput::clear_sequence() {
  _impl_.sequence_ = 0u;
}
inline uint32_t CTxInput::_internal_sequence() const {
  return _impl_.sequence_;
}
inline uint32_t CTxInput::sequence() const {
  // @@protoc_insertion_point(field_get:CTxInput.sequence)
  return _internal_sequence();
}
inline void CTxInput::_internal_set_sequence(uint32_t value) {
  
  _impl_.sequence_ = value;
}
inline void CTxInput::set_sequence(uint32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:CTxInput.sequence)
}

// string contractAddr = 4;
inline void CTxInput::clear_contractaddr() {
  _impl_.contractaddr_.ClearToEmpty();
}
inline const std::string& CTxInput::contractaddr() const {
  // @@protoc_insertion_point(field_get:CTxInput.contractAddr)
  return _internal_contractaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTxInput::set_contractaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contractaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTxInput.contractAddr)
}
inline std::string* CTxInput::mutable_contractaddr() {
  std::string* _s = _internal_mutable_contractaddr();
  // @@protoc_insertion_point(field_mutable:CTxInput.contractAddr)
  return _s;
}
inline const std::string& CTxInput::_internal_contractaddr() const {
  return _impl_.contractaddr_.Get();
}
inline void CTxInput::_internal_set_contractaddr(const std::string& value) {
  
  _impl_.contractaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* CTxInput::_internal_mutable_contractaddr() {
  
  return _impl_.contractaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* CTxInput::release_contractaddr() {
  // @@protoc_insertion_point(field_release:CTxInput.contractAddr)
  return _impl_.contractaddr_.Release();
}
inline void CTxInput::set_allocated_contractaddr(std::string* contractaddr) {
  if (contractaddr != nullptr) {
    
  } else {
    
  }
  _impl_.contractaddr_.SetAllocated(contractaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contractaddr_.IsDefault()) {
    _impl_.contractaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTxInput.contractAddr)
}

// -------------------------------------------------------------------

// CTxOutput

// int64 value = 1;
inline void CTxOutput::clear_value() {
  _impl_.value_ = int64_t{0};
}
inline int64_t CTxOutput::_internal_value() const {
  return _impl_.value_;
}
inline int64_t CTxOutput::value() const {
  // @@protoc_insertion_point(field_get:CTxOutput.value)
  return _internal_value();
}
inline void CTxOutput::_internal_set_value(int64_t value) {
  
  _impl_.value_ = value;
}
inline void CTxOutput::set_value(int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CTxOutput.value)
}

// string addr = 2;
inline void CTxOutput::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& CTxOutput::addr() const {
  // @@protoc_insertion_point(field_get:CTxOutput.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTxOutput::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTxOutput.addr)
}
inline std::string* CTxOutput::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:CTxOutput.addr)
  return _s;
}
inline const std::string& CTxOutput::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void CTxOutput::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* CTxOutput::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* CTxOutput::release_addr() {
  // @@protoc_insertion_point(field_release:CTxOutput.addr)
  return _impl_.addr_.Release();
}
inline void CTxOutput::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTxOutput.addr)
}

// -------------------------------------------------------------------

// CTxUtxo

// repeated string owner = 1;
inline int CTxUtxo::_internal_owner_size() const {
  return _impl_.owner_.size();
}
inline int CTxUtxo::owner_size() const {
  return _internal_owner_size();
}
inline void CTxUtxo::clear_owner() {
  _impl_.owner_.Clear();
}
inline std::string* CTxUtxo::add_owner() {
  std::string* _s = _internal_add_owner();
  // @@protoc_insertion_point(field_add_mutable:CTxUtxo.owner)
  return _s;
}
inline const std::string& CTxUtxo::_internal_owner(int index) const {
  return _impl_.owner_.Get(index);
}
inline const std::string& CTxUtxo::owner(int index) const {
  // @@protoc_insertion_point(field_get:CTxUtxo.owner)
  return _internal_owner(index);
}
inline std::string* CTxUtxo::mutable_owner(int index) {
  // @@protoc_insertion_point(field_mutable:CTxUtxo.owner)
  return _impl_.owner_.Mutable(index);
}
inline void CTxUtxo::set_owner(int index, const std::string& value) {
  _impl_.owner_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CTxUtxo.owner)
}
inline void CTxUtxo::set_owner(int index, std::string&& value) {
  _impl_.owner_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CTxUtxo.owner)
}
inline void CTxUtxo::set_owner(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owner_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CTxUtxo.owner)
}
inline void CTxUtxo::set_owner(int index, const char* value, size_t size) {
  _impl_.owner_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CTxUtxo.owner)
}
inline std::string* CTxUtxo::_internal_add_owner() {
  return _impl_.owner_.Add();
}
inline void CTxUtxo::add_owner(const std::string& value) {
  _impl_.owner_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CTxUtxo.owner)
}
inline void CTxUtxo::add_owner(std::string&& value) {
  _impl_.owner_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CTxUtxo.owner)
}
inline void CTxUtxo::add_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.owner_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CTxUtxo.owner)
}
inline void CTxUtxo::add_owner(const char* value, size_t size) {
  _impl_.owner_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CTxUtxo.owner)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CTxUtxo::owner() const {
  // @@protoc_insertion_point(field_list:CTxUtxo.owner)
  return _impl_.owner_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CTxUtxo::mutable_owner() {
  // @@protoc_insertion_point(field_mutable_list:CTxUtxo.owner)
  return &_impl_.owner_;
}

// repeated .CTxInput vin = 2;
inline int CTxUtxo::_internal_vin_size() const {
  return _impl_.vin_.size();
}
inline int CTxUtxo::vin_size() const {
  return _internal_vin_size();
}
inline void CTxUtxo::clear_vin() {
  _impl_.vin_.Clear();
}
inline ::CTxInput* CTxUtxo::mutable_vin(int index) {
  // @@protoc_insertion_point(field_mutable:CTxUtxo.vin)
  return _impl_.vin_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxInput >*
CTxUtxo::mutable_vin() {
  // @@protoc_insertion_point(field_mutable_list:CTxUtxo.vin)
  return &_impl_.vin_;
}
inline const ::CTxInput& CTxUtxo::_internal_vin(int index) const {
  return _impl_.vin_.Get(index);
}
inline const ::CTxInput& CTxUtxo::vin(int index) const {
  // @@protoc_insertion_point(field_get:CTxUtxo.vin)
  return _internal_vin(index);
}
inline ::CTxInput* CTxUtxo::_internal_add_vin() {
  return _impl_.vin_.Add();
}
inline ::CTxInput* CTxUtxo::add_vin() {
  ::CTxInput* _add = _internal_add_vin();
  // @@protoc_insertion_point(field_add:CTxUtxo.vin)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxInput >&
CTxUtxo::vin() const {
  // @@protoc_insertion_point(field_list:CTxUtxo.vin)
  return _impl_.vin_;
}

// repeated .CTxOutput vout = 3;
inline int CTxUtxo::_internal_vout_size() const {
  return _impl_.vout_.size();
}
inline int CTxUtxo::vout_size() const {
  return _internal_vout_size();
}
inline void CTxUtxo::clear_vout() {
  _impl_.vout_.Clear();
}
inline ::CTxOutput* CTxUtxo::mutable_vout(int index) {
  // @@protoc_insertion_point(field_mutable:CTxUtxo.vout)
  return _impl_.vout_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxOutput >*
CTxUtxo::mutable_vout() {
  // @@protoc_insertion_point(field_mutable_list:CTxUtxo.vout)
  return &_impl_.vout_;
}
inline const ::CTxOutput& CTxUtxo::_internal_vout(int index) const {
  return _impl_.vout_.Get(index);
}
inline const ::CTxOutput& CTxUtxo::vout(int index) const {
  // @@protoc_insertion_point(field_get:CTxUtxo.vout)
  return _internal_vout(index);
}
inline ::CTxOutput* CTxUtxo::_internal_add_vout() {
  return _impl_.vout_.Add();
}
inline ::CTxOutput* CTxUtxo::add_vout() {
  ::CTxOutput* _add = _internal_add_vout();
  // @@protoc_insertion_point(field_add:CTxUtxo.vout)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CTxOutput >&
CTxUtxo::vout() const {
  // @@protoc_insertion_point(field_list:CTxUtxo.vout)
  return _impl_.vout_;
}

// repeated .CSign multiSign = 4;
inline int CTxUtxo::_internal_multisign_size() const {
  return _impl_.multisign_.size();
}
inline int CTxUtxo::multisign_size() const {
  return _internal_multisign_size();
}
inline ::CSign* CTxUtxo::mutable_multisign(int index) {
  // @@protoc_insertion_point(field_mutable:CTxUtxo.multiSign)
  return _impl_.multisign_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >*
CTxUtxo::mutable_multisign() {
  // @@protoc_insertion_point(field_mutable_list:CTxUtxo.multiSign)
  return &_impl_.multisign_;
}
inline const ::CSign& CTxUtxo::_internal_multisign(int index) const {
  return _impl_.multisign_.Get(index);
}
inline const ::CSign& CTxUtxo::multisign(int index) const {
  // @@protoc_insertion_point(field_get:CTxUtxo.multiSign)
  return _internal_multisign(index);
}
inline ::CSign* CTxUtxo::_internal_add_multisign() {
  return _impl_.multisign_.Add();
}
inline ::CSign* CTxUtxo::add_multisign() {
  ::CSign* _add = _internal_add_multisign();
  // @@protoc_insertion_point(field_add:CTxUtxo.multiSign)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >&
CTxUtxo::multisign() const {
  // @@protoc_insertion_point(field_list:CTxUtxo.multiSign)
  return _impl_.multisign_;
}

// -------------------------------------------------------------------

// CTransaction

// uint32 version = 1;
inline void CTransaction::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t CTransaction::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t CTransaction::version() const {
  // @@protoc_insertion_point(field_get:CTransaction.version)
  return _internal_version();
}
inline void CTransaction::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void CTransaction::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CTransaction.version)
}

// uint64 time = 2;
inline void CTransaction::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t CTransaction::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t CTransaction::time() const {
  // @@protoc_insertion_point(field_get:CTransaction.time)
  return _internal_time();
}
inline void CTransaction::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void CTransaction::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:CTransaction.time)
}

// uint32 n = 3;
inline void CTransaction::clear_n() {
  _impl_.n_ = 0u;
}
inline uint32_t CTransaction::_internal_n() const {
  return _impl_.n_;
}
inline uint32_t CTransaction::n() const {
  // @@protoc_insertion_point(field_get:CTransaction.n)
  return _internal_n();
}
inline void CTransaction::_internal_set_n(uint32_t value) {
  
  _impl_.n_ = value;
}
inline void CTransaction::set_n(uint32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:CTransaction.n)
}

// string identity = 4;
inline void CTransaction::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& CTransaction::identity() const {
  // @@protoc_insertion_point(field_get:CTransaction.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransaction::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransaction.identity)
}
inline std::string* CTransaction::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:CTransaction.identity)
  return _s;
}
inline const std::string& CTransaction::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void CTransaction::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* CTransaction::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* CTransaction::release_identity() {
  // @@protoc_insertion_point(field_release:CTransaction.identity)
  return _impl_.identity_.Release();
}
inline void CTransaction::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransaction.identity)
}

// string hash = 5;
inline void CTransaction::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& CTransaction::hash() const {
  // @@protoc_insertion_point(field_get:CTransaction.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransaction::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransaction.hash)
}
inline std::string* CTransaction::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:CTransaction.hash)
  return _s;
}
inline const std::string& CTransaction::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void CTransaction::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CTransaction::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* CTransaction::release_hash() {
  // @@protoc_insertion_point(field_release:CTransaction.hash)
  return _impl_.hash_.Release();
}
inline void CTransaction::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransaction.hash)
}

// .CTxUtxo utxo = 6;
inline bool CTransaction::_internal_has_utxo() const {
  return this != internal_default_instance() && _impl_.utxo_ != nullptr;
}
inline bool CTransaction::has_utxo() const {
  return _internal_has_utxo();
}
inline void CTransaction::clear_utxo() {
  if (GetArenaForAllocation() == nullptr && _impl_.utxo_ != nullptr) {
    delete _impl_.utxo_;
  }
  _impl_.utxo_ = nullptr;
}
inline const ::CTxUtxo& CTransaction::_internal_utxo() const {
  const ::CTxUtxo* p = _impl_.utxo_;
  return p != nullptr ? *p : reinterpret_cast<const ::CTxUtxo&>(
      ::_CTxUtxo_default_instance_);
}
inline const ::CTxUtxo& CTransaction::utxo() const {
  // @@protoc_insertion_point(field_get:CTransaction.utxo)
  return _internal_utxo();
}
inline void CTransaction::unsafe_arena_set_allocated_utxo(
    ::CTxUtxo* utxo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.utxo_);
  }
  _impl_.utxo_ = utxo;
  if (utxo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CTransaction.utxo)
}
inline ::CTxUtxo* CTransaction::release_utxo() {
  
  ::CTxUtxo* temp = _impl_.utxo_;
  _impl_.utxo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CTxUtxo* CTransaction::unsafe_arena_release_utxo() {
  // @@protoc_insertion_point(field_release:CTransaction.utxo)
  
  ::CTxUtxo* temp = _impl_.utxo_;
  _impl_.utxo_ = nullptr;
  return temp;
}
inline ::CTxUtxo* CTransaction::_internal_mutable_utxo() {
  
  if (_impl_.utxo_ == nullptr) {
    auto* p = CreateMaybeMessage<::CTxUtxo>(GetArenaForAllocation());
    _impl_.utxo_ = p;
  }
  return _impl_.utxo_;
}
inline ::CTxUtxo* CTransaction::mutable_utxo() {
  ::CTxUtxo* _msg = _internal_mutable_utxo();
  // @@protoc_insertion_point(field_mutable:CTransaction.utxo)
  return _msg;
}
inline void CTransaction::set_allocated_utxo(::CTxUtxo* utxo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.utxo_;
  }
  if (utxo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(utxo);
    if (message_arena != submessage_arena) {
      utxo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, utxo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.utxo_ = utxo;
  // @@protoc_insertion_point(field_set_allocated:CTransaction.utxo)
}

// string type = 7;
inline void CTransaction::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& CTransaction::type() const {
  // @@protoc_insertion_point(field_get:CTransaction.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransaction::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransaction.type)
}
inline std::string* CTransaction::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:CTransaction.type)
  return _s;
}
inline const std::string& CTransaction::_internal_type() const {
  return _impl_.type_.Get();
}
inline void CTransaction::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* CTransaction::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* CTransaction::release_type() {
  // @@protoc_insertion_point(field_release:CTransaction.type)
  return _impl_.type_.Release();
}
inline void CTransaction::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransaction.type)
}

// uint32 consensus = 8;
inline void CTransaction::clear_consensus() {
  _impl_.consensus_ = 0u;
}
inline uint32_t CTransaction::_internal_consensus() const {
  return _impl_.consensus_;
}
inline uint32_t CTransaction::consensus() const {
  // @@protoc_insertion_point(field_get:CTransaction.consensus)
  return _internal_consensus();
}
inline void CTransaction::_internal_set_consensus(uint32_t value) {
  
  _impl_.consensus_ = value;
}
inline void CTransaction::set_consensus(uint32_t value) {
  _internal_set_consensus(value);
  // @@protoc_insertion_point(field_set:CTransaction.consensus)
}

// uint32 txType = 9;
inline void CTransaction::clear_txtype() {
  _impl_.txtype_ = 0u;
}
inline uint32_t CTransaction::_internal_txtype() const {
  return _impl_.txtype_;
}
inline uint32_t CTransaction::txtype() const {
  // @@protoc_insertion_point(field_get:CTransaction.txType)
  return _internal_txtype();
}
inline void CTransaction::_internal_set_txtype(uint32_t value) {
  
  _impl_.txtype_ = value;
}
inline void CTransaction::set_txtype(uint32_t value) {
  _internal_set_txtype(value);
  // @@protoc_insertion_point(field_set:CTransaction.txType)
}

// string data = 10;
inline void CTransaction::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& CTransaction::data() const {
  // @@protoc_insertion_point(field_get:CTransaction.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransaction::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransaction.data)
}
inline std::string* CTransaction::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:CTransaction.data)
  return _s;
}
inline const std::string& CTransaction::_internal_data() const {
  return _impl_.data_.Get();
}
inline void CTransaction::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* CTransaction::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* CTransaction::release_data() {
  // @@protoc_insertion_point(field_release:CTransaction.data)
  return _impl_.data_.Release();
}
inline void CTransaction::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransaction.data)
}

// string info = 11;
inline void CTransaction::clear_info() {
  _impl_.info_.ClearToEmpty();
}
inline const std::string& CTransaction::info() const {
  // @@protoc_insertion_point(field_get:CTransaction.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransaction::set_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransaction.info)
}
inline std::string* CTransaction::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:CTransaction.info)
  return _s;
}
inline const std::string& CTransaction::_internal_info() const {
  return _impl_.info_.Get();
}
inline void CTransaction::_internal_set_info(const std::string& value) {
  
  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* CTransaction::_internal_mutable_info() {
  
  return _impl_.info_.Mutable(GetArenaForAllocation());
}
inline std::string* CTransaction::release_info() {
  // @@protoc_insertion_point(field_release:CTransaction.info)
  return _impl_.info_.Release();
}
inline void CTransaction::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  _impl_.info_.SetAllocated(info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransaction.info)
}

// repeated .CSign verifySign = 12;
inline int CTransaction::_internal_verifysign_size() const {
  return _impl_.verifysign_.size();
}
inline int CTransaction::verifysign_size() const {
  return _internal_verifysign_size();
}
inline ::CSign* CTransaction::mutable_verifysign(int index) {
  // @@protoc_insertion_point(field_mutable:CTransaction.verifySign)
  return _impl_.verifysign_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >*
CTransaction::mutable_verifysign() {
  // @@protoc_insertion_point(field_mutable_list:CTransaction.verifySign)
  return &_impl_.verifysign_;
}
inline const ::CSign& CTransaction::_internal_verifysign(int index) const {
  return _impl_.verifysign_.Get(index);
}
inline const ::CSign& CTransaction::verifysign(int index) const {
  // @@protoc_insertion_point(field_get:CTransaction.verifySign)
  return _internal_verifysign(index);
}
inline ::CSign* CTransaction::_internal_add_verifysign() {
  return _impl_.verifysign_.Add();
}
inline ::CSign* CTransaction::add_verifysign() {
  ::CSign* _add = _internal_add_verifysign();
  // @@protoc_insertion_point(field_add:CTransaction.verifySign)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSign >&
CTransaction::verifysign() const {
  // @@protoc_insertion_point(field_list:CTransaction.verifySign)
  return _impl_.verifysign_;
}

// string reserve0 = 13;
inline void CTransaction::clear_reserve0() {
  _impl_.reserve0_.ClearToEmpty();
}
inline const std::string& CTransaction::reserve0() const {
  // @@protoc_insertion_point(field_get:CTransaction.reserve0)
  return _internal_reserve0();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransaction::set_reserve0(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reserve0_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransaction.reserve0)
}
inline std::string* CTransaction::mutable_reserve0() {
  std::string* _s = _internal_mutable_reserve0();
  // @@protoc_insertion_point(field_mutable:CTransaction.reserve0)
  return _s;
}
inline const std::string& CTransaction::_internal_reserve0() const {
  return _impl_.reserve0_.Get();
}
inline void CTransaction::_internal_set_reserve0(const std::string& value) {
  
  _impl_.reserve0_.Set(value, GetArenaForAllocation());
}
inline std::string* CTransaction::_internal_mutable_reserve0() {
  
  return _impl_.reserve0_.Mutable(GetArenaForAllocation());
}
inline std::string* CTransaction::release_reserve0() {
  // @@protoc_insertion_point(field_release:CTransaction.reserve0)
  return _impl_.reserve0_.Release();
}
inline void CTransaction::set_allocated_reserve0(std::string* reserve0) {
  if (reserve0 != nullptr) {
    
  } else {
    
  }
  _impl_.reserve0_.SetAllocated(reserve0, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reserve0_.IsDefault()) {
    _impl_.reserve0_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransaction.reserve0)
}

// string reserve1 = 14;
inline void CTransaction::clear_reserve1() {
  _impl_.reserve1_.ClearToEmpty();
}
inline const std::string& CTransaction::reserve1() const {
  // @@protoc_insertion_point(field_get:CTransaction.reserve1)
  return _internal_reserve1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransaction::set_reserve1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reserve1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransaction.reserve1)
}
inline std::string* CTransaction::mutable_reserve1() {
  std::string* _s = _internal_mutable_reserve1();
  // @@protoc_insertion_point(field_mutable:CTransaction.reserve1)
  return _s;
}
inline const std::string& CTransaction::_internal_reserve1() const {
  return _impl_.reserve1_.Get();
}
inline void CTransaction::_internal_set_reserve1(const std::string& value) {
  
  _impl_.reserve1_.Set(value, GetArenaForAllocation());
}
inline std::string* CTransaction::_internal_mutable_reserve1() {
  
  return _impl_.reserve1_.Mutable(GetArenaForAllocation());
}
inline std::string* CTransaction::release_reserve1() {
  // @@protoc_insertion_point(field_release:CTransaction.reserve1)
  return _impl_.reserve1_.Release();
}
inline void CTransaction::set_allocated_reserve1(std::string* reserve1) {
  if (reserve1 != nullptr) {
    
  } else {
    
  }
  _impl_.reserve1_.SetAllocated(reserve1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reserve1_.IsDefault()) {
    _impl_.reserve1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransaction.reserve1)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transaction_2eproto
