// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_interface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_interface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_interface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_interface_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_interface_2eproto;
class BlockItem;
struct BlockItemDefaultTypeInternal;
extern BlockItemDefaultTypeInternal _BlockItem_default_instance_;
class BonusItem;
struct BonusItemDefaultTypeInternal;
extern BonusItemDefaultTypeInternal _BonusItem_default_instance_;
class CheckTxAck;
struct CheckTxAckDefaultTypeInternal;
extern CheckTxAckDefaultTypeInternal _CheckTxAck_default_instance_;
class CheckTxReq;
struct CheckTxReqDefaultTypeInternal;
extern CheckTxReqDefaultTypeInternal _CheckTxReq_default_instance_;
class ConfirmTransactionAck;
struct ConfirmTransactionAckDefaultTypeInternal;
extern ConfirmTransactionAckDefaultTypeInternal _ConfirmTransactionAck_default_instance_;
class ConfirmTransactionReq;
struct ConfirmTransactionReqDefaultTypeInternal;
extern ConfirmTransactionReqDefaultTypeInternal _ConfirmTransactionReq_default_instance_;
class CorresHash;
struct CorresHashDefaultTypeInternal;
extern CorresHashDefaultTypeInternal _CorresHash_default_instance_;
class GetAllInvestAddressAck;
struct GetAllInvestAddressAckDefaultTypeInternal;
extern GetAllInvestAddressAckDefaultTypeInternal _GetAllInvestAddressAck_default_instance_;
class GetAllInvestAddressReq;
struct GetAllInvestAddressReqDefaultTypeInternal;
extern GetAllInvestAddressReqDefaultTypeInternal _GetAllInvestAddressReq_default_instance_;
class GetAllStakeNodeListAck;
struct GetAllStakeNodeListAckDefaultTypeInternal;
extern GetAllStakeNodeListAckDefaultTypeInternal _GetAllStakeNodeListAck_default_instance_;
class GetAllStakeNodeListReq;
struct GetAllStakeNodeListReqDefaultTypeInternal;
extern GetAllStakeNodeListReqDefaultTypeInternal _GetAllStakeNodeListReq_default_instance_;
class GetBalanceAck;
struct GetBalanceAckDefaultTypeInternal;
extern GetBalanceAckDefaultTypeInternal _GetBalanceAck_default_instance_;
class GetBalanceReq;
struct GetBalanceReqDefaultTypeInternal;
extern GetBalanceReqDefaultTypeInternal _GetBalanceReq_default_instance_;
class GetBlockAck;
struct GetBlockAckDefaultTypeInternal;
extern GetBlockAckDefaultTypeInternal _GetBlockAck_default_instance_;
class GetBlockReq;
struct GetBlockReqDefaultTypeInternal;
extern GetBlockReqDefaultTypeInternal _GetBlockReq_default_instance_;
class GetBonusListAck;
struct GetBonusListAckDefaultTypeInternal;
extern GetBonusListAckDefaultTypeInternal _GetBonusListAck_default_instance_;
class GetBonusListReq;
struct GetBonusListReqDefaultTypeInternal;
extern GetBonusListReqDefaultTypeInternal _GetBonusListReq_default_instance_;
class GetHeightAck;
struct GetHeightAckDefaultTypeInternal;
extern GetHeightAckDefaultTypeInternal _GetHeightAck_default_instance_;
class GetHeightReq;
struct GetHeightReqDefaultTypeInternal;
extern GetHeightReqDefaultTypeInternal _GetHeightReq_default_instance_;
class GetInvestListAck;
struct GetInvestListAckDefaultTypeInternal;
extern GetInvestListAckDefaultTypeInternal _GetInvestListAck_default_instance_;
class GetInvestListReq;
struct GetInvestListReqDefaultTypeInternal;
extern GetInvestListReqDefaultTypeInternal _GetInvestListReq_default_instance_;
class GetNodeInfoAck;
struct GetNodeInfoAckDefaultTypeInternal;
extern GetNodeInfoAckDefaultTypeInternal _GetNodeInfoAck_default_instance_;
class GetNodeInfoReq;
struct GetNodeInfoReqDefaultTypeInternal;
extern GetNodeInfoReqDefaultTypeInternal _GetNodeInfoReq_default_instance_;
class GetRestInvestAmountAck;
struct GetRestInvestAmountAckDefaultTypeInternal;
extern GetRestInvestAmountAckDefaultTypeInternal _GetRestInvestAmountAck_default_instance_;
class GetRestInvestAmountReq;
struct GetRestInvestAmountReqDefaultTypeInternal;
extern GetRestInvestAmountReqDefaultTypeInternal _GetRestInvestAmountReq_default_instance_;
class GetSignCountListAck;
struct GetSignCountListAckDefaultTypeInternal;
extern GetSignCountListAckDefaultTypeInternal _GetSignCountListAck_default_instance_;
class GetSignCountListReq;
struct GetSignCountListReqDefaultTypeInternal;
extern GetSignCountListReqDefaultTypeInternal _GetSignCountListReq_default_instance_;
class GetStakeListAck;
struct GetStakeListAckDefaultTypeInternal;
extern GetStakeListAckDefaultTypeInternal _GetStakeListAck_default_instance_;
class GetStakeListReq;
struct GetStakeListReqDefaultTypeInternal;
extern GetStakeListReqDefaultTypeInternal _GetStakeListReq_default_instance_;
class GetTransactionStatusListAck;
struct GetTransactionStatusListAckDefaultTypeInternal;
extern GetTransactionStatusListAckDefaultTypeInternal _GetTransactionStatusListAck_default_instance_;
class GetTransactionStatusListReq;
struct GetTransactionStatusListReqDefaultTypeInternal;
extern GetTransactionStatusListReqDefaultTypeInternal _GetTransactionStatusListReq_default_instance_;
class GetTxFailureListAck;
struct GetTxFailureListAckDefaultTypeInternal;
extern GetTxFailureListAckDefaultTypeInternal _GetTxFailureListAck_default_instance_;
class GetTxFailureListReq;
struct GetTxFailureListReqDefaultTypeInternal;
extern GetTxFailureListReqDefaultTypeInternal _GetTxFailureListReq_default_instance_;
class GetTxPendingListAck;
struct GetTxPendingListAckDefaultTypeInternal;
extern GetTxPendingListAckDefaultTypeInternal _GetTxPendingListAck_default_instance_;
class GetTxPendingListReq;
struct GetTxPendingListReqDefaultTypeInternal;
extern GetTxPendingListReqDefaultTypeInternal _GetTxPendingListReq_default_instance_;
class GetUtxoAck;
struct GetUtxoAckDefaultTypeInternal;
extern GetUtxoAckDefaultTypeInternal _GetUtxoAck_default_instance_;
class GetUtxoHashAck;
struct GetUtxoHashAckDefaultTypeInternal;
extern GetUtxoHashAckDefaultTypeInternal _GetUtxoHashAck_default_instance_;
class GetUtxoHashReq;
struct GetUtxoHashReqDefaultTypeInternal;
extern GetUtxoHashReqDefaultTypeInternal _GetUtxoHashReq_default_instance_;
class GetUtxoReq;
struct GetUtxoReqDefaultTypeInternal;
extern GetUtxoReqDefaultTypeInternal _GetUtxoReq_default_instance_;
class InvestAddressItem;
struct InvestAddressItemDefaultTypeInternal;
extern InvestAddressItemDefaultTypeInternal _InvestAddressItem_default_instance_;
class InvestItem;
struct InvestItemDefaultTypeInternal;
extern InvestItemDefaultTypeInternal _InvestItem_default_instance_;
class MultiSignTxAck;
struct MultiSignTxAckDefaultTypeInternal;
extern MultiSignTxAckDefaultTypeInternal _MultiSignTxAck_default_instance_;
class MultiSignTxReq;
struct MultiSignTxReqDefaultTypeInternal;
extern MultiSignTxReqDefaultTypeInternal _MultiSignTxReq_default_instance_;
class OtherStatusItem;
struct OtherStatusItemDefaultTypeInternal;
extern OtherStatusItemDefaultTypeInternal _OtherStatusItem_default_instance_;
class SelfVerifyStatusItem;
struct SelfVerifyStatusItemDefaultTypeInternal;
extern SelfVerifyStatusItemDefaultTypeInternal _SelfVerifyStatusItem_default_instance_;
class SignCount;
struct SignCountDefaultTypeInternal;
extern SignCountDefaultTypeInternal _SignCount_default_instance_;
class StakeItem;
struct StakeItemDefaultTypeInternal;
extern StakeItemDefaultTypeInternal _StakeItem_default_instance_;
class StakeNode;
struct StakeNodeDefaultTypeInternal;
extern StakeNodeDefaultTypeInternal _StakeNode_default_instance_;
class SuccessRate;
struct SuccessRateDefaultTypeInternal;
extern SuccessRateDefaultTypeInternal _SuccessRate_default_instance_;
class TransactionStatusItem;
struct TransactionStatusItemDefaultTypeInternal;
extern TransactionStatusItemDefaultTypeInternal _TransactionStatusItem_default_instance_;
class TxFailureItem;
struct TxFailureItemDefaultTypeInternal;
extern TxFailureItemDefaultTypeInternal _TxFailureItem_default_instance_;
class TxPendingItem;
struct TxPendingItemDefaultTypeInternal;
extern TxPendingItemDefaultTypeInternal _TxPendingItem_default_instance_;
class Utxo;
struct UtxoDefaultTypeInternal;
extern UtxoDefaultTypeInternal _Utxo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BlockItem* Arena::CreateMaybeMessage<::BlockItem>(Arena*);
template<> ::BonusItem* Arena::CreateMaybeMessage<::BonusItem>(Arena*);
template<> ::CheckTxAck* Arena::CreateMaybeMessage<::CheckTxAck>(Arena*);
template<> ::CheckTxReq* Arena::CreateMaybeMessage<::CheckTxReq>(Arena*);
template<> ::ConfirmTransactionAck* Arena::CreateMaybeMessage<::ConfirmTransactionAck>(Arena*);
template<> ::ConfirmTransactionReq* Arena::CreateMaybeMessage<::ConfirmTransactionReq>(Arena*);
template<> ::CorresHash* Arena::CreateMaybeMessage<::CorresHash>(Arena*);
template<> ::GetAllInvestAddressAck* Arena::CreateMaybeMessage<::GetAllInvestAddressAck>(Arena*);
template<> ::GetAllInvestAddressReq* Arena::CreateMaybeMessage<::GetAllInvestAddressReq>(Arena*);
template<> ::GetAllStakeNodeListAck* Arena::CreateMaybeMessage<::GetAllStakeNodeListAck>(Arena*);
template<> ::GetAllStakeNodeListReq* Arena::CreateMaybeMessage<::GetAllStakeNodeListReq>(Arena*);
template<> ::GetBalanceAck* Arena::CreateMaybeMessage<::GetBalanceAck>(Arena*);
template<> ::GetBalanceReq* Arena::CreateMaybeMessage<::GetBalanceReq>(Arena*);
template<> ::GetBlockAck* Arena::CreateMaybeMessage<::GetBlockAck>(Arena*);
template<> ::GetBlockReq* Arena::CreateMaybeMessage<::GetBlockReq>(Arena*);
template<> ::GetBonusListAck* Arena::CreateMaybeMessage<::GetBonusListAck>(Arena*);
template<> ::GetBonusListReq* Arena::CreateMaybeMessage<::GetBonusListReq>(Arena*);
template<> ::GetHeightAck* Arena::CreateMaybeMessage<::GetHeightAck>(Arena*);
template<> ::GetHeightReq* Arena::CreateMaybeMessage<::GetHeightReq>(Arena*);
template<> ::GetInvestListAck* Arena::CreateMaybeMessage<::GetInvestListAck>(Arena*);
template<> ::GetInvestListReq* Arena::CreateMaybeMessage<::GetInvestListReq>(Arena*);
template<> ::GetNodeInfoAck* Arena::CreateMaybeMessage<::GetNodeInfoAck>(Arena*);
template<> ::GetNodeInfoReq* Arena::CreateMaybeMessage<::GetNodeInfoReq>(Arena*);
template<> ::GetRestInvestAmountAck* Arena::CreateMaybeMessage<::GetRestInvestAmountAck>(Arena*);
template<> ::GetRestInvestAmountReq* Arena::CreateMaybeMessage<::GetRestInvestAmountReq>(Arena*);
template<> ::GetSignCountListAck* Arena::CreateMaybeMessage<::GetSignCountListAck>(Arena*);
template<> ::GetSignCountListReq* Arena::CreateMaybeMessage<::GetSignCountListReq>(Arena*);
template<> ::GetStakeListAck* Arena::CreateMaybeMessage<::GetStakeListAck>(Arena*);
template<> ::GetStakeListReq* Arena::CreateMaybeMessage<::GetStakeListReq>(Arena*);
template<> ::GetTransactionStatusListAck* Arena::CreateMaybeMessage<::GetTransactionStatusListAck>(Arena*);
template<> ::GetTransactionStatusListReq* Arena::CreateMaybeMessage<::GetTransactionStatusListReq>(Arena*);
template<> ::GetTxFailureListAck* Arena::CreateMaybeMessage<::GetTxFailureListAck>(Arena*);
template<> ::GetTxFailureListReq* Arena::CreateMaybeMessage<::GetTxFailureListReq>(Arena*);
template<> ::GetTxPendingListAck* Arena::CreateMaybeMessage<::GetTxPendingListAck>(Arena*);
template<> ::GetTxPendingListReq* Arena::CreateMaybeMessage<::GetTxPendingListReq>(Arena*);
template<> ::GetUtxoAck* Arena::CreateMaybeMessage<::GetUtxoAck>(Arena*);
template<> ::GetUtxoHashAck* Arena::CreateMaybeMessage<::GetUtxoHashAck>(Arena*);
template<> ::GetUtxoHashReq* Arena::CreateMaybeMessage<::GetUtxoHashReq>(Arena*);
template<> ::GetUtxoReq* Arena::CreateMaybeMessage<::GetUtxoReq>(Arena*);
template<> ::InvestAddressItem* Arena::CreateMaybeMessage<::InvestAddressItem>(Arena*);
template<> ::InvestItem* Arena::CreateMaybeMessage<::InvestItem>(Arena*);
template<> ::MultiSignTxAck* Arena::CreateMaybeMessage<::MultiSignTxAck>(Arena*);
template<> ::MultiSignTxReq* Arena::CreateMaybeMessage<::MultiSignTxReq>(Arena*);
template<> ::OtherStatusItem* Arena::CreateMaybeMessage<::OtherStatusItem>(Arena*);
template<> ::SelfVerifyStatusItem* Arena::CreateMaybeMessage<::SelfVerifyStatusItem>(Arena*);
template<> ::SignCount* Arena::CreateMaybeMessage<::SignCount>(Arena*);
template<> ::StakeItem* Arena::CreateMaybeMessage<::StakeItem>(Arena*);
template<> ::StakeNode* Arena::CreateMaybeMessage<::StakeNode>(Arena*);
template<> ::SuccessRate* Arena::CreateMaybeMessage<::SuccessRate>(Arena*);
template<> ::TransactionStatusItem* Arena::CreateMaybeMessage<::TransactionStatusItem>(Arena*);
template<> ::TxFailureItem* Arena::CreateMaybeMessage<::TxFailureItem>(Arena*);
template<> ::TxPendingItem* Arena::CreateMaybeMessage<::TxPendingItem>(Arena*);
template<> ::Utxo* Arena::CreateMaybeMessage<::Utxo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum TxType : int {
  TxTypeUnknown = 0,
  TxTypeTx = 1,
  TxTypeStake = 2,
  TxTypeUnstake = 3,
  TxTypeInvest = 4,
  TxTypeDisinvest = 5,
  TxTypeBonus = 6,
  TxType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TxType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TxType_IsValid(int value);
constexpr TxType TxType_MIN = TxTypeUnknown;
constexpr TxType TxType_MAX = TxTypeBonus;
constexpr int TxType_ARRAYSIZE = TxType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxType_descriptor();
template<typename T>
inline const std::string& TxType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TxType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TxType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TxType_descriptor(), enum_t_value);
}
inline bool TxType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TxType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TxType>(
    TxType_descriptor(), name, value);
}
// ===================================================================

class GetBlockReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBlockReq) */ {
 public:
  inline GetBlockReq() : GetBlockReq(nullptr) {}
  ~GetBlockReq() override;
  explicit PROTOBUF_CONSTEXPR GetBlockReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockReq(const GetBlockReq& from);
  GetBlockReq(GetBlockReq&& from) noexcept
    : GetBlockReq() {
    *this = ::std::move(from);
  }

  inline GetBlockReq& operator=(const GetBlockReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockReq& operator=(GetBlockReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockReq* internal_default_instance() {
    return reinterpret_cast<const GetBlockReq*>(
               &_GetBlockReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetBlockReq& a, GetBlockReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockReq& from) {
    GetBlockReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBlockReq";
  }
  protected:
  explicit GetBlockReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 height = 2;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetBlockReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class BlockItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BlockItem) */ {
 public:
  inline BlockItem() : BlockItem(nullptr) {}
  ~BlockItem() override;
  explicit PROTOBUF_CONSTEXPR BlockItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockItem(const BlockItem& from);
  BlockItem(BlockItem&& from) noexcept
    : BlockItem() {
    *this = ::std::move(from);
  }

  inline BlockItem& operator=(const BlockItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockItem& operator=(BlockItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockItem* internal_default_instance() {
    return reinterpret_cast<const BlockItem*>(
               &_BlockItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlockItem& a, BlockItem& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockItem& from) {
    BlockItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BlockItem";
  }
  protected:
  explicit BlockItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 2,
    kBlockhashFieldNumber = 1,
  };
  // repeated string addr = 2;
  int addr_size() const;
  private:
  int _internal_addr_size() const;
  public:
  void clear_addr();
  const std::string& addr(int index) const;
  std::string* mutable_addr(int index);
  void set_addr(int index, const std::string& value);
  void set_addr(int index, std::string&& value);
  void set_addr(int index, const char* value);
  void set_addr(int index, const char* value, size_t size);
  std::string* add_addr();
  void add_addr(const std::string& value);
  void add_addr(std::string&& value);
  void add_addr(const char* value);
  void add_addr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addr();
  private:
  const std::string& _internal_addr(int index) const;
  std::string* _internal_add_addr();
  public:

  // string blockhash = 1;
  void clear_blockhash();
  const std::string& blockhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockhash();
  PROTOBUF_NODISCARD std::string* release_blockhash();
  void set_allocated_blockhash(std::string* blockhash);
  private:
  const std::string& _internal_blockhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const std::string& value);
  std::string* _internal_mutable_blockhash();
  public:

  // @@protoc_insertion_point(class_scope:BlockItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockhash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetBlockAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBlockAck) */ {
 public:
  inline GetBlockAck() : GetBlockAck(nullptr) {}
  ~GetBlockAck() override;
  explicit PROTOBUF_CONSTEXPR GetBlockAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockAck(const GetBlockAck& from);
  GetBlockAck(GetBlockAck&& from) noexcept
    : GetBlockAck() {
    *this = ::std::move(from);
  }

  inline GetBlockAck& operator=(const GetBlockAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockAck& operator=(GetBlockAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockAck* internal_default_instance() {
    return reinterpret_cast<const GetBlockAck*>(
               &_GetBlockAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetBlockAck& a, GetBlockAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBlockAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBlockAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBlockAck& from) {
    GetBlockAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBlockAck";
  }
  protected:
  explicit GetBlockAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 6,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kHeightFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kCodeFieldNumber = 2,
  };
  // repeated .BlockItem list = 6;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::BlockItem* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BlockItem >*
      mutable_list();
  private:
  const ::BlockItem& _internal_list(int index) const;
  ::BlockItem* _internal_add_list();
  public:
  const ::BlockItem& list(int index) const;
  ::BlockItem* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BlockItem >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 height = 4;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetBlockAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BlockItem > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t height_;
    uint64_t timestamp_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetBalanceReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBalanceReq) */ {
 public:
  inline GetBalanceReq() : GetBalanceReq(nullptr) {}
  ~GetBalanceReq() override;
  explicit PROTOBUF_CONSTEXPR GetBalanceReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBalanceReq(const GetBalanceReq& from);
  GetBalanceReq(GetBalanceReq&& from) noexcept
    : GetBalanceReq() {
    *this = ::std::move(from);
  }

  inline GetBalanceReq& operator=(const GetBalanceReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBalanceReq& operator=(GetBalanceReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBalanceReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBalanceReq* internal_default_instance() {
    return reinterpret_cast<const GetBalanceReq*>(
               &_GetBalanceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetBalanceReq& a, GetBalanceReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBalanceReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBalanceReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBalanceReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBalanceReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBalanceReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBalanceReq& from) {
    GetBalanceReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBalanceReq";
  }
  protected:
  explicit GetBalanceReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:GetBalanceReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetBalanceAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBalanceAck) */ {
 public:
  inline GetBalanceAck() : GetBalanceAck(nullptr) {}
  ~GetBalanceAck() override;
  explicit PROTOBUF_CONSTEXPR GetBalanceAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBalanceAck(const GetBalanceAck& from);
  GetBalanceAck(GetBalanceAck&& from) noexcept
    : GetBalanceAck() {
    *this = ::std::move(from);
  }

  inline GetBalanceAck& operator=(const GetBalanceAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBalanceAck& operator=(GetBalanceAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBalanceAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBalanceAck* internal_default_instance() {
    return reinterpret_cast<const GetBalanceAck*>(
               &_GetBalanceAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetBalanceAck& a, GetBalanceAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBalanceAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBalanceAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBalanceAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBalanceAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBalanceAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBalanceAck& from) {
    GetBalanceAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBalanceAck";
  }
  protected:
  explicit GetBalanceAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kAddressFieldNumber = 4,
    kBalanceFieldNumber = 5,
    kHeightFieldNumber = 6,
    kCodeFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string address = 4;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 balance = 5;
  void clear_balance();
  uint64_t balance() const;
  void set_balance(uint64_t value);
  private:
  uint64_t _internal_balance() const;
  void _internal_set_balance(uint64_t value);
  public:

  // uint64 height = 6;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetBalanceAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    uint64_t balance_;
    uint64_t height_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetNodeInfoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetNodeInfoReq) */ {
 public:
  inline GetNodeInfoReq() : GetNodeInfoReq(nullptr) {}
  ~GetNodeInfoReq() override;
  explicit PROTOBUF_CONSTEXPR GetNodeInfoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNodeInfoReq(const GetNodeInfoReq& from);
  GetNodeInfoReq(GetNodeInfoReq&& from) noexcept
    : GetNodeInfoReq() {
    *this = ::std::move(from);
  }

  inline GetNodeInfoReq& operator=(const GetNodeInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodeInfoReq& operator=(GetNodeInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodeInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodeInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetNodeInfoReq*>(
               &_GetNodeInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetNodeInfoReq& a, GetNodeInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNodeInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodeInfoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodeInfoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNodeInfoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNodeInfoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNodeInfoReq& from) {
    GetNodeInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNodeInfoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetNodeInfoReq";
  }
  protected:
  explicit GetNodeInfoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:GetNodeInfoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetNodeInfoAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetNodeInfoAck) */ {
 public:
  inline GetNodeInfoAck() : GetNodeInfoAck(nullptr) {}
  ~GetNodeInfoAck() override;
  explicit PROTOBUF_CONSTEXPR GetNodeInfoAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNodeInfoAck(const GetNodeInfoAck& from);
  GetNodeInfoAck(GetNodeInfoAck&& from) noexcept
    : GetNodeInfoAck() {
    *this = ::std::move(from);
  }

  inline GetNodeInfoAck& operator=(const GetNodeInfoAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodeInfoAck& operator=(GetNodeInfoAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodeInfoAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodeInfoAck* internal_default_instance() {
    return reinterpret_cast<const GetNodeInfoAck*>(
               &_GetNodeInfoAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetNodeInfoAck& a, GetNodeInfoAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNodeInfoAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodeInfoAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodeInfoAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNodeInfoAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNodeInfoAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNodeInfoAck& from) {
    GetNodeInfoAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNodeInfoAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetNodeInfoAck";
  }
  protected:
  explicit GetNodeInfoAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kAddressFieldNumber = 4,
    kIpFieldNumber = 5,
    kVerFieldNumber = 8,
    kHeightFieldNumber = 6,
    kGasFieldNumber = 7,
    kCodeFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string address = 4;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string ip = 5;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string ver = 8;
  void clear_ver();
  const std::string& ver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ver();
  PROTOBUF_NODISCARD std::string* release_ver();
  void set_allocated_ver(std::string* ver);
  private:
  const std::string& _internal_ver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ver(const std::string& value);
  std::string* _internal_mutable_ver();
  public:

  // uint64 height = 6;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // uint64 gas = 7;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetNodeInfoAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ver_;
    uint64_t height_;
    uint64_t gas_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetStakeListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetStakeListReq) */ {
 public:
  inline GetStakeListReq() : GetStakeListReq(nullptr) {}
  ~GetStakeListReq() override;
  explicit PROTOBUF_CONSTEXPR GetStakeListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStakeListReq(const GetStakeListReq& from);
  GetStakeListReq(GetStakeListReq&& from) noexcept
    : GetStakeListReq() {
    *this = ::std::move(from);
  }

  inline GetStakeListReq& operator=(const GetStakeListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStakeListReq& operator=(GetStakeListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStakeListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStakeListReq* internal_default_instance() {
    return reinterpret_cast<const GetStakeListReq*>(
               &_GetStakeListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetStakeListReq& a, GetStakeListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStakeListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStakeListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStakeListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStakeListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStakeListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStakeListReq& from) {
    GetStakeListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStakeListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetStakeListReq";
  }
  protected:
  explicit GetStakeListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAddrFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:GetStakeListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class StakeItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StakeItem) */ {
 public:
  inline StakeItem() : StakeItem(nullptr) {}
  ~StakeItem() override;
  explicit PROTOBUF_CONSTEXPR StakeItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StakeItem(const StakeItem& from);
  StakeItem(StakeItem&& from) noexcept
    : StakeItem() {
    *this = ::std::move(from);
  }

  inline StakeItem& operator=(const StakeItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline StakeItem& operator=(StakeItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StakeItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const StakeItem* internal_default_instance() {
    return reinterpret_cast<const StakeItem*>(
               &_StakeItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StakeItem& a, StakeItem& b) {
    a.Swap(&b);
  }
  inline void Swap(StakeItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StakeItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StakeItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StakeItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StakeItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StakeItem& from) {
    StakeItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StakeItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StakeItem";
  }
  protected:
  explicit StakeItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockhashFieldNumber = 1,
    kUtxoFieldNumber = 3,
    kFromaddrFieldNumber = 6,
    kToaddrFieldNumber = 7,
    kDetailFieldNumber = 8,
    kAmountFieldNumber = 4,
    kTimeFieldNumber = 5,
    kBlockheightFieldNumber = 2,
  };
  // string blockhash = 1;
  void clear_blockhash();
  const std::string& blockhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockhash();
  PROTOBUF_NODISCARD std::string* release_blockhash();
  void set_allocated_blockhash(std::string* blockhash);
  private:
  const std::string& _internal_blockhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const std::string& value);
  std::string* _internal_mutable_blockhash();
  public:

  // string utxo = 3;
  void clear_utxo();
  const std::string& utxo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utxo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utxo();
  PROTOBUF_NODISCARD std::string* release_utxo();
  void set_allocated_utxo(std::string* utxo);
  private:
  const std::string& _internal_utxo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utxo(const std::string& value);
  std::string* _internal_mutable_utxo();
  public:

  // string fromaddr = 6;
  void clear_fromaddr();
  const std::string& fromaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fromaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fromaddr();
  PROTOBUF_NODISCARD std::string* release_fromaddr();
  void set_allocated_fromaddr(std::string* fromaddr);
  private:
  const std::string& _internal_fromaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromaddr(const std::string& value);
  std::string* _internal_mutable_fromaddr();
  public:

  // string toaddr = 7;
  void clear_toaddr();
  const std::string& toaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddr();
  PROTOBUF_NODISCARD std::string* release_toaddr();
  void set_allocated_toaddr(std::string* toaddr);
  private:
  const std::string& _internal_toaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddr(const std::string& value);
  std::string* _internal_mutable_toaddr();
  public:

  // string detail = 8;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // uint64 amount = 4;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // uint64 time = 5;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // uint32 blockheight = 2;
  void clear_blockheight();
  uint32_t blockheight() const;
  void set_blockheight(uint32_t value);
  private:
  uint32_t _internal_blockheight() const;
  void _internal_set_blockheight(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StakeItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utxo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    uint64_t amount_;
    uint64_t time_;
    uint32_t blockheight_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetStakeListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetStakeListAck) */ {
 public:
  inline GetStakeListAck() : GetStakeListAck(nullptr) {}
  ~GetStakeListAck() override;
  explicit PROTOBUF_CONSTEXPR GetStakeListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStakeListAck(const GetStakeListAck& from);
  GetStakeListAck(GetStakeListAck&& from) noexcept
    : GetStakeListAck() {
    *this = ::std::move(from);
  }

  inline GetStakeListAck& operator=(const GetStakeListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStakeListAck& operator=(GetStakeListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStakeListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStakeListAck* internal_default_instance() {
    return reinterpret_cast<const GetStakeListAck*>(
               &_GetStakeListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetStakeListAck& a, GetStakeListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStakeListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStakeListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStakeListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStakeListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStakeListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStakeListAck& from) {
    GetStakeListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStakeListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetStakeListAck";
  }
  protected:
  explicit GetStakeListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 4,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 2,
  };
  // repeated .StakeItem list = 4;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::StakeItem* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeItem >*
      mutable_list();
  private:
  const ::StakeItem& _internal_list(int index) const;
  ::StakeItem* _internal_add_list();
  public:
  const ::StakeItem& list(int index) const;
  ::StakeItem* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeItem >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetStakeListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeItem > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetInvestListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetInvestListReq) */ {
 public:
  inline GetInvestListReq() : GetInvestListReq(nullptr) {}
  ~GetInvestListReq() override;
  explicit PROTOBUF_CONSTEXPR GetInvestListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInvestListReq(const GetInvestListReq& from);
  GetInvestListReq(GetInvestListReq&& from) noexcept
    : GetInvestListReq() {
    *this = ::std::move(from);
  }

  inline GetInvestListReq& operator=(const GetInvestListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInvestListReq& operator=(GetInvestListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInvestListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInvestListReq* internal_default_instance() {
    return reinterpret_cast<const GetInvestListReq*>(
               &_GetInvestListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetInvestListReq& a, GetInvestListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInvestListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInvestListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInvestListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInvestListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInvestListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInvestListReq& from) {
    GetInvestListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInvestListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetInvestListReq";
  }
  protected:
  explicit GetInvestListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAddrFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:GetInvestListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InvestItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InvestItem) */ {
 public:
  inline InvestItem() : InvestItem(nullptr) {}
  ~InvestItem() override;
  explicit PROTOBUF_CONSTEXPR InvestItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvestItem(const InvestItem& from);
  InvestItem(InvestItem&& from) noexcept
    : InvestItem() {
    *this = ::std::move(from);
  }

  inline InvestItem& operator=(const InvestItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvestItem& operator=(InvestItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvestItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvestItem* internal_default_instance() {
    return reinterpret_cast<const InvestItem*>(
               &_InvestItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InvestItem& a, InvestItem& b) {
    a.Swap(&b);
  }
  inline void Swap(InvestItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvestItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvestItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvestItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvestItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvestItem& from) {
    InvestItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvestItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InvestItem";
  }
  protected:
  explicit InvestItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockhashFieldNumber = 1,
    kUtxoFieldNumber = 3,
    kFromaddrFieldNumber = 6,
    kToaddrFieldNumber = 7,
    kDetailFieldNumber = 8,
    kAmountFieldNumber = 4,
    kTimeFieldNumber = 5,
    kBlockheightFieldNumber = 2,
  };
  // string blockhash = 1;
  void clear_blockhash();
  const std::string& blockhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockhash();
  PROTOBUF_NODISCARD std::string* release_blockhash();
  void set_allocated_blockhash(std::string* blockhash);
  private:
  const std::string& _internal_blockhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const std::string& value);
  std::string* _internal_mutable_blockhash();
  public:

  // string utxo = 3;
  void clear_utxo();
  const std::string& utxo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utxo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utxo();
  PROTOBUF_NODISCARD std::string* release_utxo();
  void set_allocated_utxo(std::string* utxo);
  private:
  const std::string& _internal_utxo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utxo(const std::string& value);
  std::string* _internal_mutable_utxo();
  public:

  // string fromaddr = 6;
  void clear_fromaddr();
  const std::string& fromaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fromaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fromaddr();
  PROTOBUF_NODISCARD std::string* release_fromaddr();
  void set_allocated_fromaddr(std::string* fromaddr);
  private:
  const std::string& _internal_fromaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromaddr(const std::string& value);
  std::string* _internal_mutable_fromaddr();
  public:

  // string toaddr = 7;
  void clear_toaddr();
  const std::string& toaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaddr();
  PROTOBUF_NODISCARD std::string* release_toaddr();
  void set_allocated_toaddr(std::string* toaddr);
  private:
  const std::string& _internal_toaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaddr(const std::string& value);
  std::string* _internal_mutable_toaddr();
  public:

  // string detail = 8;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // uint64 amount = 4;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // uint64 time = 5;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // uint32 blockheight = 2;
  void clear_blockheight();
  uint32_t blockheight() const;
  void set_blockheight(uint32_t value);
  private:
  uint32_t _internal_blockheight() const;
  void _internal_set_blockheight(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:InvestItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utxo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaddr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    uint64_t amount_;
    uint64_t time_;
    uint32_t blockheight_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetInvestListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetInvestListAck) */ {
 public:
  inline GetInvestListAck() : GetInvestListAck(nullptr) {}
  ~GetInvestListAck() override;
  explicit PROTOBUF_CONSTEXPR GetInvestListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetInvestListAck(const GetInvestListAck& from);
  GetInvestListAck(GetInvestListAck&& from) noexcept
    : GetInvestListAck() {
    *this = ::std::move(from);
  }

  inline GetInvestListAck& operator=(const GetInvestListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInvestListAck& operator=(GetInvestListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetInvestListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetInvestListAck* internal_default_instance() {
    return reinterpret_cast<const GetInvestListAck*>(
               &_GetInvestListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetInvestListAck& a, GetInvestListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInvestListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInvestListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetInvestListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetInvestListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetInvestListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetInvestListAck& from) {
    GetInvestListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInvestListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetInvestListAck";
  }
  protected:
  explicit GetInvestListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 4,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 2,
  };
  // repeated .InvestItem list = 4;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::InvestItem* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestItem >*
      mutable_list();
  private:
  const ::InvestItem& _internal_list(int index) const;
  ::InvestItem* _internal_add_list();
  public:
  const ::InvestItem& list(int index) const;
  ::InvestItem* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestItem >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetInvestListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestItem > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetTxPendingListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetTxPendingListReq) */ {
 public:
  inline GetTxPendingListReq() : GetTxPendingListReq(nullptr) {}
  ~GetTxPendingListReq() override;
  explicit PROTOBUF_CONSTEXPR GetTxPendingListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxPendingListReq(const GetTxPendingListReq& from);
  GetTxPendingListReq(GetTxPendingListReq&& from) noexcept
    : GetTxPendingListReq() {
    *this = ::std::move(from);
  }

  inline GetTxPendingListReq& operator=(const GetTxPendingListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxPendingListReq& operator=(GetTxPendingListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxPendingListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxPendingListReq* internal_default_instance() {
    return reinterpret_cast<const GetTxPendingListReq*>(
               &_GetTxPendingListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetTxPendingListReq& a, GetTxPendingListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxPendingListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxPendingListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxPendingListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxPendingListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxPendingListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxPendingListReq& from) {
    GetTxPendingListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxPendingListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetTxPendingListReq";
  }
  protected:
  explicit GetTxPendingListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated string addr = 2;
  int addr_size() const;
  private:
  int _internal_addr_size() const;
  public:
  void clear_addr();
  const std::string& addr(int index) const;
  std::string* mutable_addr(int index);
  void set_addr(int index, const std::string& value);
  void set_addr(int index, std::string&& value);
  void set_addr(int index, const char* value);
  void set_addr(int index, const char* value, size_t size);
  std::string* add_addr();
  void add_addr(const std::string& value);
  void add_addr(std::string&& value);
  void add_addr(const char* value);
  void add_addr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addr();
  private:
  const std::string& _internal_addr(int index) const;
  std::string* _internal_add_addr();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:GetTxPendingListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TxPendingItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxPendingItem) */ {
 public:
  inline TxPendingItem() : TxPendingItem(nullptr) {}
  ~TxPendingItem() override;
  explicit PROTOBUF_CONSTEXPR TxPendingItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxPendingItem(const TxPendingItem& from);
  TxPendingItem(TxPendingItem&& from) noexcept
    : TxPendingItem() {
    *this = ::std::move(from);
  }

  inline TxPendingItem& operator=(const TxPendingItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxPendingItem& operator=(TxPendingItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxPendingItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxPendingItem* internal_default_instance() {
    return reinterpret_cast<const TxPendingItem*>(
               &_TxPendingItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TxPendingItem& a, TxPendingItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TxPendingItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxPendingItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxPendingItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxPendingItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxPendingItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxPendingItem& from) {
    TxPendingItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxPendingItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxPendingItem";
  }
  protected:
  explicit TxPendingItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVinsFieldNumber = 2,
    kFromaddrFieldNumber = 3,
    kToaddrFieldNumber = 4,
    kToAmountFieldNumber = 9,
    kTxHashFieldNumber = 1,
    kDetailFieldNumber = 7,
    kAmountFieldNumber = 5,
    kTimeFieldNumber = 6,
    kGasFieldNumber = 8,
    kTypeFieldNumber = 10,
  };
  // repeated string vins = 2;
  int vins_size() const;
  private:
  int _internal_vins_size() const;
  public:
  void clear_vins();
  const std::string& vins(int index) const;
  std::string* mutable_vins(int index);
  void set_vins(int index, const std::string& value);
  void set_vins(int index, std::string&& value);
  void set_vins(int index, const char* value);
  void set_vins(int index, const char* value, size_t size);
  std::string* add_vins();
  void add_vins(const std::string& value);
  void add_vins(std::string&& value);
  void add_vins(const char* value);
  void add_vins(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vins();
  private:
  const std::string& _internal_vins(int index) const;
  std::string* _internal_add_vins();
  public:

  // repeated string fromaddr = 3;
  int fromaddr_size() const;
  private:
  int _internal_fromaddr_size() const;
  public:
  void clear_fromaddr();
  const std::string& fromaddr(int index) const;
  std::string* mutable_fromaddr(int index);
  void set_fromaddr(int index, const std::string& value);
  void set_fromaddr(int index, std::string&& value);
  void set_fromaddr(int index, const char* value);
  void set_fromaddr(int index, const char* value, size_t size);
  std::string* add_fromaddr();
  void add_fromaddr(const std::string& value);
  void add_fromaddr(std::string&& value);
  void add_fromaddr(const char* value);
  void add_fromaddr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fromaddr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fromaddr();
  private:
  const std::string& _internal_fromaddr(int index) const;
  std::string* _internal_add_fromaddr();
  public:

  // repeated string toaddr = 4;
  int toaddr_size() const;
  private:
  int _internal_toaddr_size() const;
  public:
  void clear_toaddr();
  const std::string& toaddr(int index) const;
  std::string* mutable_toaddr(int index);
  void set_toaddr(int index, const std::string& value);
  void set_toaddr(int index, std::string&& value);
  void set_toaddr(int index, const char* value);
  void set_toaddr(int index, const char* value, size_t size);
  std::string* add_toaddr();
  void add_toaddr(const std::string& value);
  void add_toaddr(std::string&& value);
  void add_toaddr(const char* value);
  void add_toaddr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& toaddr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_toaddr();
  private:
  const std::string& _internal_toaddr(int index) const;
  std::string* _internal_add_toaddr();
  public:

  // repeated uint64 toAmount = 9;
  int toamount_size() const;
  private:
  int _internal_toamount_size() const;
  public:
  void clear_toamount();
  private:
  uint64_t _internal_toamount(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_toamount() const;
  void _internal_add_toamount(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_toamount();
  public:
  uint64_t toamount(int index) const;
  void set_toamount(int index, uint64_t value);
  void add_toamount(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      toamount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_toamount();

  // string txHash = 1;
  void clear_txhash();
  const std::string& txhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txhash();
  PROTOBUF_NODISCARD std::string* release_txhash();
  void set_allocated_txhash(std::string* txhash);
  private:
  const std::string& _internal_txhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txhash(const std::string& value);
  std::string* _internal_mutable_txhash();
  public:

  // string detail = 7;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // uint64 amount = 5;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // uint64 time = 6;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // uint64 gas = 8;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // .TxType type = 10;
  void clear_type();
  ::TxType type() const;
  void set_type(::TxType value);
  private:
  ::TxType _internal_type() const;
  void _internal_set_type(::TxType value);
  public:

  // @@protoc_insertion_point(class_scope:TxPendingItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vins_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fromaddr_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> toaddr_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > toamount_;
    mutable std::atomic<int> _toamount_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    uint64_t amount_;
    uint64_t time_;
    uint64_t gas_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetTxPendingListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetTxPendingListAck) */ {
 public:
  inline GetTxPendingListAck() : GetTxPendingListAck(nullptr) {}
  ~GetTxPendingListAck() override;
  explicit PROTOBUF_CONSTEXPR GetTxPendingListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxPendingListAck(const GetTxPendingListAck& from);
  GetTxPendingListAck(GetTxPendingListAck&& from) noexcept
    : GetTxPendingListAck() {
    *this = ::std::move(from);
  }

  inline GetTxPendingListAck& operator=(const GetTxPendingListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxPendingListAck& operator=(GetTxPendingListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxPendingListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxPendingListAck* internal_default_instance() {
    return reinterpret_cast<const GetTxPendingListAck*>(
               &_GetTxPendingListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetTxPendingListAck& a, GetTxPendingListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxPendingListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxPendingListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxPendingListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxPendingListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxPendingListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxPendingListAck& from) {
    GetTxPendingListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxPendingListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetTxPendingListAck";
  }
  protected:
  explicit GetTxPendingListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 4,
    kListFieldNumber = 5,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 2,
  };
  // repeated string addr = 4;
  int addr_size() const;
  private:
  int _internal_addr_size() const;
  public:
  void clear_addr();
  const std::string& addr(int index) const;
  std::string* mutable_addr(int index);
  void set_addr(int index, const std::string& value);
  void set_addr(int index, std::string&& value);
  void set_addr(int index, const char* value);
  void set_addr(int index, const char* value, size_t size);
  std::string* add_addr();
  void add_addr(const std::string& value);
  void add_addr(std::string&& value);
  void add_addr(const char* value);
  void add_addr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addr();
  private:
  const std::string& _internal_addr(int index) const;
  std::string* _internal_add_addr();
  public:

  // repeated .TxPendingItem list = 5;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::TxPendingItem* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxPendingItem >*
      mutable_list();
  private:
  const ::TxPendingItem& _internal_list(int index) const;
  ::TxPendingItem* _internal_add_list();
  public:
  const ::TxPendingItem& list(int index) const;
  ::TxPendingItem* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxPendingItem >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetTxPendingListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addr_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxPendingItem > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetTxFailureListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetTxFailureListReq) */ {
 public:
  inline GetTxFailureListReq() : GetTxFailureListReq(nullptr) {}
  ~GetTxFailureListReq() override;
  explicit PROTOBUF_CONSTEXPR GetTxFailureListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxFailureListReq(const GetTxFailureListReq& from);
  GetTxFailureListReq(GetTxFailureListReq&& from) noexcept
    : GetTxFailureListReq() {
    *this = ::std::move(from);
  }

  inline GetTxFailureListReq& operator=(const GetTxFailureListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxFailureListReq& operator=(GetTxFailureListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxFailureListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxFailureListReq* internal_default_instance() {
    return reinterpret_cast<const GetTxFailureListReq*>(
               &_GetTxFailureListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetTxFailureListReq& a, GetTxFailureListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxFailureListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxFailureListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxFailureListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxFailureListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxFailureListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxFailureListReq& from) {
    GetTxFailureListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxFailureListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetTxFailureListReq";
  }
  protected:
  explicit GetTxFailureListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTxhashFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string txhash = 3;
  void clear_txhash();
  const std::string& txhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txhash();
  PROTOBUF_NODISCARD std::string* release_txhash();
  void set_allocated_txhash(std::string* txhash);
  private:
  const std::string& _internal_txhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txhash(const std::string& value);
  std::string* _internal_mutable_txhash();
  public:

  // uint32 count = 4;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetTxFailureListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txhash_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TxFailureItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxFailureItem) */ {
 public:
  inline TxFailureItem() : TxFailureItem(nullptr) {}
  ~TxFailureItem() override;
  explicit PROTOBUF_CONSTEXPR TxFailureItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxFailureItem(const TxFailureItem& from);
  TxFailureItem(TxFailureItem&& from) noexcept
    : TxFailureItem() {
    *this = ::std::move(from);
  }

  inline TxFailureItem& operator=(const TxFailureItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxFailureItem& operator=(TxFailureItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxFailureItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxFailureItem* internal_default_instance() {
    return reinterpret_cast<const TxFailureItem*>(
               &_TxFailureItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TxFailureItem& a, TxFailureItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TxFailureItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxFailureItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxFailureItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxFailureItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxFailureItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxFailureItem& from) {
    TxFailureItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxFailureItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxFailureItem";
  }
  protected:
  explicit TxFailureItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVinsFieldNumber = 2,
    kFromaddrFieldNumber = 3,
    kToaddrFieldNumber = 4,
    kToAmountFieldNumber = 9,
    kTxHashFieldNumber = 1,
    kDetailFieldNumber = 7,
    kAmountFieldNumber = 5,
    kTimeFieldNumber = 6,
    kGasFieldNumber = 8,
    kTypeFieldNumber = 10,
  };
  // repeated string vins = 2;
  int vins_size() const;
  private:
  int _internal_vins_size() const;
  public:
  void clear_vins();
  const std::string& vins(int index) const;
  std::string* mutable_vins(int index);
  void set_vins(int index, const std::string& value);
  void set_vins(int index, std::string&& value);
  void set_vins(int index, const char* value);
  void set_vins(int index, const char* value, size_t size);
  std::string* add_vins();
  void add_vins(const std::string& value);
  void add_vins(std::string&& value);
  void add_vins(const char* value);
  void add_vins(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& vins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_vins();
  private:
  const std::string& _internal_vins(int index) const;
  std::string* _internal_add_vins();
  public:

  // repeated string fromaddr = 3;
  int fromaddr_size() const;
  private:
  int _internal_fromaddr_size() const;
  public:
  void clear_fromaddr();
  const std::string& fromaddr(int index) const;
  std::string* mutable_fromaddr(int index);
  void set_fromaddr(int index, const std::string& value);
  void set_fromaddr(int index, std::string&& value);
  void set_fromaddr(int index, const char* value);
  void set_fromaddr(int index, const char* value, size_t size);
  std::string* add_fromaddr();
  void add_fromaddr(const std::string& value);
  void add_fromaddr(std::string&& value);
  void add_fromaddr(const char* value);
  void add_fromaddr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fromaddr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fromaddr();
  private:
  const std::string& _internal_fromaddr(int index) const;
  std::string* _internal_add_fromaddr();
  public:

  // repeated string toaddr = 4;
  int toaddr_size() const;
  private:
  int _internal_toaddr_size() const;
  public:
  void clear_toaddr();
  const std::string& toaddr(int index) const;
  std::string* mutable_toaddr(int index);
  void set_toaddr(int index, const std::string& value);
  void set_toaddr(int index, std::string&& value);
  void set_toaddr(int index, const char* value);
  void set_toaddr(int index, const char* value, size_t size);
  std::string* add_toaddr();
  void add_toaddr(const std::string& value);
  void add_toaddr(std::string&& value);
  void add_toaddr(const char* value);
  void add_toaddr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& toaddr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_toaddr();
  private:
  const std::string& _internal_toaddr(int index) const;
  std::string* _internal_add_toaddr();
  public:

  // repeated uint64 toAmount = 9;
  int toamount_size() const;
  private:
  int _internal_toamount_size() const;
  public:
  void clear_toamount();
  private:
  uint64_t _internal_toamount(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_toamount() const;
  void _internal_add_toamount(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_toamount();
  public:
  uint64_t toamount(int index) const;
  void set_toamount(int index, uint64_t value);
  void add_toamount(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      toamount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_toamount();

  // string txHash = 1;
  void clear_txhash();
  const std::string& txhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txhash();
  PROTOBUF_NODISCARD std::string* release_txhash();
  void set_allocated_txhash(std::string* txhash);
  private:
  const std::string& _internal_txhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txhash(const std::string& value);
  std::string* _internal_mutable_txhash();
  public:

  // string detail = 7;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // uint64 amount = 5;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // uint64 time = 6;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // uint64 gas = 8;
  void clear_gas();
  uint64_t gas() const;
  void set_gas(uint64_t value);
  private:
  uint64_t _internal_gas() const;
  void _internal_set_gas(uint64_t value);
  public:

  // .TxType type = 10;
  void clear_type();
  ::TxType type() const;
  void set_type(::TxType value);
  private:
  ::TxType _internal_type() const;
  void _internal_set_type(::TxType value);
  public:

  // @@protoc_insertion_point(class_scope:TxFailureItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> vins_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fromaddr_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> toaddr_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > toamount_;
    mutable std::atomic<int> _toamount_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    uint64_t amount_;
    uint64_t time_;
    uint64_t gas_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetTxFailureListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetTxFailureListAck) */ {
 public:
  inline GetTxFailureListAck() : GetTxFailureListAck(nullptr) {}
  ~GetTxFailureListAck() override;
  explicit PROTOBUF_CONSTEXPR GetTxFailureListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTxFailureListAck(const GetTxFailureListAck& from);
  GetTxFailureListAck(GetTxFailureListAck&& from) noexcept
    : GetTxFailureListAck() {
    *this = ::std::move(from);
  }

  inline GetTxFailureListAck& operator=(const GetTxFailureListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTxFailureListAck& operator=(GetTxFailureListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTxFailureListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTxFailureListAck* internal_default_instance() {
    return reinterpret_cast<const GetTxFailureListAck*>(
               &_GetTxFailureListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetTxFailureListAck& a, GetTxFailureListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTxFailureListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTxFailureListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTxFailureListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTxFailureListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTxFailureListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTxFailureListAck& from) {
    GetTxFailureListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTxFailureListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetTxFailureListAck";
  }
  protected:
  explicit GetTxFailureListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 5,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kLasthashFieldNumber = 6,
    kCodeFieldNumber = 2,
    kTotalFieldNumber = 4,
  };
  // repeated .TxFailureItem list = 5;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::TxFailureItem* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxFailureItem >*
      mutable_list();
  private:
  const ::TxFailureItem& _internal_list(int index) const;
  ::TxFailureItem* _internal_add_list();
  public:
  const ::TxFailureItem& list(int index) const;
  ::TxFailureItem* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxFailureItem >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string lasthash = 6;
  void clear_lasthash();
  const std::string& lasthash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lasthash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lasthash();
  PROTOBUF_NODISCARD std::string* release_lasthash();
  void set_allocated_lasthash(std::string* lasthash);
  private:
  const std::string& _internal_lasthash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lasthash(const std::string& value);
  std::string* _internal_mutable_lasthash();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // uint32 total = 4;
  void clear_total();
  uint32_t total() const;
  void set_total(uint32_t value);
  private:
  uint32_t _internal_total() const;
  void _internal_set_total(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetTxFailureListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxFailureItem > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lasthash_;
    int32_t code_;
    uint32_t total_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetUtxoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUtxoReq) */ {
 public:
  inline GetUtxoReq() : GetUtxoReq(nullptr) {}
  ~GetUtxoReq() override;
  explicit PROTOBUF_CONSTEXPR GetUtxoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUtxoReq(const GetUtxoReq& from);
  GetUtxoReq(GetUtxoReq&& from) noexcept
    : GetUtxoReq() {
    *this = ::std::move(from);
  }

  inline GetUtxoReq& operator=(const GetUtxoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUtxoReq& operator=(GetUtxoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUtxoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUtxoReq* internal_default_instance() {
    return reinterpret_cast<const GetUtxoReq*>(
               &_GetUtxoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetUtxoReq& a, GetUtxoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUtxoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUtxoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUtxoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUtxoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUtxoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUtxoReq& from) {
    GetUtxoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUtxoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUtxoReq";
  }
  protected:
  explicit GetUtxoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:GetUtxoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class Utxo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Utxo) */ {
 public:
  inline Utxo() : Utxo(nullptr) {}
  ~Utxo() override;
  explicit PROTOBUF_CONSTEXPR Utxo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Utxo(const Utxo& from);
  Utxo(Utxo&& from) noexcept
    : Utxo() {
    *this = ::std::move(from);
  }

  inline Utxo& operator=(const Utxo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Utxo& operator=(Utxo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Utxo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Utxo* internal_default_instance() {
    return reinterpret_cast<const Utxo*>(
               &_Utxo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Utxo& a, Utxo& b) {
    a.Swap(&b);
  }
  inline void Swap(Utxo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Utxo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Utxo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Utxo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Utxo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Utxo& from) {
    Utxo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Utxo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Utxo";
  }
  protected:
  explicit Utxo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kValueFieldNumber = 2,
    kNFieldNumber = 3,
  };
  // string hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // uint64 value = 2;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // uint32 n = 3;
  void clear_n();
  uint32_t n() const;
  void set_n(uint32_t value);
  private:
  uint32_t _internal_n() const;
  void _internal_set_n(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Utxo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    uint64_t value_;
    uint32_t n_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetUtxoAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUtxoAck) */ {
 public:
  inline GetUtxoAck() : GetUtxoAck(nullptr) {}
  ~GetUtxoAck() override;
  explicit PROTOBUF_CONSTEXPR GetUtxoAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUtxoAck(const GetUtxoAck& from);
  GetUtxoAck(GetUtxoAck&& from) noexcept
    : GetUtxoAck() {
    *this = ::std::move(from);
  }

  inline GetUtxoAck& operator=(const GetUtxoAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUtxoAck& operator=(GetUtxoAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUtxoAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUtxoAck* internal_default_instance() {
    return reinterpret_cast<const GetUtxoAck*>(
               &_GetUtxoAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GetUtxoAck& a, GetUtxoAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUtxoAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUtxoAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUtxoAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUtxoAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUtxoAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUtxoAck& from) {
    GetUtxoAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUtxoAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUtxoAck";
  }
  protected:
  explicit GetUtxoAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtxosFieldNumber = 5,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kAddressFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // repeated .Utxo utxos = 5;
  int utxos_size() const;
  private:
  int _internal_utxos_size() const;
  public:
  void clear_utxos();
  ::Utxo* mutable_utxos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Utxo >*
      mutable_utxos();
  private:
  const ::Utxo& _internal_utxos(int index) const;
  ::Utxo* _internal_add_utxos();
  public:
  const ::Utxo& utxos(int index) const;
  ::Utxo* add_utxos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Utxo >&
      utxos() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string address = 4;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetUtxoAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Utxo > utxos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetAllInvestAddressReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetAllInvestAddressReq) */ {
 public:
  inline GetAllInvestAddressReq() : GetAllInvestAddressReq(nullptr) {}
  ~GetAllInvestAddressReq() override;
  explicit PROTOBUF_CONSTEXPR GetAllInvestAddressReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllInvestAddressReq(const GetAllInvestAddressReq& from);
  GetAllInvestAddressReq(GetAllInvestAddressReq&& from) noexcept
    : GetAllInvestAddressReq() {
    *this = ::std::move(from);
  }

  inline GetAllInvestAddressReq& operator=(const GetAllInvestAddressReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllInvestAddressReq& operator=(GetAllInvestAddressReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllInvestAddressReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllInvestAddressReq* internal_default_instance() {
    return reinterpret_cast<const GetAllInvestAddressReq*>(
               &_GetAllInvestAddressReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetAllInvestAddressReq& a, GetAllInvestAddressReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllInvestAddressReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllInvestAddressReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllInvestAddressReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllInvestAddressReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllInvestAddressReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllInvestAddressReq& from) {
    GetAllInvestAddressReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllInvestAddressReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetAllInvestAddressReq";
  }
  protected:
  explicit GetAllInvestAddressReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAddrFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:GetAllInvestAddressReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class InvestAddressItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InvestAddressItem) */ {
 public:
  inline InvestAddressItem() : InvestAddressItem(nullptr) {}
  ~InvestAddressItem() override;
  explicit PROTOBUF_CONSTEXPR InvestAddressItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvestAddressItem(const InvestAddressItem& from);
  InvestAddressItem(InvestAddressItem&& from) noexcept
    : InvestAddressItem() {
    *this = ::std::move(from);
  }

  inline InvestAddressItem& operator=(const InvestAddressItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvestAddressItem& operator=(InvestAddressItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvestAddressItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvestAddressItem* internal_default_instance() {
    return reinterpret_cast<const InvestAddressItem*>(
               &_InvestAddressItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(InvestAddressItem& a, InvestAddressItem& b) {
    a.Swap(&b);
  }
  inline void Swap(InvestAddressItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvestAddressItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvestAddressItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvestAddressItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvestAddressItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InvestAddressItem& from) {
    InvestAddressItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvestAddressItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InvestAddressItem";
  }
  protected:
  explicit InvestAddressItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // uint64 value = 2;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:InvestAddressItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    uint64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetAllInvestAddressAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetAllInvestAddressAck) */ {
 public:
  inline GetAllInvestAddressAck() : GetAllInvestAddressAck(nullptr) {}
  ~GetAllInvestAddressAck() override;
  explicit PROTOBUF_CONSTEXPR GetAllInvestAddressAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllInvestAddressAck(const GetAllInvestAddressAck& from);
  GetAllInvestAddressAck(GetAllInvestAddressAck&& from) noexcept
    : GetAllInvestAddressAck() {
    *this = ::std::move(from);
  }

  inline GetAllInvestAddressAck& operator=(const GetAllInvestAddressAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllInvestAddressAck& operator=(GetAllInvestAddressAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllInvestAddressAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllInvestAddressAck* internal_default_instance() {
    return reinterpret_cast<const GetAllInvestAddressAck*>(
               &_GetAllInvestAddressAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GetAllInvestAddressAck& a, GetAllInvestAddressAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllInvestAddressAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllInvestAddressAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllInvestAddressAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllInvestAddressAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllInvestAddressAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllInvestAddressAck& from) {
    GetAllInvestAddressAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllInvestAddressAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetAllInvestAddressAck";
  }
  protected:
  explicit GetAllInvestAddressAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 5,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kAddrFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // repeated .InvestAddressItem list = 5;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::InvestAddressItem* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestAddressItem >*
      mutable_list();
  private:
  const ::InvestAddressItem& _internal_list(int index) const;
  ::InvestAddressItem* _internal_add_list();
  public:
  const ::InvestAddressItem& list(int index) const;
  ::InvestAddressItem* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestAddressItem >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string addr = 4;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetAllInvestAddressAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestAddressItem > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetAllStakeNodeListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetAllStakeNodeListReq) */ {
 public:
  inline GetAllStakeNodeListReq() : GetAllStakeNodeListReq(nullptr) {}
  ~GetAllStakeNodeListReq() override;
  explicit PROTOBUF_CONSTEXPR GetAllStakeNodeListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllStakeNodeListReq(const GetAllStakeNodeListReq& from);
  GetAllStakeNodeListReq(GetAllStakeNodeListReq&& from) noexcept
    : GetAllStakeNodeListReq() {
    *this = ::std::move(from);
  }

  inline GetAllStakeNodeListReq& operator=(const GetAllStakeNodeListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllStakeNodeListReq& operator=(GetAllStakeNodeListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllStakeNodeListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllStakeNodeListReq* internal_default_instance() {
    return reinterpret_cast<const GetAllStakeNodeListReq*>(
               &_GetAllStakeNodeListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetAllStakeNodeListReq& a, GetAllStakeNodeListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllStakeNodeListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllStakeNodeListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllStakeNodeListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllStakeNodeListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllStakeNodeListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllStakeNodeListReq& from) {
    GetAllStakeNodeListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllStakeNodeListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetAllStakeNodeListReq";
  }
  protected:
  explicit GetAllStakeNodeListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:GetAllStakeNodeListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class StakeNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StakeNode) */ {
 public:
  inline StakeNode() : StakeNode(nullptr) {}
  ~StakeNode() override;
  explicit PROTOBUF_CONSTEXPR StakeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StakeNode(const StakeNode& from);
  StakeNode(StakeNode&& from) noexcept
    : StakeNode() {
    *this = ::std::move(from);
  }

  inline StakeNode& operator=(const StakeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline StakeNode& operator=(StakeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StakeNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const StakeNode* internal_default_instance() {
    return reinterpret_cast<const StakeNode*>(
               &_StakeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(StakeNode& a, StakeNode& b) {
    a.Swap(&b);
  }
  inline void Swap(StakeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StakeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StakeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StakeNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StakeNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StakeNode& from) {
    StakeNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StakeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StakeNode";
  }
  protected:
  explicit StakeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kNameFieldNumber = 2,
    kIpFieldNumber = 3,
    kIdentityFieldNumber = 4,
    kLogoFieldNumber = 5,
    kVersionFieldNumber = 7,
    kHeightFieldNumber = 6,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string ip = 3;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // bytes identity = 4;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string logo = 5;
  void clear_logo();
  const std::string& logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo();
  PROTOBUF_NODISCARD std::string* release_logo();
  void set_allocated_logo(std::string* logo);
  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(const std::string& value);
  std::string* _internal_mutable_logo();
  public:

  // string version = 7;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 height = 6;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StakeNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetAllStakeNodeListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetAllStakeNodeListAck) */ {
 public:
  inline GetAllStakeNodeListAck() : GetAllStakeNodeListAck(nullptr) {}
  ~GetAllStakeNodeListAck() override;
  explicit PROTOBUF_CONSTEXPR GetAllStakeNodeListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllStakeNodeListAck(const GetAllStakeNodeListAck& from);
  GetAllStakeNodeListAck(GetAllStakeNodeListAck&& from) noexcept
    : GetAllStakeNodeListAck() {
    *this = ::std::move(from);
  }

  inline GetAllStakeNodeListAck& operator=(const GetAllStakeNodeListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllStakeNodeListAck& operator=(GetAllStakeNodeListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllStakeNodeListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllStakeNodeListAck* internal_default_instance() {
    return reinterpret_cast<const GetAllStakeNodeListAck*>(
               &_GetAllStakeNodeListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetAllStakeNodeListAck& a, GetAllStakeNodeListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllStakeNodeListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllStakeNodeListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllStakeNodeListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllStakeNodeListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllStakeNodeListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllStakeNodeListAck& from) {
    GetAllStakeNodeListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllStakeNodeListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetAllStakeNodeListAck";
  }
  protected:
  explicit GetAllStakeNodeListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 4,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 2,
  };
  // repeated .StakeNode list = 4;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::StakeNode* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeNode >*
      mutable_list();
  private:
  const ::StakeNode& _internal_list(int index) const;
  ::StakeNode* _internal_add_list();
  public:
  const ::StakeNode& list(int index) const;
  ::StakeNode* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeNode >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetAllStakeNodeListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeNode > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetSignCountListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetSignCountListReq) */ {
 public:
  inline GetSignCountListReq() : GetSignCountListReq(nullptr) {}
  ~GetSignCountListReq() override;
  explicit PROTOBUF_CONSTEXPR GetSignCountListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSignCountListReq(const GetSignCountListReq& from);
  GetSignCountListReq(GetSignCountListReq&& from) noexcept
    : GetSignCountListReq() {
    *this = ::std::move(from);
  }

  inline GetSignCountListReq& operator=(const GetSignCountListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSignCountListReq& operator=(GetSignCountListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSignCountListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSignCountListReq* internal_default_instance() {
    return reinterpret_cast<const GetSignCountListReq*>(
               &_GetSignCountListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetSignCountListReq& a, GetSignCountListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSignCountListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSignCountListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSignCountListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSignCountListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSignCountListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSignCountListReq& from) {
    GetSignCountListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSignCountListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetSignCountListReq";
  }
  protected:
  explicit GetSignCountListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:GetSignCountListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class SignCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SignCount) */ {
 public:
  inline SignCount() : SignCount(nullptr) {}
  ~SignCount() override;
  explicit PROTOBUF_CONSTEXPR SignCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignCount(const SignCount& from);
  SignCount(SignCount&& from) noexcept
    : SignCount() {
    *this = ::std::move(from);
  }

  inline SignCount& operator=(const SignCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignCount& operator=(SignCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignCount* internal_default_instance() {
    return reinterpret_cast<const SignCount*>(
               &_SignCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SignCount& a, SignCount& b) {
    a.Swap(&b);
  }
  inline void Swap(SignCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignCount& from) {
    SignCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SignCount";
  }
  protected:
  explicit SignCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // uint32 count = 2;
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SignCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    uint32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetSignCountListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetSignCountListAck) */ {
 public:
  inline GetSignCountListAck() : GetSignCountListAck(nullptr) {}
  ~GetSignCountListAck() override;
  explicit PROTOBUF_CONSTEXPR GetSignCountListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSignCountListAck(const GetSignCountListAck& from);
  GetSignCountListAck(GetSignCountListAck&& from) noexcept
    : GetSignCountListAck() {
    *this = ::std::move(from);
  }

  inline GetSignCountListAck& operator=(const GetSignCountListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSignCountListAck& operator=(GetSignCountListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSignCountListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSignCountListAck* internal_default_instance() {
    return reinterpret_cast<const GetSignCountListAck*>(
               &_GetSignCountListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GetSignCountListAck& a, GetSignCountListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSignCountListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSignCountListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSignCountListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSignCountListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSignCountListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSignCountListAck& from) {
    GetSignCountListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSignCountListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetSignCountListAck";
  }
  protected:
  explicit GetSignCountListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 4,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kCodeFieldNumber = 2,
  };
  // repeated .SignCount list = 4;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::SignCount* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignCount >*
      mutable_list();
  private:
  const ::SignCount& _internal_list(int index) const;
  ::SignCount* _internal_add_list();
  public:
  const ::SignCount& list(int index) const;
  ::SignCount* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignCount >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // sint32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetSignCountListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignCount > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetHeightReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetHeightReq) */ {
 public:
  inline GetHeightReq() : GetHeightReq(nullptr) {}
  ~GetHeightReq() override;
  explicit PROTOBUF_CONSTEXPR GetHeightReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHeightReq(const GetHeightReq& from);
  GetHeightReq(GetHeightReq&& from) noexcept
    : GetHeightReq() {
    *this = ::std::move(from);
  }

  inline GetHeightReq& operator=(const GetHeightReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeightReq& operator=(GetHeightReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeightReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeightReq* internal_default_instance() {
    return reinterpret_cast<const GetHeightReq*>(
               &_GetHeightReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetHeightReq& a, GetHeightReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHeightReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeightReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHeightReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHeightReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHeightReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetHeightReq& from) {
    GetHeightReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHeightReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetHeightReq";
  }
  protected:
  explicit GetHeightReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:GetHeightReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetHeightAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetHeightAck) */ {
 public:
  inline GetHeightAck() : GetHeightAck(nullptr) {}
  ~GetHeightAck() override;
  explicit PROTOBUF_CONSTEXPR GetHeightAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHeightAck(const GetHeightAck& from);
  GetHeightAck(GetHeightAck&& from) noexcept
    : GetHeightAck() {
    *this = ::std::move(from);
  }

  inline GetHeightAck& operator=(const GetHeightAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeightAck& operator=(GetHeightAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeightAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeightAck* internal_default_instance() {
    return reinterpret_cast<const GetHeightAck*>(
               &_GetHeightAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetHeightAck& a, GetHeightAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHeightAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeightAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHeightAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetHeightAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHeightAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetHeightAck& from) {
    GetHeightAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHeightAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetHeightAck";
  }
  protected:
  explicit GetHeightAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kHeightFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 height = 4;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetHeightAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t height_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetBonusListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBonusListReq) */ {
 public:
  inline GetBonusListReq() : GetBonusListReq(nullptr) {}
  ~GetBonusListReq() override;
  explicit PROTOBUF_CONSTEXPR GetBonusListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBonusListReq(const GetBonusListReq& from);
  GetBonusListReq(GetBonusListReq&& from) noexcept
    : GetBonusListReq() {
    *this = ::std::move(from);
  }

  inline GetBonusListReq& operator=(const GetBonusListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBonusListReq& operator=(GetBonusListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBonusListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBonusListReq* internal_default_instance() {
    return reinterpret_cast<const GetBonusListReq*>(
               &_GetBonusListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetBonusListReq& a, GetBonusListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBonusListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBonusListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBonusListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBonusListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBonusListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBonusListReq& from) {
    GetBonusListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBonusListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBonusListReq";
  }
  protected:
  explicit GetBonusListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kBonusAddrFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string bonusAddr = 2;
  void clear_bonusaddr();
  const std::string& bonusaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bonusaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bonusaddr();
  PROTOBUF_NODISCARD std::string* release_bonusaddr();
  void set_allocated_bonusaddr(std::string* bonusaddr);
  private:
  const std::string& _internal_bonusaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bonusaddr(const std::string& value);
  std::string* _internal_mutable_bonusaddr();
  public:

  // @@protoc_insertion_point(class_scope:GetBonusListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bonusaddr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class BonusItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BonusItem) */ {
 public:
  inline BonusItem() : BonusItem(nullptr) {}
  ~BonusItem() override;
  explicit PROTOBUF_CONSTEXPR BonusItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BonusItem(const BonusItem& from);
  BonusItem(BonusItem&& from) noexcept
    : BonusItem() {
    *this = ::std::move(from);
  }

  inline BonusItem& operator=(const BonusItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline BonusItem& operator=(BonusItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BonusItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const BonusItem* internal_default_instance() {
    return reinterpret_cast<const BonusItem*>(
               &_BonusItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(BonusItem& a, BonusItem& b) {
    a.Swap(&b);
  }
  inline void Swap(BonusItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BonusItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BonusItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BonusItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BonusItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BonusItem& from) {
    BonusItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BonusItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BonusItem";
  }
  protected:
  explicit BonusItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string addr = 1;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // uint64 value = 2;
  void clear_value();
  uint64_t value() const;
  void set_value(uint64_t value);
  private:
  uint64_t _internal_value() const;
  void _internal_set_value(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:BonusItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    uint64_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetBonusListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBonusListAck) */ {
 public:
  inline GetBonusListAck() : GetBonusListAck(nullptr) {}
  ~GetBonusListAck() override;
  explicit PROTOBUF_CONSTEXPR GetBonusListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBonusListAck(const GetBonusListAck& from);
  GetBonusListAck(GetBonusListAck&& from) noexcept
    : GetBonusListAck() {
    *this = ::std::move(from);
  }

  inline GetBonusListAck& operator=(const GetBonusListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBonusListAck& operator=(GetBonusListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBonusListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBonusListAck* internal_default_instance() {
    return reinterpret_cast<const GetBonusListAck*>(
               &_GetBonusListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetBonusListAck& a, GetBonusListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBonusListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBonusListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBonusListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBonusListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBonusListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetBonusListAck& from) {
    GetBonusListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBonusListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBonusListAck";
  }
  protected:
  explicit GetBonusListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 5,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kBonusAddrFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // repeated .BonusItem list = 5;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::BonusItem* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BonusItem >*
      mutable_list();
  private:
  const ::BonusItem& _internal_list(int index) const;
  ::BonusItem* _internal_add_list();
  public:
  const ::BonusItem& list(int index) const;
  ::BonusItem* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BonusItem >&
      list() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string bonusAddr = 4;
  void clear_bonusaddr();
  const std::string& bonusaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bonusaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bonusaddr();
  PROTOBUF_NODISCARD std::string* release_bonusaddr();
  void set_allocated_bonusaddr(std::string* bonusaddr);
  private:
  const std::string& _internal_bonusaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bonusaddr(const std::string& value);
  std::string* _internal_mutable_bonusaddr();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetBonusListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BonusItem > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bonusaddr_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class MultiSignTxReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiSignTxReq) */ {
 public:
  inline MultiSignTxReq() : MultiSignTxReq(nullptr) {}
  ~MultiSignTxReq() override;
  explicit PROTOBUF_CONSTEXPR MultiSignTxReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiSignTxReq(const MultiSignTxReq& from);
  MultiSignTxReq(MultiSignTxReq&& from) noexcept
    : MultiSignTxReq() {
    *this = ::std::move(from);
  }

  inline MultiSignTxReq& operator=(const MultiSignTxReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSignTxReq& operator=(MultiSignTxReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiSignTxReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiSignTxReq* internal_default_instance() {
    return reinterpret_cast<const MultiSignTxReq*>(
               &_MultiSignTxReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MultiSignTxReq& a, MultiSignTxReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiSignTxReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiSignTxReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiSignTxReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiSignTxReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiSignTxReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultiSignTxReq& from) {
    MultiSignTxReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiSignTxReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiSignTxReq";
  }
  protected:
  explicit MultiSignTxReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kTxRawFieldNumber = 3,
    kHeightFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // bytes txRaw = 3;
  void clear_txraw();
  const std::string& txraw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txraw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txraw();
  PROTOBUF_NODISCARD std::string* release_txraw();
  void set_allocated_txraw(std::string* txraw);
  private:
  const std::string& _internal_txraw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txraw(const std::string& value);
  std::string* _internal_mutable_txraw();
  public:

  // uint64 height = 2;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:MultiSignTxReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txraw_;
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class MultiSignTxAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MultiSignTxAck) */ {
 public:
  inline MultiSignTxAck() : MultiSignTxAck(nullptr) {}
  ~MultiSignTxAck() override;
  explicit PROTOBUF_CONSTEXPR MultiSignTxAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiSignTxAck(const MultiSignTxAck& from);
  MultiSignTxAck(MultiSignTxAck&& from) noexcept
    : MultiSignTxAck() {
    *this = ::std::move(from);
  }

  inline MultiSignTxAck& operator=(const MultiSignTxAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSignTxAck& operator=(MultiSignTxAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiSignTxAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiSignTxAck* internal_default_instance() {
    return reinterpret_cast<const MultiSignTxAck*>(
               &_MultiSignTxAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(MultiSignTxAck& a, MultiSignTxAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiSignTxAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiSignTxAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiSignTxAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiSignTxAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiSignTxAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultiSignTxAck& from) {
    MultiSignTxAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiSignTxAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MultiSignTxAck";
  }
  protected:
  explicit MultiSignTxAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kTxRawFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes txRaw = 4;
  void clear_txraw();
  const std::string& txraw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txraw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txraw();
  PROTOBUF_NODISCARD std::string* release_txraw();
  void set_allocated_txraw(std::string* txraw);
  private:
  const std::string& _internal_txraw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txraw(const std::string& value);
  std::string* _internal_mutable_txraw();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MultiSignTxAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txraw_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetTransactionStatusListReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetTransactionStatusListReq) */ {
 public:
  inline GetTransactionStatusListReq() : GetTransactionStatusListReq(nullptr) {}
  ~GetTransactionStatusListReq() override;
  explicit PROTOBUF_CONSTEXPR GetTransactionStatusListReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTransactionStatusListReq(const GetTransactionStatusListReq& from);
  GetTransactionStatusListReq(GetTransactionStatusListReq&& from) noexcept
    : GetTransactionStatusListReq() {
    *this = ::std::move(from);
  }

  inline GetTransactionStatusListReq& operator=(const GetTransactionStatusListReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTransactionStatusListReq& operator=(GetTransactionStatusListReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTransactionStatusListReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTransactionStatusListReq* internal_default_instance() {
    return reinterpret_cast<const GetTransactionStatusListReq*>(
               &_GetTransactionStatusListReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetTransactionStatusListReq& a, GetTransactionStatusListReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTransactionStatusListReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTransactionStatusListReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTransactionStatusListReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTransactionStatusListReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTransactionStatusListReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTransactionStatusListReq& from) {
    GetTransactionStatusListReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionStatusListReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetTransactionStatusListReq";
  }
  protected:
  explicit GetTransactionStatusListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kTxhashFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string txhash = 2;
  void clear_txhash();
  const std::string& txhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txhash();
  PROTOBUF_NODISCARD std::string* release_txhash();
  void set_allocated_txhash(std::string* txhash);
  private:
  const std::string& _internal_txhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txhash(const std::string& value);
  std::string* _internal_mutable_txhash();
  public:

  // @@protoc_insertion_point(class_scope:GetTransactionStatusListReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txhash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class OtherStatusItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OtherStatusItem) */ {
 public:
  inline OtherStatusItem() : OtherStatusItem(nullptr) {}
  ~OtherStatusItem() override;
  explicit PROTOBUF_CONSTEXPR OtherStatusItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OtherStatusItem(const OtherStatusItem& from);
  OtherStatusItem(OtherStatusItem&& from) noexcept
    : OtherStatusItem() {
    *this = ::std::move(from);
  }

  inline OtherStatusItem& operator=(const OtherStatusItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline OtherStatusItem& operator=(OtherStatusItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OtherStatusItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const OtherStatusItem* internal_default_instance() {
    return reinterpret_cast<const OtherStatusItem*>(
               &_OtherStatusItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(OtherStatusItem& a, OtherStatusItem& b) {
    a.Swap(&b);
  }
  inline void Swap(OtherStatusItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OtherStatusItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OtherStatusItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OtherStatusItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OtherStatusItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OtherStatusItem& from) {
    OtherStatusItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OtherStatusItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OtherStatusItem";
  }
  protected:
  explicit OtherStatusItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOthernodetimeFieldNumber = 1,
    kOthernodemessageFieldNumber = 3,
    kOthernodecodeFieldNumber = 2,
  };
  // string othernodetime = 1;
  void clear_othernodetime();
  const std::string& othernodetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_othernodetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_othernodetime();
  PROTOBUF_NODISCARD std::string* release_othernodetime();
  void set_allocated_othernodetime(std::string* othernodetime);
  private:
  const std::string& _internal_othernodetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_othernodetime(const std::string& value);
  std::string* _internal_mutable_othernodetime();
  public:

  // string othernodemessage = 3;
  void clear_othernodemessage();
  const std::string& othernodemessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_othernodemessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_othernodemessage();
  PROTOBUF_NODISCARD std::string* release_othernodemessage();
  void set_allocated_othernodemessage(std::string* othernodemessage);
  private:
  const std::string& _internal_othernodemessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_othernodemessage(const std::string& value);
  std::string* _internal_mutable_othernodemessage();
  public:

  // int32 othernodecode = 2;
  void clear_othernodecode();
  int32_t othernodecode() const;
  void set_othernodecode(int32_t value);
  private:
  int32_t _internal_othernodecode() const;
  void _internal_set_othernodecode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OtherStatusItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr othernodetime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr othernodemessage_;
    int32_t othernodecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class SelfVerifyStatusItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SelfVerifyStatusItem) */ {
 public:
  inline SelfVerifyStatusItem() : SelfVerifyStatusItem(nullptr) {}
  ~SelfVerifyStatusItem() override;
  explicit PROTOBUF_CONSTEXPR SelfVerifyStatusItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelfVerifyStatusItem(const SelfVerifyStatusItem& from);
  SelfVerifyStatusItem(SelfVerifyStatusItem&& from) noexcept
    : SelfVerifyStatusItem() {
    *this = ::std::move(from);
  }

  inline SelfVerifyStatusItem& operator=(const SelfVerifyStatusItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelfVerifyStatusItem& operator=(SelfVerifyStatusItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelfVerifyStatusItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelfVerifyStatusItem* internal_default_instance() {
    return reinterpret_cast<const SelfVerifyStatusItem*>(
               &_SelfVerifyStatusItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SelfVerifyStatusItem& a, SelfVerifyStatusItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SelfVerifyStatusItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelfVerifyStatusItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelfVerifyStatusItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelfVerifyStatusItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelfVerifyStatusItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelfVerifyStatusItem& from) {
    SelfVerifyStatusItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelfVerifyStatusItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SelfVerifyStatusItem";
  }
  protected:
  explicit SelfVerifyStatusItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerifyothernodetimeFieldNumber = 1,
    kVerifyothernodemessageFieldNumber = 3,
    kVerifyothernodecodeFieldNumber = 2,
  };
  // string verifyothernodetime = 1;
  void clear_verifyothernodetime();
  const std::string& verifyothernodetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verifyothernodetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verifyothernodetime();
  PROTOBUF_NODISCARD std::string* release_verifyothernodetime();
  void set_allocated_verifyothernodetime(std::string* verifyothernodetime);
  private:
  const std::string& _internal_verifyothernodetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verifyothernodetime(const std::string& value);
  std::string* _internal_mutable_verifyothernodetime();
  public:

  // string verifyothernodemessage = 3;
  void clear_verifyothernodemessage();
  const std::string& verifyothernodemessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verifyothernodemessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verifyothernodemessage();
  PROTOBUF_NODISCARD std::string* release_verifyothernodemessage();
  void set_allocated_verifyothernodemessage(std::string* verifyothernodemessage);
  private:
  const std::string& _internal_verifyothernodemessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verifyothernodemessage(const std::string& value);
  std::string* _internal_mutable_verifyothernodemessage();
  public:

  // int32 verifyothernodecode = 2;
  void clear_verifyothernodecode();
  int32_t verifyothernodecode() const;
  void set_verifyothernodecode(int32_t value);
  private:
  int32_t _internal_verifyothernodecode() const;
  void _internal_set_verifyothernodecode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SelfVerifyStatusItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verifyothernodetime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verifyothernodemessage_;
    int32_t verifyothernodecode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class TransactionStatusItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TransactionStatusItem) */ {
 public:
  inline TransactionStatusItem() : TransactionStatusItem(nullptr) {}
  ~TransactionStatusItem() override;
  explicit PROTOBUF_CONSTEXPR TransactionStatusItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionStatusItem(const TransactionStatusItem& from);
  TransactionStatusItem(TransactionStatusItem&& from) noexcept
    : TransactionStatusItem() {
    *this = ::std::move(from);
  }

  inline TransactionStatusItem& operator=(const TransactionStatusItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionStatusItem& operator=(TransactionStatusItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionStatusItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionStatusItem* internal_default_instance() {
    return reinterpret_cast<const TransactionStatusItem*>(
               &_TransactionStatusItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(TransactionStatusItem& a, TransactionStatusItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionStatusItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionStatusItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionStatusItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionStatusItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionStatusItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionStatusItem& from) {
    TransactionStatusItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionStatusItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TransactionStatusItem";
  }
  protected:
  explicit TransactionStatusItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOthernodeFieldNumber = 4,
    kVerifyothernodeFieldNumber = 5,
    kInitiatortimeFieldNumber = 1,
    kInitiatormessageFieldNumber = 3,
    kComposetimeFieldNumber = 6,
    kSelfaddblocktimeFieldNumber = 7,
    kSelfeaddblockmessageFieldNumber = 8,
    kRemovependingtimeFieldNumber = 9,
    kSelfcodeFieldNumber = 2,
  };
  // repeated .OtherStatusItem Othernode = 4;
  int othernode_size() const;
  private:
  int _internal_othernode_size() const;
  public:
  void clear_othernode();
  ::OtherStatusItem* mutable_othernode(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OtherStatusItem >*
      mutable_othernode();
  private:
  const ::OtherStatusItem& _internal_othernode(int index) const;
  ::OtherStatusItem* _internal_add_othernode();
  public:
  const ::OtherStatusItem& othernode(int index) const;
  ::OtherStatusItem* add_othernode();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OtherStatusItem >&
      othernode() const;

  // repeated .SelfVerifyStatusItem verifyothernode = 5;
  int verifyothernode_size() const;
  private:
  int _internal_verifyothernode_size() const;
  public:
  void clear_verifyothernode();
  ::SelfVerifyStatusItem* mutable_verifyothernode(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SelfVerifyStatusItem >*
      mutable_verifyothernode();
  private:
  const ::SelfVerifyStatusItem& _internal_verifyothernode(int index) const;
  ::SelfVerifyStatusItem* _internal_add_verifyothernode();
  public:
  const ::SelfVerifyStatusItem& verifyothernode(int index) const;
  ::SelfVerifyStatusItem* add_verifyothernode();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SelfVerifyStatusItem >&
      verifyothernode() const;

  // string initiatortime = 1;
  void clear_initiatortime();
  const std::string& initiatortime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initiatortime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initiatortime();
  PROTOBUF_NODISCARD std::string* release_initiatortime();
  void set_allocated_initiatortime(std::string* initiatortime);
  private:
  const std::string& _internal_initiatortime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiatortime(const std::string& value);
  std::string* _internal_mutable_initiatortime();
  public:

  // string initiatormessage = 3;
  void clear_initiatormessage();
  const std::string& initiatormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initiatormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initiatormessage();
  PROTOBUF_NODISCARD std::string* release_initiatormessage();
  void set_allocated_initiatormessage(std::string* initiatormessage);
  private:
  const std::string& _internal_initiatormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiatormessage(const std::string& value);
  std::string* _internal_mutable_initiatormessage();
  public:

  // string composetime = 6;
  void clear_composetime();
  const std::string& composetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_composetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_composetime();
  PROTOBUF_NODISCARD std::string* release_composetime();
  void set_allocated_composetime(std::string* composetime);
  private:
  const std::string& _internal_composetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_composetime(const std::string& value);
  std::string* _internal_mutable_composetime();
  public:

  // string selfaddblocktime = 7;
  void clear_selfaddblocktime();
  const std::string& selfaddblocktime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selfaddblocktime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selfaddblocktime();
  PROTOBUF_NODISCARD std::string* release_selfaddblocktime();
  void set_allocated_selfaddblocktime(std::string* selfaddblocktime);
  private:
  const std::string& _internal_selfaddblocktime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selfaddblocktime(const std::string& value);
  std::string* _internal_mutable_selfaddblocktime();
  public:

  // string selfeaddblockmessage = 8;
  void clear_selfeaddblockmessage();
  const std::string& selfeaddblockmessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_selfeaddblockmessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_selfeaddblockmessage();
  PROTOBUF_NODISCARD std::string* release_selfeaddblockmessage();
  void set_allocated_selfeaddblockmessage(std::string* selfeaddblockmessage);
  private:
  const std::string& _internal_selfeaddblockmessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_selfeaddblockmessage(const std::string& value);
  std::string* _internal_mutable_selfeaddblockmessage();
  public:

  // string removependingtime = 9;
  void clear_removependingtime();
  const std::string& removependingtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_removependingtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_removependingtime();
  PROTOBUF_NODISCARD std::string* release_removependingtime();
  void set_allocated_removependingtime(std::string* removependingtime);
  private:
  const std::string& _internal_removependingtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_removependingtime(const std::string& value);
  std::string* _internal_mutable_removependingtime();
  public:

  // int32 selfcode = 2;
  void clear_selfcode();
  int32_t selfcode() const;
  void set_selfcode(int32_t value);
  private:
  int32_t _internal_selfcode() const;
  void _internal_set_selfcode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TransactionStatusItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OtherStatusItem > othernode_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SelfVerifyStatusItem > verifyothernode_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initiatortime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initiatormessage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr composetime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selfaddblocktime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr selfeaddblockmessage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr removependingtime_;
    int32_t selfcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetTransactionStatusListAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetTransactionStatusListAck) */ {
 public:
  inline GetTransactionStatusListAck() : GetTransactionStatusListAck(nullptr) {}
  ~GetTransactionStatusListAck() override;
  explicit PROTOBUF_CONSTEXPR GetTransactionStatusListAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTransactionStatusListAck(const GetTransactionStatusListAck& from);
  GetTransactionStatusListAck(GetTransactionStatusListAck&& from) noexcept
    : GetTransactionStatusListAck() {
    *this = ::std::move(from);
  }

  inline GetTransactionStatusListAck& operator=(const GetTransactionStatusListAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTransactionStatusListAck& operator=(GetTransactionStatusListAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTransactionStatusListAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTransactionStatusListAck* internal_default_instance() {
    return reinterpret_cast<const GetTransactionStatusListAck*>(
               &_GetTransactionStatusListAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetTransactionStatusListAck& a, GetTransactionStatusListAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTransactionStatusListAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTransactionStatusListAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTransactionStatusListAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTransactionStatusListAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTransactionStatusListAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTransactionStatusListAck& from) {
    GetTransactionStatusListAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionStatusListAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetTransactionStatusListAck";
  }
  protected:
  explicit GetTransactionStatusListAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kListFieldNumber = 5,
    kCodeFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .TransactionStatusItem list = 5;
  bool has_list() const;
  private:
  bool _internal_has_list() const;
  public:
  void clear_list();
  const ::TransactionStatusItem& list() const;
  PROTOBUF_NODISCARD ::TransactionStatusItem* release_list();
  ::TransactionStatusItem* mutable_list();
  void set_allocated_list(::TransactionStatusItem* list);
  private:
  const ::TransactionStatusItem& _internal_list() const;
  ::TransactionStatusItem* _internal_mutable_list();
  public:
  void unsafe_arena_set_allocated_list(
      ::TransactionStatusItem* list);
  ::TransactionStatusItem* unsafe_arena_release_list();

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetTransactionStatusListAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::TransactionStatusItem* list_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class SuccessRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SuccessRate) */ {
 public:
  inline SuccessRate() : SuccessRate(nullptr) {}
  ~SuccessRate() override;
  explicit PROTOBUF_CONSTEXPR SuccessRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SuccessRate(const SuccessRate& from);
  SuccessRate(SuccessRate&& from) noexcept
    : SuccessRate() {
    *this = ::std::move(from);
  }

  inline SuccessRate& operator=(const SuccessRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuccessRate& operator=(SuccessRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SuccessRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const SuccessRate* internal_default_instance() {
    return reinterpret_cast<const SuccessRate*>(
               &_SuccessRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SuccessRate& a, SuccessRate& b) {
    a.Swap(&b);
  }
  inline void Swap(SuccessRate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuccessRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SuccessRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SuccessRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SuccessRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SuccessRate& from) {
    SuccessRate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuccessRate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SuccessRate";
  }
  protected:
  explicit SuccessRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kRateFieldNumber = 2,
  };
  // string hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // double rate = 2;
  void clear_rate();
  double rate() const;
  void set_rate(double value);
  private:
  double _internal_rate() const;
  void _internal_set_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:SuccessRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    double rate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class ConfirmTransactionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfirmTransactionReq) */ {
 public:
  inline ConfirmTransactionReq() : ConfirmTransactionReq(nullptr) {}
  ~ConfirmTransactionReq() override;
  explicit PROTOBUF_CONSTEXPR ConfirmTransactionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmTransactionReq(const ConfirmTransactionReq& from);
  ConfirmTransactionReq(ConfirmTransactionReq&& from) noexcept
    : ConfirmTransactionReq() {
    *this = ::std::move(from);
  }

  inline ConfirmTransactionReq& operator=(const ConfirmTransactionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmTransactionReq& operator=(ConfirmTransactionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmTransactionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmTransactionReq* internal_default_instance() {
    return reinterpret_cast<const ConfirmTransactionReq*>(
               &_ConfirmTransactionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ConfirmTransactionReq& a, ConfirmTransactionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmTransactionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmTransactionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmTransactionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmTransactionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmTransactionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmTransactionReq& from) {
    ConfirmTransactionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmTransactionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfirmTransactionReq";
  }
  protected:
  explicit ConfirmTransactionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxhashFieldNumber = 2,
    kVersionFieldNumber = 1,
    kTimeFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // repeated string txhash = 2;
  int txhash_size() const;
  private:
  int _internal_txhash_size() const;
  public:
  void clear_txhash();
  const std::string& txhash(int index) const;
  std::string* mutable_txhash(int index);
  void set_txhash(int index, const std::string& value);
  void set_txhash(int index, std::string&& value);
  void set_txhash(int index, const char* value);
  void set_txhash(int index, const char* value, size_t size);
  std::string* add_txhash();
  void add_txhash(const std::string& value);
  void add_txhash(std::string&& value);
  void add_txhash(const char* value);
  void add_txhash(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txhash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txhash();
  private:
  const std::string& _internal_txhash(int index) const;
  std::string* _internal_add_txhash();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 time = 3;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // uint64 height = 4;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ConfirmTransactionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint64_t time_;
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class ConfirmTransactionAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfirmTransactionAck) */ {
 public:
  inline ConfirmTransactionAck() : ConfirmTransactionAck(nullptr) {}
  ~ConfirmTransactionAck() override;
  explicit PROTOBUF_CONSTEXPR ConfirmTransactionAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmTransactionAck(const ConfirmTransactionAck& from);
  ConfirmTransactionAck(ConfirmTransactionAck&& from) noexcept
    : ConfirmTransactionAck() {
    *this = ::std::move(from);
  }

  inline ConfirmTransactionAck& operator=(const ConfirmTransactionAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmTransactionAck& operator=(ConfirmTransactionAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmTransactionAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmTransactionAck* internal_default_instance() {
    return reinterpret_cast<const ConfirmTransactionAck*>(
               &_ConfirmTransactionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ConfirmTransactionAck& a, ConfirmTransactionAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmTransactionAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmTransactionAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmTransactionAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmTransactionAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmTransactionAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmTransactionAck& from) {
    ConfirmTransactionAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmTransactionAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfirmTransactionAck";
  }
  protected:
  explicit ConfirmTransactionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentageFieldNumber = 5,
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kTxFieldNumber = 8,
    kTimeFieldNumber = 4,
    kCodeFieldNumber = 2,
    kSendSizeFieldNumber = 6,
    kReceivedSizeFieldNumber = 7,
  };
  // repeated .SuccessRate percentage = 5;
  int percentage_size() const;
  private:
  int _internal_percentage_size() const;
  public:
  void clear_percentage();
  ::SuccessRate* mutable_percentage(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SuccessRate >*
      mutable_percentage();
  private:
  const ::SuccessRate& _internal_percentage(int index) const;
  ::SuccessRate* _internal_add_percentage();
  public:
  const ::SuccessRate& percentage(int index) const;
  ::SuccessRate* add_percentage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SuccessRate >&
      percentage() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes tx = 8;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // uint64 time = 4;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // uint32 send_size = 6;
  void clear_send_size();
  uint32_t send_size() const;
  void set_send_size(uint32_t value);
  private:
  uint32_t _internal_send_size() const;
  void _internal_set_send_size(uint32_t value);
  public:

  // uint32 received_size = 7;
  void clear_received_size();
  uint32_t received_size() const;
  void set_received_size(uint32_t value);
  private:
  uint32_t _internal_received_size() const;
  void _internal_set_received_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ConfirmTransactionAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SuccessRate > percentage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    uint64_t time_;
    int32_t code_;
    uint32_t send_size_;
    uint32_t received_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class CorresHash final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CorresHash) */ {
 public:
  inline CorresHash() : CorresHash(nullptr) {}
  ~CorresHash() override;
  explicit PROTOBUF_CONSTEXPR CorresHash(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CorresHash(const CorresHash& from);
  CorresHash(CorresHash&& from) noexcept
    : CorresHash() {
    *this = ::std::move(from);
  }

  inline CorresHash& operator=(const CorresHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline CorresHash& operator=(CorresHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CorresHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const CorresHash* internal_default_instance() {
    return reinterpret_cast<const CorresHash*>(
               &_CorresHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CorresHash& a, CorresHash& b) {
    a.Swap(&b);
  }
  inline void Swap(CorresHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CorresHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CorresHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CorresHash>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CorresHash& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CorresHash& from) {
    CorresHash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CorresHash* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CorresHash";
  }
  protected:
  explicit CorresHash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kFlagFieldNumber = 2,
  };
  // string hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // uint32 flag = 2;
  void clear_flag();
  uint32_t flag() const;
  void set_flag(uint32_t value);
  private:
  uint32_t _internal_flag() const;
  void _internal_set_flag(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CorresHash)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    uint32_t flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class CheckTxReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CheckTxReq) */ {
 public:
  inline CheckTxReq() : CheckTxReq(nullptr) {}
  ~CheckTxReq() override;
  explicit PROTOBUF_CONSTEXPR CheckTxReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckTxReq(const CheckTxReq& from);
  CheckTxReq(CheckTxReq&& from) noexcept
    : CheckTxReq() {
    *this = ::std::move(from);
  }

  inline CheckTxReq& operator=(const CheckTxReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckTxReq& operator=(CheckTxReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckTxReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckTxReq* internal_default_instance() {
    return reinterpret_cast<const CheckTxReq*>(
               &_CheckTxReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CheckTxReq& a, CheckTxReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckTxReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckTxReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckTxReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckTxReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckTxReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckTxReq& from) {
    CheckTxReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckTxReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CheckTxReq";
  }
  protected:
  explicit CheckTxReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxhashFieldNumber = 2,
    kVersionFieldNumber = 1,
    kMsgIdFieldNumber = 3,
    kIsresponseFieldNumber = 4,
  };
  // repeated string txhash = 2;
  int txhash_size() const;
  private:
  int _internal_txhash_size() const;
  public:
  void clear_txhash();
  const std::string& txhash(int index) const;
  std::string* mutable_txhash(int index);
  void set_txhash(int index, const std::string& value);
  void set_txhash(int index, std::string&& value);
  void set_txhash(int index, const char* value);
  void set_txhash(int index, const char* value, size_t size);
  std::string* add_txhash();
  void add_txhash(const std::string& value);
  void add_txhash(std::string&& value);
  void add_txhash(const char* value);
  void add_txhash(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& txhash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_txhash();
  private:
  const std::string& _internal_txhash(int index) const;
  std::string* _internal_add_txhash();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string msg_id = 3;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // uint32 isresponse = 4;
  void clear_isresponse();
  uint32_t isresponse() const;
  void set_isresponse(uint32_t value);
  private:
  uint32_t _internal_isresponse() const;
  void _internal_set_isresponse(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CheckTxReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> txhash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    uint32_t isresponse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetUtxoHashReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUtxoHashReq) */ {
 public:
  inline GetUtxoHashReq() : GetUtxoHashReq(nullptr) {}
  ~GetUtxoHashReq() override;
  explicit PROTOBUF_CONSTEXPR GetUtxoHashReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUtxoHashReq(const GetUtxoHashReq& from);
  GetUtxoHashReq(GetUtxoHashReq&& from) noexcept
    : GetUtxoHashReq() {
    *this = ::std::move(from);
  }

  inline GetUtxoHashReq& operator=(const GetUtxoHashReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUtxoHashReq& operator=(GetUtxoHashReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUtxoHashReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUtxoHashReq* internal_default_instance() {
    return reinterpret_cast<const GetUtxoHashReq*>(
               &_GetUtxoHashReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(GetUtxoHashReq& a, GetUtxoHashReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUtxoHashReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUtxoHashReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUtxoHashReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUtxoHashReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUtxoHashReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUtxoHashReq& from) {
    GetUtxoHashReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUtxoHashReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUtxoHashReq";
  }
  protected:
  explicit GetUtxoHashReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtxoHashFieldNumber = 2,
    kVersionFieldNumber = 1,
    kMsgIdFieldNumber = 3,
  };
  // repeated string utxoHash = 2;
  int utxohash_size() const;
  private:
  int _internal_utxohash_size() const;
  public:
  void clear_utxohash();
  const std::string& utxohash(int index) const;
  std::string* mutable_utxohash(int index);
  void set_utxohash(int index, const std::string& value);
  void set_utxohash(int index, std::string&& value);
  void set_utxohash(int index, const char* value);
  void set_utxohash(int index, const char* value, size_t size);
  std::string* add_utxohash();
  void add_utxohash(const std::string& value);
  void add_utxohash(std::string&& value);
  void add_utxohash(const char* value);
  void add_utxohash(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& utxohash() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_utxohash();
  private:
  const std::string& _internal_utxohash(int index) const;
  std::string* _internal_add_utxohash();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string msg_id = 3;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // @@protoc_insertion_point(class_scope:GetUtxoHashReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> utxohash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetUtxoHashAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetUtxoHashAck) */ {
 public:
  inline GetUtxoHashAck() : GetUtxoHashAck(nullptr) {}
  ~GetUtxoHashAck() override;
  explicit PROTOBUF_CONSTEXPR GetUtxoHashAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUtxoHashAck(const GetUtxoHashAck& from);
  GetUtxoHashAck(GetUtxoHashAck&& from) noexcept
    : GetUtxoHashAck() {
    *this = ::std::move(from);
  }

  inline GetUtxoHashAck& operator=(const GetUtxoHashAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUtxoHashAck& operator=(GetUtxoHashAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUtxoHashAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUtxoHashAck* internal_default_instance() {
    return reinterpret_cast<const GetUtxoHashAck*>(
               &_GetUtxoHashAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(GetUtxoHashAck& a, GetUtxoHashAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUtxoHashAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUtxoHashAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUtxoHashAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUtxoHashAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUtxoHashAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUtxoHashAck& from) {
    GetUtxoHashAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUtxoHashAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetUtxoHashAck";
  }
  protected:
  explicit GetUtxoHashAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlaghashFieldNumber = 2,
    kVersionFieldNumber = 1,
    kMsgIdFieldNumber = 3,
    kBase58AddrFieldNumber = 4,
  };
  // repeated .CorresHash flaghash = 2;
  int flaghash_size() const;
  private:
  int _internal_flaghash_size() const;
  public:
  void clear_flaghash();
  ::CorresHash* mutable_flaghash(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >*
      mutable_flaghash();
  private:
  const ::CorresHash& _internal_flaghash(int index) const;
  ::CorresHash* _internal_add_flaghash();
  public:
  const ::CorresHash& flaghash(int index) const;
  ::CorresHash* add_flaghash();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >&
      flaghash() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string msg_id = 3;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // string base58addr = 4;
  void clear_base58addr();
  const std::string& base58addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base58addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base58addr();
  PROTOBUF_NODISCARD std::string* release_base58addr();
  void set_allocated_base58addr(std::string* base58addr);
  private:
  const std::string& _internal_base58addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base58addr(const std::string& value);
  std::string* _internal_mutable_base58addr();
  public:

  // @@protoc_insertion_point(class_scope:GetUtxoHashAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash > flaghash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base58addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class CheckTxAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CheckTxAck) */ {
 public:
  inline CheckTxAck() : CheckTxAck(nullptr) {}
  ~CheckTxAck() override;
  explicit PROTOBUF_CONSTEXPR CheckTxAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckTxAck(const CheckTxAck& from);
  CheckTxAck(CheckTxAck&& from) noexcept
    : CheckTxAck() {
    *this = ::std::move(from);
  }

  inline CheckTxAck& operator=(const CheckTxAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckTxAck& operator=(CheckTxAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckTxAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckTxAck* internal_default_instance() {
    return reinterpret_cast<const CheckTxAck*>(
               &_CheckTxAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CheckTxAck& a, CheckTxAck& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckTxAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckTxAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckTxAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckTxAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckTxAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckTxAck& from) {
    CheckTxAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckTxAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CheckTxAck";
  }
  protected:
  explicit CheckTxAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlaghashFieldNumber = 2,
    kVersionFieldNumber = 1,
    kMsgIdFieldNumber = 3,
    kAddrFieldNumber = 4,
    kTxFieldNumber = 5,
  };
  // repeated .CorresHash flaghash = 2;
  int flaghash_size() const;
  private:
  int _internal_flaghash_size() const;
  public:
  void clear_flaghash();
  ::CorresHash* mutable_flaghash(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >*
      mutable_flaghash();
  private:
  const ::CorresHash& _internal_flaghash(int index) const;
  ::CorresHash* _internal_add_flaghash();
  public:
  const ::CorresHash& flaghash(int index) const;
  ::CorresHash* add_flaghash();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >&
      flaghash() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string msg_id = 3;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // string addr = 4;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // bytes tx = 5;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // @@protoc_insertion_point(class_scope:CheckTxAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash > flaghash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetRestInvestAmountReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetRestInvestAmountReq) */ {
 public:
  inline GetRestInvestAmountReq() : GetRestInvestAmountReq(nullptr) {}
  ~GetRestInvestAmountReq() override;
  explicit PROTOBUF_CONSTEXPR GetRestInvestAmountReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRestInvestAmountReq(const GetRestInvestAmountReq& from);
  GetRestInvestAmountReq(GetRestInvestAmountReq&& from) noexcept
    : GetRestInvestAmountReq() {
    *this = ::std::move(from);
  }

  inline GetRestInvestAmountReq& operator=(const GetRestInvestAmountReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRestInvestAmountReq& operator=(GetRestInvestAmountReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRestInvestAmountReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRestInvestAmountReq* internal_default_instance() {
    return reinterpret_cast<const GetRestInvestAmountReq*>(
               &_GetRestInvestAmountReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(GetRestInvestAmountReq& a, GetRestInvestAmountReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRestInvestAmountReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRestInvestAmountReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRestInvestAmountReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRestInvestAmountReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRestInvestAmountReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRestInvestAmountReq& from) {
    GetRestInvestAmountReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRestInvestAmountReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetRestInvestAmountReq";
  }
  protected:
  explicit GetRestInvestAmountReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kAddrFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // @@protoc_insertion_point(class_scope:GetRestInvestAmountReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// -------------------------------------------------------------------

class GetRestInvestAmountAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetRestInvestAmountAck) */ {
 public:
  inline GetRestInvestAmountAck() : GetRestInvestAmountAck(nullptr) {}
  ~GetRestInvestAmountAck() override;
  explicit PROTOBUF_CONSTEXPR GetRestInvestAmountAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRestInvestAmountAck(const GetRestInvestAmountAck& from);
  GetRestInvestAmountAck(GetRestInvestAmountAck&& from) noexcept
    : GetRestInvestAmountAck() {
    *this = ::std::move(from);
  }

  inline GetRestInvestAmountAck& operator=(const GetRestInvestAmountAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRestInvestAmountAck& operator=(GetRestInvestAmountAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRestInvestAmountAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRestInvestAmountAck* internal_default_instance() {
    return reinterpret_cast<const GetRestInvestAmountAck*>(
               &_GetRestInvestAmountAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(GetRestInvestAmountAck& a, GetRestInvestAmountAck& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRestInvestAmountAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRestInvestAmountAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRestInvestAmountAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRestInvestAmountAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRestInvestAmountAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRestInvestAmountAck& from) {
    GetRestInvestAmountAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRestInvestAmountAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetRestInvestAmountAck";
  }
  protected:
  explicit GetRestInvestAmountAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kAddrFieldNumber = 5,
    kAmountFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string addr = 5;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // uint64 amount = 4;
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetRestInvestAmountAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    uint64_t amount_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_interface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetBlockReq

// string version = 1;
inline void GetBlockReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetBlockReq::version() const {
  // @@protoc_insertion_point(field_get:GetBlockReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBlockReq.version)
}
inline std::string* GetBlockReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetBlockReq.version)
  return _s;
}
inline const std::string& GetBlockReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetBlockReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBlockReq::release_version() {
  // @@protoc_insertion_point(field_release:GetBlockReq.version)
  return _impl_.version_.Release();
}
inline void GetBlockReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBlockReq.version)
}

// uint64 height = 2;
inline void GetBlockReq::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t GetBlockReq::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t GetBlockReq::height() const {
  // @@protoc_insertion_point(field_get:GetBlockReq.height)
  return _internal_height();
}
inline void GetBlockReq::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void GetBlockReq::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:GetBlockReq.height)
}

// -------------------------------------------------------------------

// BlockItem

// string blockhash = 1;
inline void BlockItem::clear_blockhash() {
  _impl_.blockhash_.ClearToEmpty();
}
inline const std::string& BlockItem::blockhash() const {
  // @@protoc_insertion_point(field_get:BlockItem.blockhash)
  return _internal_blockhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockItem::set_blockhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blockhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BlockItem.blockhash)
}
inline std::string* BlockItem::mutable_blockhash() {
  std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:BlockItem.blockhash)
  return _s;
}
inline const std::string& BlockItem::_internal_blockhash() const {
  return _impl_.blockhash_.Get();
}
inline void BlockItem::_internal_set_blockhash(const std::string& value) {
  
  _impl_.blockhash_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockItem::_internal_mutable_blockhash() {
  
  return _impl_.blockhash_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockItem::release_blockhash() {
  // @@protoc_insertion_point(field_release:BlockItem.blockhash)
  return _impl_.blockhash_.Release();
}
inline void BlockItem::set_allocated_blockhash(std::string* blockhash) {
  if (blockhash != nullptr) {
    
  } else {
    
  }
  _impl_.blockhash_.SetAllocated(blockhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BlockItem.blockhash)
}

// repeated string addr = 2;
inline int BlockItem::_internal_addr_size() const {
  return _impl_.addr_.size();
}
inline int BlockItem::addr_size() const {
  return _internal_addr_size();
}
inline void BlockItem::clear_addr() {
  _impl_.addr_.Clear();
}
inline std::string* BlockItem::add_addr() {
  std::string* _s = _internal_add_addr();
  // @@protoc_insertion_point(field_add_mutable:BlockItem.addr)
  return _s;
}
inline const std::string& BlockItem::_internal_addr(int index) const {
  return _impl_.addr_.Get(index);
}
inline const std::string& BlockItem::addr(int index) const {
  // @@protoc_insertion_point(field_get:BlockItem.addr)
  return _internal_addr(index);
}
inline std::string* BlockItem::mutable_addr(int index) {
  // @@protoc_insertion_point(field_mutable:BlockItem.addr)
  return _impl_.addr_.Mutable(index);
}
inline void BlockItem::set_addr(int index, const std::string& value) {
  _impl_.addr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BlockItem.addr)
}
inline void BlockItem::set_addr(int index, std::string&& value) {
  _impl_.addr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BlockItem.addr)
}
inline void BlockItem::set_addr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BlockItem.addr)
}
inline void BlockItem::set_addr(int index, const char* value, size_t size) {
  _impl_.addr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BlockItem.addr)
}
inline std::string* BlockItem::_internal_add_addr() {
  return _impl_.addr_.Add();
}
inline void BlockItem::add_addr(const std::string& value) {
  _impl_.addr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BlockItem.addr)
}
inline void BlockItem::add_addr(std::string&& value) {
  _impl_.addr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BlockItem.addr)
}
inline void BlockItem::add_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BlockItem.addr)
}
inline void BlockItem::add_addr(const char* value, size_t size) {
  _impl_.addr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BlockItem.addr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockItem::addr() const {
  // @@protoc_insertion_point(field_list:BlockItem.addr)
  return _impl_.addr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockItem::mutable_addr() {
  // @@protoc_insertion_point(field_mutable_list:BlockItem.addr)
  return &_impl_.addr_;
}

// -------------------------------------------------------------------

// GetBlockAck

// string version = 1;
inline void GetBlockAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetBlockAck::version() const {
  // @@protoc_insertion_point(field_get:GetBlockAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBlockAck.version)
}
inline std::string* GetBlockAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetBlockAck.version)
  return _s;
}
inline const std::string& GetBlockAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetBlockAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBlockAck::release_version() {
  // @@protoc_insertion_point(field_release:GetBlockAck.version)
  return _impl_.version_.Release();
}
inline void GetBlockAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBlockAck.version)
}

// sint32 code = 2;
inline void GetBlockAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetBlockAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetBlockAck::code() const {
  // @@protoc_insertion_point(field_get:GetBlockAck.code)
  return _internal_code();
}
inline void GetBlockAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetBlockAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetBlockAck.code)
}

// string message = 3;
inline void GetBlockAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetBlockAck::message() const {
  // @@protoc_insertion_point(field_get:GetBlockAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBlockAck.message)
}
inline std::string* GetBlockAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetBlockAck.message)
  return _s;
}
inline const std::string& GetBlockAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetBlockAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBlockAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBlockAck::release_message() {
  // @@protoc_insertion_point(field_release:GetBlockAck.message)
  return _impl_.message_.Release();
}
inline void GetBlockAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBlockAck.message)
}

// uint64 height = 4;
inline void GetBlockAck::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t GetBlockAck::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t GetBlockAck::height() const {
  // @@protoc_insertion_point(field_get:GetBlockAck.height)
  return _internal_height();
}
inline void GetBlockAck::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void GetBlockAck::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:GetBlockAck.height)
}

// uint64 timestamp = 5;
inline void GetBlockAck::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t GetBlockAck::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t GetBlockAck::timestamp() const {
  // @@protoc_insertion_point(field_get:GetBlockAck.timestamp)
  return _internal_timestamp();
}
inline void GetBlockAck::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void GetBlockAck::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:GetBlockAck.timestamp)
}

// repeated .BlockItem list = 6;
inline int GetBlockAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetBlockAck::list_size() const {
  return _internal_list_size();
}
inline void GetBlockAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::BlockItem* GetBlockAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetBlockAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BlockItem >*
GetBlockAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetBlockAck.list)
  return &_impl_.list_;
}
inline const ::BlockItem& GetBlockAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::BlockItem& GetBlockAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetBlockAck.list)
  return _internal_list(index);
}
inline ::BlockItem* GetBlockAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::BlockItem* GetBlockAck::add_list() {
  ::BlockItem* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetBlockAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BlockItem >&
GetBlockAck::list() const {
  // @@protoc_insertion_point(field_list:GetBlockAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// GetBalanceReq

// string version = 1;
inline void GetBalanceReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetBalanceReq::version() const {
  // @@protoc_insertion_point(field_get:GetBalanceReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBalanceReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBalanceReq.version)
}
inline std::string* GetBalanceReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetBalanceReq.version)
  return _s;
}
inline const std::string& GetBalanceReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetBalanceReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBalanceReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBalanceReq::release_version() {
  // @@protoc_insertion_point(field_release:GetBalanceReq.version)
  return _impl_.version_.Release();
}
inline void GetBalanceReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBalanceReq.version)
}

// string address = 2;
inline void GetBalanceReq::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetBalanceReq::address() const {
  // @@protoc_insertion_point(field_get:GetBalanceReq.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBalanceReq::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBalanceReq.address)
}
inline std::string* GetBalanceReq::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:GetBalanceReq.address)
  return _s;
}
inline const std::string& GetBalanceReq::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetBalanceReq::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBalanceReq::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBalanceReq::release_address() {
  // @@protoc_insertion_point(field_release:GetBalanceReq.address)
  return _impl_.address_.Release();
}
inline void GetBalanceReq::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBalanceReq.address)
}

// -------------------------------------------------------------------

// GetBalanceAck

// string version = 1;
inline void GetBalanceAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetBalanceAck::version() const {
  // @@protoc_insertion_point(field_get:GetBalanceAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBalanceAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBalanceAck.version)
}
inline std::string* GetBalanceAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetBalanceAck.version)
  return _s;
}
inline const std::string& GetBalanceAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetBalanceAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBalanceAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBalanceAck::release_version() {
  // @@protoc_insertion_point(field_release:GetBalanceAck.version)
  return _impl_.version_.Release();
}
inline void GetBalanceAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBalanceAck.version)
}

// sint32 code = 2;
inline void GetBalanceAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetBalanceAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetBalanceAck::code() const {
  // @@protoc_insertion_point(field_get:GetBalanceAck.code)
  return _internal_code();
}
inline void GetBalanceAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetBalanceAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetBalanceAck.code)
}

// string message = 3;
inline void GetBalanceAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetBalanceAck::message() const {
  // @@protoc_insertion_point(field_get:GetBalanceAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBalanceAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBalanceAck.message)
}
inline std::string* GetBalanceAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetBalanceAck.message)
  return _s;
}
inline const std::string& GetBalanceAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetBalanceAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBalanceAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBalanceAck::release_message() {
  // @@protoc_insertion_point(field_release:GetBalanceAck.message)
  return _impl_.message_.Release();
}
inline void GetBalanceAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBalanceAck.message)
}

// string address = 4;
inline void GetBalanceAck::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetBalanceAck::address() const {
  // @@protoc_insertion_point(field_get:GetBalanceAck.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBalanceAck::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBalanceAck.address)
}
inline std::string* GetBalanceAck::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:GetBalanceAck.address)
  return _s;
}
inline const std::string& GetBalanceAck::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetBalanceAck::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBalanceAck::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBalanceAck::release_address() {
  // @@protoc_insertion_point(field_release:GetBalanceAck.address)
  return _impl_.address_.Release();
}
inline void GetBalanceAck::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBalanceAck.address)
}

// uint64 balance = 5;
inline void GetBalanceAck::clear_balance() {
  _impl_.balance_ = uint64_t{0u};
}
inline uint64_t GetBalanceAck::_internal_balance() const {
  return _impl_.balance_;
}
inline uint64_t GetBalanceAck::balance() const {
  // @@protoc_insertion_point(field_get:GetBalanceAck.balance)
  return _internal_balance();
}
inline void GetBalanceAck::_internal_set_balance(uint64_t value) {
  
  _impl_.balance_ = value;
}
inline void GetBalanceAck::set_balance(uint64_t value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:GetBalanceAck.balance)
}

// uint64 height = 6;
inline void GetBalanceAck::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t GetBalanceAck::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t GetBalanceAck::height() const {
  // @@protoc_insertion_point(field_get:GetBalanceAck.height)
  return _internal_height();
}
inline void GetBalanceAck::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void GetBalanceAck::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:GetBalanceAck.height)
}

// -------------------------------------------------------------------

// GetNodeInfoReq

// string version = 1;
inline void GetNodeInfoReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetNodeInfoReq::version() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeInfoReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetNodeInfoReq.version)
}
inline std::string* GetNodeInfoReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetNodeInfoReq.version)
  return _s;
}
inline const std::string& GetNodeInfoReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetNodeInfoReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeInfoReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeInfoReq::release_version() {
  // @@protoc_insertion_point(field_release:GetNodeInfoReq.version)
  return _impl_.version_.Release();
}
inline void GetNodeInfoReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetNodeInfoReq.version)
}

// -------------------------------------------------------------------

// GetNodeInfoAck

// string version = 1;
inline void GetNodeInfoAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetNodeInfoAck::version() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeInfoAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.version)
}
inline std::string* GetNodeInfoAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetNodeInfoAck.version)
  return _s;
}
inline const std::string& GetNodeInfoAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetNodeInfoAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::release_version() {
  // @@protoc_insertion_point(field_release:GetNodeInfoAck.version)
  return _impl_.version_.Release();
}
inline void GetNodeInfoAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetNodeInfoAck.version)
}

// sint32 code = 2;
inline void GetNodeInfoAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetNodeInfoAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetNodeInfoAck::code() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.code)
  return _internal_code();
}
inline void GetNodeInfoAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetNodeInfoAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.code)
}

// string message = 3;
inline void GetNodeInfoAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetNodeInfoAck::message() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeInfoAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.message)
}
inline std::string* GetNodeInfoAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetNodeInfoAck.message)
  return _s;
}
inline const std::string& GetNodeInfoAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetNodeInfoAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::release_message() {
  // @@protoc_insertion_point(field_release:GetNodeInfoAck.message)
  return _impl_.message_.Release();
}
inline void GetNodeInfoAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetNodeInfoAck.message)
}

// string address = 4;
inline void GetNodeInfoAck::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetNodeInfoAck::address() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeInfoAck::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.address)
}
inline std::string* GetNodeInfoAck::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:GetNodeInfoAck.address)
  return _s;
}
inline const std::string& GetNodeInfoAck::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetNodeInfoAck::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::release_address() {
  // @@protoc_insertion_point(field_release:GetNodeInfoAck.address)
  return _impl_.address_.Release();
}
inline void GetNodeInfoAck::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetNodeInfoAck.address)
}

// string ip = 5;
inline void GetNodeInfoAck::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& GetNodeInfoAck::ip() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeInfoAck::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.ip)
}
inline std::string* GetNodeInfoAck::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:GetNodeInfoAck.ip)
  return _s;
}
inline const std::string& GetNodeInfoAck::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void GetNodeInfoAck::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::release_ip() {
  // @@protoc_insertion_point(field_release:GetNodeInfoAck.ip)
  return _impl_.ip_.Release();
}
inline void GetNodeInfoAck::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetNodeInfoAck.ip)
}

// uint64 height = 6;
inline void GetNodeInfoAck::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t GetNodeInfoAck::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t GetNodeInfoAck::height() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.height)
  return _internal_height();
}
inline void GetNodeInfoAck::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void GetNodeInfoAck::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.height)
}

// uint64 gas = 7;
inline void GetNodeInfoAck::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t GetNodeInfoAck::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t GetNodeInfoAck::gas() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.gas)
  return _internal_gas();
}
inline void GetNodeInfoAck::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void GetNodeInfoAck::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.gas)
}

// string ver = 8;
inline void GetNodeInfoAck::clear_ver() {
  _impl_.ver_.ClearToEmpty();
}
inline const std::string& GetNodeInfoAck::ver() const {
  // @@protoc_insertion_point(field_get:GetNodeInfoAck.ver)
  return _internal_ver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNodeInfoAck::set_ver(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ver_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetNodeInfoAck.ver)
}
inline std::string* GetNodeInfoAck::mutable_ver() {
  std::string* _s = _internal_mutable_ver();
  // @@protoc_insertion_point(field_mutable:GetNodeInfoAck.ver)
  return _s;
}
inline const std::string& GetNodeInfoAck::_internal_ver() const {
  return _impl_.ver_.Get();
}
inline void GetNodeInfoAck::_internal_set_ver(const std::string& value) {
  
  _impl_.ver_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::_internal_mutable_ver() {
  
  return _impl_.ver_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNodeInfoAck::release_ver() {
  // @@protoc_insertion_point(field_release:GetNodeInfoAck.ver)
  return _impl_.ver_.Release();
}
inline void GetNodeInfoAck::set_allocated_ver(std::string* ver) {
  if (ver != nullptr) {
    
  } else {
    
  }
  _impl_.ver_.SetAllocated(ver, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ver_.IsDefault()) {
    _impl_.ver_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetNodeInfoAck.ver)
}

// -------------------------------------------------------------------

// GetStakeListReq

// string version = 1;
inline void GetStakeListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetStakeListReq::version() const {
  // @@protoc_insertion_point(field_get:GetStakeListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStakeListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetStakeListReq.version)
}
inline std::string* GetStakeListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetStakeListReq.version)
  return _s;
}
inline const std::string& GetStakeListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetStakeListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStakeListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStakeListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetStakeListReq.version)
  return _impl_.version_.Release();
}
inline void GetStakeListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetStakeListReq.version)
}

// string addr = 2;
inline void GetStakeListReq::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetStakeListReq::addr() const {
  // @@protoc_insertion_point(field_get:GetStakeListReq.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStakeListReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetStakeListReq.addr)
}
inline std::string* GetStakeListReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:GetStakeListReq.addr)
  return _s;
}
inline const std::string& GetStakeListReq::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void GetStakeListReq::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStakeListReq::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStakeListReq::release_addr() {
  // @@protoc_insertion_point(field_release:GetStakeListReq.addr)
  return _impl_.addr_.Release();
}
inline void GetStakeListReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetStakeListReq.addr)
}

// -------------------------------------------------------------------

// StakeItem

// string blockhash = 1;
inline void StakeItem::clear_blockhash() {
  _impl_.blockhash_.ClearToEmpty();
}
inline const std::string& StakeItem::blockhash() const {
  // @@protoc_insertion_point(field_get:StakeItem.blockhash)
  return _internal_blockhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeItem::set_blockhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blockhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeItem.blockhash)
}
inline std::string* StakeItem::mutable_blockhash() {
  std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:StakeItem.blockhash)
  return _s;
}
inline const std::string& StakeItem::_internal_blockhash() const {
  return _impl_.blockhash_.Get();
}
inline void StakeItem::_internal_set_blockhash(const std::string& value) {
  
  _impl_.blockhash_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeItem::_internal_mutable_blockhash() {
  
  return _impl_.blockhash_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeItem::release_blockhash() {
  // @@protoc_insertion_point(field_release:StakeItem.blockhash)
  return _impl_.blockhash_.Release();
}
inline void StakeItem::set_allocated_blockhash(std::string* blockhash) {
  if (blockhash != nullptr) {
    
  } else {
    
  }
  _impl_.blockhash_.SetAllocated(blockhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeItem.blockhash)
}

// uint32 blockheight = 2;
inline void StakeItem::clear_blockheight() {
  _impl_.blockheight_ = 0u;
}
inline uint32_t StakeItem::_internal_blockheight() const {
  return _impl_.blockheight_;
}
inline uint32_t StakeItem::blockheight() const {
  // @@protoc_insertion_point(field_get:StakeItem.blockheight)
  return _internal_blockheight();
}
inline void StakeItem::_internal_set_blockheight(uint32_t value) {
  
  _impl_.blockheight_ = value;
}
inline void StakeItem::set_blockheight(uint32_t value) {
  _internal_set_blockheight(value);
  // @@protoc_insertion_point(field_set:StakeItem.blockheight)
}

// string utxo = 3;
inline void StakeItem::clear_utxo() {
  _impl_.utxo_.ClearToEmpty();
}
inline const std::string& StakeItem::utxo() const {
  // @@protoc_insertion_point(field_get:StakeItem.utxo)
  return _internal_utxo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeItem::set_utxo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.utxo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeItem.utxo)
}
inline std::string* StakeItem::mutable_utxo() {
  std::string* _s = _internal_mutable_utxo();
  // @@protoc_insertion_point(field_mutable:StakeItem.utxo)
  return _s;
}
inline const std::string& StakeItem::_internal_utxo() const {
  return _impl_.utxo_.Get();
}
inline void StakeItem::_internal_set_utxo(const std::string& value) {
  
  _impl_.utxo_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeItem::_internal_mutable_utxo() {
  
  return _impl_.utxo_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeItem::release_utxo() {
  // @@protoc_insertion_point(field_release:StakeItem.utxo)
  return _impl_.utxo_.Release();
}
inline void StakeItem::set_allocated_utxo(std::string* utxo) {
  if (utxo != nullptr) {
    
  } else {
    
  }
  _impl_.utxo_.SetAllocated(utxo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utxo_.IsDefault()) {
    _impl_.utxo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeItem.utxo)
}

// uint64 amount = 4;
inline void StakeItem::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
}
inline uint64_t StakeItem::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t StakeItem::amount() const {
  // @@protoc_insertion_point(field_get:StakeItem.amount)
  return _internal_amount();
}
inline void StakeItem::_internal_set_amount(uint64_t value) {
  
  _impl_.amount_ = value;
}
inline void StakeItem::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:StakeItem.amount)
}

// uint64 time = 5;
inline void StakeItem::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t StakeItem::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t StakeItem::time() const {
  // @@protoc_insertion_point(field_get:StakeItem.time)
  return _internal_time();
}
inline void StakeItem::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void StakeItem::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:StakeItem.time)
}

// string fromaddr = 6;
inline void StakeItem::clear_fromaddr() {
  _impl_.fromaddr_.ClearToEmpty();
}
inline const std::string& StakeItem::fromaddr() const {
  // @@protoc_insertion_point(field_get:StakeItem.fromaddr)
  return _internal_fromaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeItem::set_fromaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fromaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeItem.fromaddr)
}
inline std::string* StakeItem::mutable_fromaddr() {
  std::string* _s = _internal_mutable_fromaddr();
  // @@protoc_insertion_point(field_mutable:StakeItem.fromaddr)
  return _s;
}
inline const std::string& StakeItem::_internal_fromaddr() const {
  return _impl_.fromaddr_.Get();
}
inline void StakeItem::_internal_set_fromaddr(const std::string& value) {
  
  _impl_.fromaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeItem::_internal_mutable_fromaddr() {
  
  return _impl_.fromaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeItem::release_fromaddr() {
  // @@protoc_insertion_point(field_release:StakeItem.fromaddr)
  return _impl_.fromaddr_.Release();
}
inline void StakeItem::set_allocated_fromaddr(std::string* fromaddr) {
  if (fromaddr != nullptr) {
    
  } else {
    
  }
  _impl_.fromaddr_.SetAllocated(fromaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fromaddr_.IsDefault()) {
    _impl_.fromaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeItem.fromaddr)
}

// string toaddr = 7;
inline void StakeItem::clear_toaddr() {
  _impl_.toaddr_.ClearToEmpty();
}
inline const std::string& StakeItem::toaddr() const {
  // @@protoc_insertion_point(field_get:StakeItem.toaddr)
  return _internal_toaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeItem::set_toaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.toaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeItem.toaddr)
}
inline std::string* StakeItem::mutable_toaddr() {
  std::string* _s = _internal_mutable_toaddr();
  // @@protoc_insertion_point(field_mutable:StakeItem.toaddr)
  return _s;
}
inline const std::string& StakeItem::_internal_toaddr() const {
  return _impl_.toaddr_.Get();
}
inline void StakeItem::_internal_set_toaddr(const std::string& value) {
  
  _impl_.toaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeItem::_internal_mutable_toaddr() {
  
  return _impl_.toaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeItem::release_toaddr() {
  // @@protoc_insertion_point(field_release:StakeItem.toaddr)
  return _impl_.toaddr_.Release();
}
inline void StakeItem::set_allocated_toaddr(std::string* toaddr) {
  if (toaddr != nullptr) {
    
  } else {
    
  }
  _impl_.toaddr_.SetAllocated(toaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.toaddr_.IsDefault()) {
    _impl_.toaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeItem.toaddr)
}

// string detail = 8;
inline void StakeItem::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& StakeItem::detail() const {
  // @@protoc_insertion_point(field_get:StakeItem.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeItem::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeItem.detail)
}
inline std::string* StakeItem::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:StakeItem.detail)
  return _s;
}
inline const std::string& StakeItem::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void StakeItem::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeItem::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeItem::release_detail() {
  // @@protoc_insertion_point(field_release:StakeItem.detail)
  return _impl_.detail_.Release();
}
inline void StakeItem::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeItem.detail)
}

// -------------------------------------------------------------------

// GetStakeListAck

// string version = 1;
inline void GetStakeListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetStakeListAck::version() const {
  // @@protoc_insertion_point(field_get:GetStakeListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStakeListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetStakeListAck.version)
}
inline std::string* GetStakeListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetStakeListAck.version)
  return _s;
}
inline const std::string& GetStakeListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetStakeListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStakeListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStakeListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetStakeListAck.version)
  return _impl_.version_.Release();
}
inline void GetStakeListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetStakeListAck.version)
}

// int32 code = 2;
inline void GetStakeListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetStakeListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetStakeListAck::code() const {
  // @@protoc_insertion_point(field_get:GetStakeListAck.code)
  return _internal_code();
}
inline void GetStakeListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetStakeListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetStakeListAck.code)
}

// string message = 3;
inline void GetStakeListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetStakeListAck::message() const {
  // @@protoc_insertion_point(field_get:GetStakeListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStakeListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetStakeListAck.message)
}
inline std::string* GetStakeListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetStakeListAck.message)
  return _s;
}
inline const std::string& GetStakeListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetStakeListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStakeListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStakeListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetStakeListAck.message)
  return _impl_.message_.Release();
}
inline void GetStakeListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetStakeListAck.message)
}

// repeated .StakeItem list = 4;
inline int GetStakeListAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetStakeListAck::list_size() const {
  return _internal_list_size();
}
inline void GetStakeListAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::StakeItem* GetStakeListAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetStakeListAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeItem >*
GetStakeListAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetStakeListAck.list)
  return &_impl_.list_;
}
inline const ::StakeItem& GetStakeListAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::StakeItem& GetStakeListAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetStakeListAck.list)
  return _internal_list(index);
}
inline ::StakeItem* GetStakeListAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::StakeItem* GetStakeListAck::add_list() {
  ::StakeItem* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetStakeListAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeItem >&
GetStakeListAck::list() const {
  // @@protoc_insertion_point(field_list:GetStakeListAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// GetInvestListReq

// string version = 1;
inline void GetInvestListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetInvestListReq::version() const {
  // @@protoc_insertion_point(field_get:GetInvestListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInvestListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetInvestListReq.version)
}
inline std::string* GetInvestListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetInvestListReq.version)
  return _s;
}
inline const std::string& GetInvestListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetInvestListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInvestListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInvestListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetInvestListReq.version)
  return _impl_.version_.Release();
}
inline void GetInvestListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetInvestListReq.version)
}

// string addr = 2;
inline void GetInvestListReq::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetInvestListReq::addr() const {
  // @@protoc_insertion_point(field_get:GetInvestListReq.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInvestListReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetInvestListReq.addr)
}
inline std::string* GetInvestListReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:GetInvestListReq.addr)
  return _s;
}
inline const std::string& GetInvestListReq::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void GetInvestListReq::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInvestListReq::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInvestListReq::release_addr() {
  // @@protoc_insertion_point(field_release:GetInvestListReq.addr)
  return _impl_.addr_.Release();
}
inline void GetInvestListReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetInvestListReq.addr)
}

// -------------------------------------------------------------------

// InvestItem

// string blockhash = 1;
inline void InvestItem::clear_blockhash() {
  _impl_.blockhash_.ClearToEmpty();
}
inline const std::string& InvestItem::blockhash() const {
  // @@protoc_insertion_point(field_get:InvestItem.blockhash)
  return _internal_blockhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvestItem::set_blockhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blockhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InvestItem.blockhash)
}
inline std::string* InvestItem::mutable_blockhash() {
  std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:InvestItem.blockhash)
  return _s;
}
inline const std::string& InvestItem::_internal_blockhash() const {
  return _impl_.blockhash_.Get();
}
inline void InvestItem::_internal_set_blockhash(const std::string& value) {
  
  _impl_.blockhash_.Set(value, GetArenaForAllocation());
}
inline std::string* InvestItem::_internal_mutable_blockhash() {
  
  return _impl_.blockhash_.Mutable(GetArenaForAllocation());
}
inline std::string* InvestItem::release_blockhash() {
  // @@protoc_insertion_point(field_release:InvestItem.blockhash)
  return _impl_.blockhash_.Release();
}
inline void InvestItem::set_allocated_blockhash(std::string* blockhash) {
  if (blockhash != nullptr) {
    
  } else {
    
  }
  _impl_.blockhash_.SetAllocated(blockhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InvestItem.blockhash)
}

// uint32 blockheight = 2;
inline void InvestItem::clear_blockheight() {
  _impl_.blockheight_ = 0u;
}
inline uint32_t InvestItem::_internal_blockheight() const {
  return _impl_.blockheight_;
}
inline uint32_t InvestItem::blockheight() const {
  // @@protoc_insertion_point(field_get:InvestItem.blockheight)
  return _internal_blockheight();
}
inline void InvestItem::_internal_set_blockheight(uint32_t value) {
  
  _impl_.blockheight_ = value;
}
inline void InvestItem::set_blockheight(uint32_t value) {
  _internal_set_blockheight(value);
  // @@protoc_insertion_point(field_set:InvestItem.blockheight)
}

// string utxo = 3;
inline void InvestItem::clear_utxo() {
  _impl_.utxo_.ClearToEmpty();
}
inline const std::string& InvestItem::utxo() const {
  // @@protoc_insertion_point(field_get:InvestItem.utxo)
  return _internal_utxo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvestItem::set_utxo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.utxo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InvestItem.utxo)
}
inline std::string* InvestItem::mutable_utxo() {
  std::string* _s = _internal_mutable_utxo();
  // @@protoc_insertion_point(field_mutable:InvestItem.utxo)
  return _s;
}
inline const std::string& InvestItem::_internal_utxo() const {
  return _impl_.utxo_.Get();
}
inline void InvestItem::_internal_set_utxo(const std::string& value) {
  
  _impl_.utxo_.Set(value, GetArenaForAllocation());
}
inline std::string* InvestItem::_internal_mutable_utxo() {
  
  return _impl_.utxo_.Mutable(GetArenaForAllocation());
}
inline std::string* InvestItem::release_utxo() {
  // @@protoc_insertion_point(field_release:InvestItem.utxo)
  return _impl_.utxo_.Release();
}
inline void InvestItem::set_allocated_utxo(std::string* utxo) {
  if (utxo != nullptr) {
    
  } else {
    
  }
  _impl_.utxo_.SetAllocated(utxo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utxo_.IsDefault()) {
    _impl_.utxo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InvestItem.utxo)
}

// uint64 amount = 4;
inline void InvestItem::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
}
inline uint64_t InvestItem::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t InvestItem::amount() const {
  // @@protoc_insertion_point(field_get:InvestItem.amount)
  return _internal_amount();
}
inline void InvestItem::_internal_set_amount(uint64_t value) {
  
  _impl_.amount_ = value;
}
inline void InvestItem::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:InvestItem.amount)
}

// uint64 time = 5;
inline void InvestItem::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t InvestItem::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t InvestItem::time() const {
  // @@protoc_insertion_point(field_get:InvestItem.time)
  return _internal_time();
}
inline void InvestItem::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void InvestItem::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:InvestItem.time)
}

// string fromaddr = 6;
inline void InvestItem::clear_fromaddr() {
  _impl_.fromaddr_.ClearToEmpty();
}
inline const std::string& InvestItem::fromaddr() const {
  // @@protoc_insertion_point(field_get:InvestItem.fromaddr)
  return _internal_fromaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvestItem::set_fromaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fromaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InvestItem.fromaddr)
}
inline std::string* InvestItem::mutable_fromaddr() {
  std::string* _s = _internal_mutable_fromaddr();
  // @@protoc_insertion_point(field_mutable:InvestItem.fromaddr)
  return _s;
}
inline const std::string& InvestItem::_internal_fromaddr() const {
  return _impl_.fromaddr_.Get();
}
inline void InvestItem::_internal_set_fromaddr(const std::string& value) {
  
  _impl_.fromaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* InvestItem::_internal_mutable_fromaddr() {
  
  return _impl_.fromaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* InvestItem::release_fromaddr() {
  // @@protoc_insertion_point(field_release:InvestItem.fromaddr)
  return _impl_.fromaddr_.Release();
}
inline void InvestItem::set_allocated_fromaddr(std::string* fromaddr) {
  if (fromaddr != nullptr) {
    
  } else {
    
  }
  _impl_.fromaddr_.SetAllocated(fromaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fromaddr_.IsDefault()) {
    _impl_.fromaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InvestItem.fromaddr)
}

// string toaddr = 7;
inline void InvestItem::clear_toaddr() {
  _impl_.toaddr_.ClearToEmpty();
}
inline const std::string& InvestItem::toaddr() const {
  // @@protoc_insertion_point(field_get:InvestItem.toaddr)
  return _internal_toaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvestItem::set_toaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.toaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InvestItem.toaddr)
}
inline std::string* InvestItem::mutable_toaddr() {
  std::string* _s = _internal_mutable_toaddr();
  // @@protoc_insertion_point(field_mutable:InvestItem.toaddr)
  return _s;
}
inline const std::string& InvestItem::_internal_toaddr() const {
  return _impl_.toaddr_.Get();
}
inline void InvestItem::_internal_set_toaddr(const std::string& value) {
  
  _impl_.toaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* InvestItem::_internal_mutable_toaddr() {
  
  return _impl_.toaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* InvestItem::release_toaddr() {
  // @@protoc_insertion_point(field_release:InvestItem.toaddr)
  return _impl_.toaddr_.Release();
}
inline void InvestItem::set_allocated_toaddr(std::string* toaddr) {
  if (toaddr != nullptr) {
    
  } else {
    
  }
  _impl_.toaddr_.SetAllocated(toaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.toaddr_.IsDefault()) {
    _impl_.toaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InvestItem.toaddr)
}

// string detail = 8;
inline void InvestItem::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& InvestItem::detail() const {
  // @@protoc_insertion_point(field_get:InvestItem.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvestItem::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InvestItem.detail)
}
inline std::string* InvestItem::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:InvestItem.detail)
  return _s;
}
inline const std::string& InvestItem::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void InvestItem::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* InvestItem::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* InvestItem::release_detail() {
  // @@protoc_insertion_point(field_release:InvestItem.detail)
  return _impl_.detail_.Release();
}
inline void InvestItem::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InvestItem.detail)
}

// -------------------------------------------------------------------

// GetInvestListAck

// string version = 1;
inline void GetInvestListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetInvestListAck::version() const {
  // @@protoc_insertion_point(field_get:GetInvestListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInvestListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetInvestListAck.version)
}
inline std::string* GetInvestListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetInvestListAck.version)
  return _s;
}
inline const std::string& GetInvestListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetInvestListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInvestListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInvestListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetInvestListAck.version)
  return _impl_.version_.Release();
}
inline void GetInvestListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetInvestListAck.version)
}

// int32 code = 2;
inline void GetInvestListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetInvestListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetInvestListAck::code() const {
  // @@protoc_insertion_point(field_get:GetInvestListAck.code)
  return _internal_code();
}
inline void GetInvestListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetInvestListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetInvestListAck.code)
}

// string message = 3;
inline void GetInvestListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetInvestListAck::message() const {
  // @@protoc_insertion_point(field_get:GetInvestListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetInvestListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetInvestListAck.message)
}
inline std::string* GetInvestListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetInvestListAck.message)
  return _s;
}
inline const std::string& GetInvestListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetInvestListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetInvestListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetInvestListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetInvestListAck.message)
  return _impl_.message_.Release();
}
inline void GetInvestListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetInvestListAck.message)
}

// repeated .InvestItem list = 4;
inline int GetInvestListAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetInvestListAck::list_size() const {
  return _internal_list_size();
}
inline void GetInvestListAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::InvestItem* GetInvestListAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetInvestListAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestItem >*
GetInvestListAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetInvestListAck.list)
  return &_impl_.list_;
}
inline const ::InvestItem& GetInvestListAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::InvestItem& GetInvestListAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetInvestListAck.list)
  return _internal_list(index);
}
inline ::InvestItem* GetInvestListAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::InvestItem* GetInvestListAck::add_list() {
  ::InvestItem* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetInvestListAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestItem >&
GetInvestListAck::list() const {
  // @@protoc_insertion_point(field_list:GetInvestListAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// GetTxPendingListReq

// string version = 1;
inline void GetTxPendingListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetTxPendingListReq::version() const {
  // @@protoc_insertion_point(field_get:GetTxPendingListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxPendingListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxPendingListReq.version)
}
inline std::string* GetTxPendingListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetTxPendingListReq.version)
  return _s;
}
inline const std::string& GetTxPendingListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetTxPendingListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxPendingListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxPendingListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetTxPendingListReq.version)
  return _impl_.version_.Release();
}
inline void GetTxPendingListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxPendingListReq.version)
}

// repeated string addr = 2;
inline int GetTxPendingListReq::_internal_addr_size() const {
  return _impl_.addr_.size();
}
inline int GetTxPendingListReq::addr_size() const {
  return _internal_addr_size();
}
inline void GetTxPendingListReq::clear_addr() {
  _impl_.addr_.Clear();
}
inline std::string* GetTxPendingListReq::add_addr() {
  std::string* _s = _internal_add_addr();
  // @@protoc_insertion_point(field_add_mutable:GetTxPendingListReq.addr)
  return _s;
}
inline const std::string& GetTxPendingListReq::_internal_addr(int index) const {
  return _impl_.addr_.Get(index);
}
inline const std::string& GetTxPendingListReq::addr(int index) const {
  // @@protoc_insertion_point(field_get:GetTxPendingListReq.addr)
  return _internal_addr(index);
}
inline std::string* GetTxPendingListReq::mutable_addr(int index) {
  // @@protoc_insertion_point(field_mutable:GetTxPendingListReq.addr)
  return _impl_.addr_.Mutable(index);
}
inline void GetTxPendingListReq::set_addr(int index, const std::string& value) {
  _impl_.addr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:GetTxPendingListReq.addr)
}
inline void GetTxPendingListReq::set_addr(int index, std::string&& value) {
  _impl_.addr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:GetTxPendingListReq.addr)
}
inline void GetTxPendingListReq::set_addr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GetTxPendingListReq.addr)
}
inline void GetTxPendingListReq::set_addr(int index, const char* value, size_t size) {
  _impl_.addr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetTxPendingListReq.addr)
}
inline std::string* GetTxPendingListReq::_internal_add_addr() {
  return _impl_.addr_.Add();
}
inline void GetTxPendingListReq::add_addr(const std::string& value) {
  _impl_.addr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GetTxPendingListReq.addr)
}
inline void GetTxPendingListReq::add_addr(std::string&& value) {
  _impl_.addr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:GetTxPendingListReq.addr)
}
inline void GetTxPendingListReq::add_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GetTxPendingListReq.addr)
}
inline void GetTxPendingListReq::add_addr(const char* value, size_t size) {
  _impl_.addr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GetTxPendingListReq.addr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetTxPendingListReq::addr() const {
  // @@protoc_insertion_point(field_list:GetTxPendingListReq.addr)
  return _impl_.addr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetTxPendingListReq::mutable_addr() {
  // @@protoc_insertion_point(field_mutable_list:GetTxPendingListReq.addr)
  return &_impl_.addr_;
}

// -------------------------------------------------------------------

// TxPendingItem

// string txHash = 1;
inline void TxPendingItem::clear_txhash() {
  _impl_.txhash_.ClearToEmpty();
}
inline const std::string& TxPendingItem::txhash() const {
  // @@protoc_insertion_point(field_get:TxPendingItem.txHash)
  return _internal_txhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxPendingItem::set_txhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxPendingItem.txHash)
}
inline std::string* TxPendingItem::mutable_txhash() {
  std::string* _s = _internal_mutable_txhash();
  // @@protoc_insertion_point(field_mutable:TxPendingItem.txHash)
  return _s;
}
inline const std::string& TxPendingItem::_internal_txhash() const {
  return _impl_.txhash_.Get();
}
inline void TxPendingItem::_internal_set_txhash(const std::string& value) {
  
  _impl_.txhash_.Set(value, GetArenaForAllocation());
}
inline std::string* TxPendingItem::_internal_mutable_txhash() {
  
  return _impl_.txhash_.Mutable(GetArenaForAllocation());
}
inline std::string* TxPendingItem::release_txhash() {
  // @@protoc_insertion_point(field_release:TxPendingItem.txHash)
  return _impl_.txhash_.Release();
}
inline void TxPendingItem::set_allocated_txhash(std::string* txhash) {
  if (txhash != nullptr) {
    
  } else {
    
  }
  _impl_.txhash_.SetAllocated(txhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txhash_.IsDefault()) {
    _impl_.txhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxPendingItem.txHash)
}

// repeated string vins = 2;
inline int TxPendingItem::_internal_vins_size() const {
  return _impl_.vins_.size();
}
inline int TxPendingItem::vins_size() const {
  return _internal_vins_size();
}
inline void TxPendingItem::clear_vins() {
  _impl_.vins_.Clear();
}
inline std::string* TxPendingItem::add_vins() {
  std::string* _s = _internal_add_vins();
  // @@protoc_insertion_point(field_add_mutable:TxPendingItem.vins)
  return _s;
}
inline const std::string& TxPendingItem::_internal_vins(int index) const {
  return _impl_.vins_.Get(index);
}
inline const std::string& TxPendingItem::vins(int index) const {
  // @@protoc_insertion_point(field_get:TxPendingItem.vins)
  return _internal_vins(index);
}
inline std::string* TxPendingItem::mutable_vins(int index) {
  // @@protoc_insertion_point(field_mutable:TxPendingItem.vins)
  return _impl_.vins_.Mutable(index);
}
inline void TxPendingItem::set_vins(int index, const std::string& value) {
  _impl_.vins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TxPendingItem.vins)
}
inline void TxPendingItem::set_vins(int index, std::string&& value) {
  _impl_.vins_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TxPendingItem.vins)
}
inline void TxPendingItem::set_vins(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TxPendingItem.vins)
}
inline void TxPendingItem::set_vins(int index, const char* value, size_t size) {
  _impl_.vins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxPendingItem.vins)
}
inline std::string* TxPendingItem::_internal_add_vins() {
  return _impl_.vins_.Add();
}
inline void TxPendingItem::add_vins(const std::string& value) {
  _impl_.vins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TxPendingItem.vins)
}
inline void TxPendingItem::add_vins(std::string&& value) {
  _impl_.vins_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TxPendingItem.vins)
}
inline void TxPendingItem::add_vins(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TxPendingItem.vins)
}
inline void TxPendingItem::add_vins(const char* value, size_t size) {
  _impl_.vins_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TxPendingItem.vins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxPendingItem::vins() const {
  // @@protoc_insertion_point(field_list:TxPendingItem.vins)
  return _impl_.vins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxPendingItem::mutable_vins() {
  // @@protoc_insertion_point(field_mutable_list:TxPendingItem.vins)
  return &_impl_.vins_;
}

// repeated string fromaddr = 3;
inline int TxPendingItem::_internal_fromaddr_size() const {
  return _impl_.fromaddr_.size();
}
inline int TxPendingItem::fromaddr_size() const {
  return _internal_fromaddr_size();
}
inline void TxPendingItem::clear_fromaddr() {
  _impl_.fromaddr_.Clear();
}
inline std::string* TxPendingItem::add_fromaddr() {
  std::string* _s = _internal_add_fromaddr();
  // @@protoc_insertion_point(field_add_mutable:TxPendingItem.fromaddr)
  return _s;
}
inline const std::string& TxPendingItem::_internal_fromaddr(int index) const {
  return _impl_.fromaddr_.Get(index);
}
inline const std::string& TxPendingItem::fromaddr(int index) const {
  // @@protoc_insertion_point(field_get:TxPendingItem.fromaddr)
  return _internal_fromaddr(index);
}
inline std::string* TxPendingItem::mutable_fromaddr(int index) {
  // @@protoc_insertion_point(field_mutable:TxPendingItem.fromaddr)
  return _impl_.fromaddr_.Mutable(index);
}
inline void TxPendingItem::set_fromaddr(int index, const std::string& value) {
  _impl_.fromaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TxPendingItem.fromaddr)
}
inline void TxPendingItem::set_fromaddr(int index, std::string&& value) {
  _impl_.fromaddr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TxPendingItem.fromaddr)
}
inline void TxPendingItem::set_fromaddr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fromaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TxPendingItem.fromaddr)
}
inline void TxPendingItem::set_fromaddr(int index, const char* value, size_t size) {
  _impl_.fromaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxPendingItem.fromaddr)
}
inline std::string* TxPendingItem::_internal_add_fromaddr() {
  return _impl_.fromaddr_.Add();
}
inline void TxPendingItem::add_fromaddr(const std::string& value) {
  _impl_.fromaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TxPendingItem.fromaddr)
}
inline void TxPendingItem::add_fromaddr(std::string&& value) {
  _impl_.fromaddr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TxPendingItem.fromaddr)
}
inline void TxPendingItem::add_fromaddr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fromaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TxPendingItem.fromaddr)
}
inline void TxPendingItem::add_fromaddr(const char* value, size_t size) {
  _impl_.fromaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TxPendingItem.fromaddr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxPendingItem::fromaddr() const {
  // @@protoc_insertion_point(field_list:TxPendingItem.fromaddr)
  return _impl_.fromaddr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxPendingItem::mutable_fromaddr() {
  // @@protoc_insertion_point(field_mutable_list:TxPendingItem.fromaddr)
  return &_impl_.fromaddr_;
}

// repeated string toaddr = 4;
inline int TxPendingItem::_internal_toaddr_size() const {
  return _impl_.toaddr_.size();
}
inline int TxPendingItem::toaddr_size() const {
  return _internal_toaddr_size();
}
inline void TxPendingItem::clear_toaddr() {
  _impl_.toaddr_.Clear();
}
inline std::string* TxPendingItem::add_toaddr() {
  std::string* _s = _internal_add_toaddr();
  // @@protoc_insertion_point(field_add_mutable:TxPendingItem.toaddr)
  return _s;
}
inline const std::string& TxPendingItem::_internal_toaddr(int index) const {
  return _impl_.toaddr_.Get(index);
}
inline const std::string& TxPendingItem::toaddr(int index) const {
  // @@protoc_insertion_point(field_get:TxPendingItem.toaddr)
  return _internal_toaddr(index);
}
inline std::string* TxPendingItem::mutable_toaddr(int index) {
  // @@protoc_insertion_point(field_mutable:TxPendingItem.toaddr)
  return _impl_.toaddr_.Mutable(index);
}
inline void TxPendingItem::set_toaddr(int index, const std::string& value) {
  _impl_.toaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TxPendingItem.toaddr)
}
inline void TxPendingItem::set_toaddr(int index, std::string&& value) {
  _impl_.toaddr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TxPendingItem.toaddr)
}
inline void TxPendingItem::set_toaddr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.toaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TxPendingItem.toaddr)
}
inline void TxPendingItem::set_toaddr(int index, const char* value, size_t size) {
  _impl_.toaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxPendingItem.toaddr)
}
inline std::string* TxPendingItem::_internal_add_toaddr() {
  return _impl_.toaddr_.Add();
}
inline void TxPendingItem::add_toaddr(const std::string& value) {
  _impl_.toaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TxPendingItem.toaddr)
}
inline void TxPendingItem::add_toaddr(std::string&& value) {
  _impl_.toaddr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TxPendingItem.toaddr)
}
inline void TxPendingItem::add_toaddr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.toaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TxPendingItem.toaddr)
}
inline void TxPendingItem::add_toaddr(const char* value, size_t size) {
  _impl_.toaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TxPendingItem.toaddr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxPendingItem::toaddr() const {
  // @@protoc_insertion_point(field_list:TxPendingItem.toaddr)
  return _impl_.toaddr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxPendingItem::mutable_toaddr() {
  // @@protoc_insertion_point(field_mutable_list:TxPendingItem.toaddr)
  return &_impl_.toaddr_;
}

// uint64 amount = 5;
inline void TxPendingItem::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
}
inline uint64_t TxPendingItem::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t TxPendingItem::amount() const {
  // @@protoc_insertion_point(field_get:TxPendingItem.amount)
  return _internal_amount();
}
inline void TxPendingItem::_internal_set_amount(uint64_t value) {
  
  _impl_.amount_ = value;
}
inline void TxPendingItem::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TxPendingItem.amount)
}

// uint64 time = 6;
inline void TxPendingItem::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t TxPendingItem::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t TxPendingItem::time() const {
  // @@protoc_insertion_point(field_get:TxPendingItem.time)
  return _internal_time();
}
inline void TxPendingItem::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void TxPendingItem::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:TxPendingItem.time)
}

// string detail = 7;
inline void TxPendingItem::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& TxPendingItem::detail() const {
  // @@protoc_insertion_point(field_get:TxPendingItem.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxPendingItem::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxPendingItem.detail)
}
inline std::string* TxPendingItem::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:TxPendingItem.detail)
  return _s;
}
inline const std::string& TxPendingItem::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void TxPendingItem::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* TxPendingItem::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* TxPendingItem::release_detail() {
  // @@protoc_insertion_point(field_release:TxPendingItem.detail)
  return _impl_.detail_.Release();
}
inline void TxPendingItem::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxPendingItem.detail)
}

// uint64 gas = 8;
inline void TxPendingItem::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TxPendingItem::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TxPendingItem::gas() const {
  // @@protoc_insertion_point(field_get:TxPendingItem.gas)
  return _internal_gas();
}
inline void TxPendingItem::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TxPendingItem::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:TxPendingItem.gas)
}

// repeated uint64 toAmount = 9;
inline int TxPendingItem::_internal_toamount_size() const {
  return _impl_.toamount_.size();
}
inline int TxPendingItem::toamount_size() const {
  return _internal_toamount_size();
}
inline void TxPendingItem::clear_toamount() {
  _impl_.toamount_.Clear();
}
inline uint64_t TxPendingItem::_internal_toamount(int index) const {
  return _impl_.toamount_.Get(index);
}
inline uint64_t TxPendingItem::toamount(int index) const {
  // @@protoc_insertion_point(field_get:TxPendingItem.toAmount)
  return _internal_toamount(index);
}
inline void TxPendingItem::set_toamount(int index, uint64_t value) {
  _impl_.toamount_.Set(index, value);
  // @@protoc_insertion_point(field_set:TxPendingItem.toAmount)
}
inline void TxPendingItem::_internal_add_toamount(uint64_t value) {
  _impl_.toamount_.Add(value);
}
inline void TxPendingItem::add_toamount(uint64_t value) {
  _internal_add_toamount(value);
  // @@protoc_insertion_point(field_add:TxPendingItem.toAmount)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TxPendingItem::_internal_toamount() const {
  return _impl_.toamount_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TxPendingItem::toamount() const {
  // @@protoc_insertion_point(field_list:TxPendingItem.toAmount)
  return _internal_toamount();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TxPendingItem::_internal_mutable_toamount() {
  return &_impl_.toamount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TxPendingItem::mutable_toamount() {
  // @@protoc_insertion_point(field_mutable_list:TxPendingItem.toAmount)
  return _internal_mutable_toamount();
}

// .TxType type = 10;
inline void TxPendingItem::clear_type() {
  _impl_.type_ = 0;
}
inline ::TxType TxPendingItem::_internal_type() const {
  return static_cast< ::TxType >(_impl_.type_);
}
inline ::TxType TxPendingItem::type() const {
  // @@protoc_insertion_point(field_get:TxPendingItem.type)
  return _internal_type();
}
inline void TxPendingItem::_internal_set_type(::TxType value) {
  
  _impl_.type_ = value;
}
inline void TxPendingItem::set_type(::TxType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TxPendingItem.type)
}

// -------------------------------------------------------------------

// GetTxPendingListAck

// string version = 1;
inline void GetTxPendingListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetTxPendingListAck::version() const {
  // @@protoc_insertion_point(field_get:GetTxPendingListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxPendingListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxPendingListAck.version)
}
inline std::string* GetTxPendingListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetTxPendingListAck.version)
  return _s;
}
inline const std::string& GetTxPendingListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetTxPendingListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxPendingListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxPendingListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetTxPendingListAck.version)
  return _impl_.version_.Release();
}
inline void GetTxPendingListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxPendingListAck.version)
}

// int32 code = 2;
inline void GetTxPendingListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetTxPendingListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetTxPendingListAck::code() const {
  // @@protoc_insertion_point(field_get:GetTxPendingListAck.code)
  return _internal_code();
}
inline void GetTxPendingListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetTxPendingListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetTxPendingListAck.code)
}

// string message = 3;
inline void GetTxPendingListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetTxPendingListAck::message() const {
  // @@protoc_insertion_point(field_get:GetTxPendingListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxPendingListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxPendingListAck.message)
}
inline std::string* GetTxPendingListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetTxPendingListAck.message)
  return _s;
}
inline const std::string& GetTxPendingListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetTxPendingListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxPendingListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxPendingListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetTxPendingListAck.message)
  return _impl_.message_.Release();
}
inline void GetTxPendingListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxPendingListAck.message)
}

// repeated string addr = 4;
inline int GetTxPendingListAck::_internal_addr_size() const {
  return _impl_.addr_.size();
}
inline int GetTxPendingListAck::addr_size() const {
  return _internal_addr_size();
}
inline void GetTxPendingListAck::clear_addr() {
  _impl_.addr_.Clear();
}
inline std::string* GetTxPendingListAck::add_addr() {
  std::string* _s = _internal_add_addr();
  // @@protoc_insertion_point(field_add_mutable:GetTxPendingListAck.addr)
  return _s;
}
inline const std::string& GetTxPendingListAck::_internal_addr(int index) const {
  return _impl_.addr_.Get(index);
}
inline const std::string& GetTxPendingListAck::addr(int index) const {
  // @@protoc_insertion_point(field_get:GetTxPendingListAck.addr)
  return _internal_addr(index);
}
inline std::string* GetTxPendingListAck::mutable_addr(int index) {
  // @@protoc_insertion_point(field_mutable:GetTxPendingListAck.addr)
  return _impl_.addr_.Mutable(index);
}
inline void GetTxPendingListAck::set_addr(int index, const std::string& value) {
  _impl_.addr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:GetTxPendingListAck.addr)
}
inline void GetTxPendingListAck::set_addr(int index, std::string&& value) {
  _impl_.addr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:GetTxPendingListAck.addr)
}
inline void GetTxPendingListAck::set_addr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GetTxPendingListAck.addr)
}
inline void GetTxPendingListAck::set_addr(int index, const char* value, size_t size) {
  _impl_.addr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetTxPendingListAck.addr)
}
inline std::string* GetTxPendingListAck::_internal_add_addr() {
  return _impl_.addr_.Add();
}
inline void GetTxPendingListAck::add_addr(const std::string& value) {
  _impl_.addr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GetTxPendingListAck.addr)
}
inline void GetTxPendingListAck::add_addr(std::string&& value) {
  _impl_.addr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:GetTxPendingListAck.addr)
}
inline void GetTxPendingListAck::add_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GetTxPendingListAck.addr)
}
inline void GetTxPendingListAck::add_addr(const char* value, size_t size) {
  _impl_.addr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GetTxPendingListAck.addr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetTxPendingListAck::addr() const {
  // @@protoc_insertion_point(field_list:GetTxPendingListAck.addr)
  return _impl_.addr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetTxPendingListAck::mutable_addr() {
  // @@protoc_insertion_point(field_mutable_list:GetTxPendingListAck.addr)
  return &_impl_.addr_;
}

// repeated .TxPendingItem list = 5;
inline int GetTxPendingListAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetTxPendingListAck::list_size() const {
  return _internal_list_size();
}
inline void GetTxPendingListAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::TxPendingItem* GetTxPendingListAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetTxPendingListAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxPendingItem >*
GetTxPendingListAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetTxPendingListAck.list)
  return &_impl_.list_;
}
inline const ::TxPendingItem& GetTxPendingListAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::TxPendingItem& GetTxPendingListAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetTxPendingListAck.list)
  return _internal_list(index);
}
inline ::TxPendingItem* GetTxPendingListAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::TxPendingItem* GetTxPendingListAck::add_list() {
  ::TxPendingItem* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetTxPendingListAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxPendingItem >&
GetTxPendingListAck::list() const {
  // @@protoc_insertion_point(field_list:GetTxPendingListAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// GetTxFailureListReq

// string version = 1;
inline void GetTxFailureListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetTxFailureListReq::version() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxFailureListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxFailureListReq.version)
}
inline std::string* GetTxFailureListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetTxFailureListReq.version)
  return _s;
}
inline const std::string& GetTxFailureListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetTxFailureListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxFailureListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxFailureListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetTxFailureListReq.version)
  return _impl_.version_.Release();
}
inline void GetTxFailureListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxFailureListReq.version)
}

// string addr = 2;
inline void GetTxFailureListReq::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetTxFailureListReq::addr() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListReq.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxFailureListReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxFailureListReq.addr)
}
inline std::string* GetTxFailureListReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:GetTxFailureListReq.addr)
  return _s;
}
inline const std::string& GetTxFailureListReq::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void GetTxFailureListReq::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxFailureListReq::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxFailureListReq::release_addr() {
  // @@protoc_insertion_point(field_release:GetTxFailureListReq.addr)
  return _impl_.addr_.Release();
}
inline void GetTxFailureListReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxFailureListReq.addr)
}

// string txhash = 3;
inline void GetTxFailureListReq::clear_txhash() {
  _impl_.txhash_.ClearToEmpty();
}
inline const std::string& GetTxFailureListReq::txhash() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListReq.txhash)
  return _internal_txhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxFailureListReq::set_txhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxFailureListReq.txhash)
}
inline std::string* GetTxFailureListReq::mutable_txhash() {
  std::string* _s = _internal_mutable_txhash();
  // @@protoc_insertion_point(field_mutable:GetTxFailureListReq.txhash)
  return _s;
}
inline const std::string& GetTxFailureListReq::_internal_txhash() const {
  return _impl_.txhash_.Get();
}
inline void GetTxFailureListReq::_internal_set_txhash(const std::string& value) {
  
  _impl_.txhash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxFailureListReq::_internal_mutable_txhash() {
  
  return _impl_.txhash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxFailureListReq::release_txhash() {
  // @@protoc_insertion_point(field_release:GetTxFailureListReq.txhash)
  return _impl_.txhash_.Release();
}
inline void GetTxFailureListReq::set_allocated_txhash(std::string* txhash) {
  if (txhash != nullptr) {
    
  } else {
    
  }
  _impl_.txhash_.SetAllocated(txhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txhash_.IsDefault()) {
    _impl_.txhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxFailureListReq.txhash)
}

// uint32 count = 4;
inline void GetTxFailureListReq::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t GetTxFailureListReq::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t GetTxFailureListReq::count() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListReq.count)
  return _internal_count();
}
inline void GetTxFailureListReq::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void GetTxFailureListReq::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:GetTxFailureListReq.count)
}

// -------------------------------------------------------------------

// TxFailureItem

// string txHash = 1;
inline void TxFailureItem::clear_txhash() {
  _impl_.txhash_.ClearToEmpty();
}
inline const std::string& TxFailureItem::txhash() const {
  // @@protoc_insertion_point(field_get:TxFailureItem.txHash)
  return _internal_txhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxFailureItem::set_txhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxFailureItem.txHash)
}
inline std::string* TxFailureItem::mutable_txhash() {
  std::string* _s = _internal_mutable_txhash();
  // @@protoc_insertion_point(field_mutable:TxFailureItem.txHash)
  return _s;
}
inline const std::string& TxFailureItem::_internal_txhash() const {
  return _impl_.txhash_.Get();
}
inline void TxFailureItem::_internal_set_txhash(const std::string& value) {
  
  _impl_.txhash_.Set(value, GetArenaForAllocation());
}
inline std::string* TxFailureItem::_internal_mutable_txhash() {
  
  return _impl_.txhash_.Mutable(GetArenaForAllocation());
}
inline std::string* TxFailureItem::release_txhash() {
  // @@protoc_insertion_point(field_release:TxFailureItem.txHash)
  return _impl_.txhash_.Release();
}
inline void TxFailureItem::set_allocated_txhash(std::string* txhash) {
  if (txhash != nullptr) {
    
  } else {
    
  }
  _impl_.txhash_.SetAllocated(txhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txhash_.IsDefault()) {
    _impl_.txhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxFailureItem.txHash)
}

// repeated string vins = 2;
inline int TxFailureItem::_internal_vins_size() const {
  return _impl_.vins_.size();
}
inline int TxFailureItem::vins_size() const {
  return _internal_vins_size();
}
inline void TxFailureItem::clear_vins() {
  _impl_.vins_.Clear();
}
inline std::string* TxFailureItem::add_vins() {
  std::string* _s = _internal_add_vins();
  // @@protoc_insertion_point(field_add_mutable:TxFailureItem.vins)
  return _s;
}
inline const std::string& TxFailureItem::_internal_vins(int index) const {
  return _impl_.vins_.Get(index);
}
inline const std::string& TxFailureItem::vins(int index) const {
  // @@protoc_insertion_point(field_get:TxFailureItem.vins)
  return _internal_vins(index);
}
inline std::string* TxFailureItem::mutable_vins(int index) {
  // @@protoc_insertion_point(field_mutable:TxFailureItem.vins)
  return _impl_.vins_.Mutable(index);
}
inline void TxFailureItem::set_vins(int index, const std::string& value) {
  _impl_.vins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TxFailureItem.vins)
}
inline void TxFailureItem::set_vins(int index, std::string&& value) {
  _impl_.vins_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TxFailureItem.vins)
}
inline void TxFailureItem::set_vins(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vins_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TxFailureItem.vins)
}
inline void TxFailureItem::set_vins(int index, const char* value, size_t size) {
  _impl_.vins_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxFailureItem.vins)
}
inline std::string* TxFailureItem::_internal_add_vins() {
  return _impl_.vins_.Add();
}
inline void TxFailureItem::add_vins(const std::string& value) {
  _impl_.vins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TxFailureItem.vins)
}
inline void TxFailureItem::add_vins(std::string&& value) {
  _impl_.vins_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TxFailureItem.vins)
}
inline void TxFailureItem::add_vins(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.vins_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TxFailureItem.vins)
}
inline void TxFailureItem::add_vins(const char* value, size_t size) {
  _impl_.vins_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TxFailureItem.vins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxFailureItem::vins() const {
  // @@protoc_insertion_point(field_list:TxFailureItem.vins)
  return _impl_.vins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxFailureItem::mutable_vins() {
  // @@protoc_insertion_point(field_mutable_list:TxFailureItem.vins)
  return &_impl_.vins_;
}

// repeated string fromaddr = 3;
inline int TxFailureItem::_internal_fromaddr_size() const {
  return _impl_.fromaddr_.size();
}
inline int TxFailureItem::fromaddr_size() const {
  return _internal_fromaddr_size();
}
inline void TxFailureItem::clear_fromaddr() {
  _impl_.fromaddr_.Clear();
}
inline std::string* TxFailureItem::add_fromaddr() {
  std::string* _s = _internal_add_fromaddr();
  // @@protoc_insertion_point(field_add_mutable:TxFailureItem.fromaddr)
  return _s;
}
inline const std::string& TxFailureItem::_internal_fromaddr(int index) const {
  return _impl_.fromaddr_.Get(index);
}
inline const std::string& TxFailureItem::fromaddr(int index) const {
  // @@protoc_insertion_point(field_get:TxFailureItem.fromaddr)
  return _internal_fromaddr(index);
}
inline std::string* TxFailureItem::mutable_fromaddr(int index) {
  // @@protoc_insertion_point(field_mutable:TxFailureItem.fromaddr)
  return _impl_.fromaddr_.Mutable(index);
}
inline void TxFailureItem::set_fromaddr(int index, const std::string& value) {
  _impl_.fromaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TxFailureItem.fromaddr)
}
inline void TxFailureItem::set_fromaddr(int index, std::string&& value) {
  _impl_.fromaddr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TxFailureItem.fromaddr)
}
inline void TxFailureItem::set_fromaddr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fromaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TxFailureItem.fromaddr)
}
inline void TxFailureItem::set_fromaddr(int index, const char* value, size_t size) {
  _impl_.fromaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxFailureItem.fromaddr)
}
inline std::string* TxFailureItem::_internal_add_fromaddr() {
  return _impl_.fromaddr_.Add();
}
inline void TxFailureItem::add_fromaddr(const std::string& value) {
  _impl_.fromaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TxFailureItem.fromaddr)
}
inline void TxFailureItem::add_fromaddr(std::string&& value) {
  _impl_.fromaddr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TxFailureItem.fromaddr)
}
inline void TxFailureItem::add_fromaddr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.fromaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TxFailureItem.fromaddr)
}
inline void TxFailureItem::add_fromaddr(const char* value, size_t size) {
  _impl_.fromaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TxFailureItem.fromaddr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxFailureItem::fromaddr() const {
  // @@protoc_insertion_point(field_list:TxFailureItem.fromaddr)
  return _impl_.fromaddr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxFailureItem::mutable_fromaddr() {
  // @@protoc_insertion_point(field_mutable_list:TxFailureItem.fromaddr)
  return &_impl_.fromaddr_;
}

// repeated string toaddr = 4;
inline int TxFailureItem::_internal_toaddr_size() const {
  return _impl_.toaddr_.size();
}
inline int TxFailureItem::toaddr_size() const {
  return _internal_toaddr_size();
}
inline void TxFailureItem::clear_toaddr() {
  _impl_.toaddr_.Clear();
}
inline std::string* TxFailureItem::add_toaddr() {
  std::string* _s = _internal_add_toaddr();
  // @@protoc_insertion_point(field_add_mutable:TxFailureItem.toaddr)
  return _s;
}
inline const std::string& TxFailureItem::_internal_toaddr(int index) const {
  return _impl_.toaddr_.Get(index);
}
inline const std::string& TxFailureItem::toaddr(int index) const {
  // @@protoc_insertion_point(field_get:TxFailureItem.toaddr)
  return _internal_toaddr(index);
}
inline std::string* TxFailureItem::mutable_toaddr(int index) {
  // @@protoc_insertion_point(field_mutable:TxFailureItem.toaddr)
  return _impl_.toaddr_.Mutable(index);
}
inline void TxFailureItem::set_toaddr(int index, const std::string& value) {
  _impl_.toaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TxFailureItem.toaddr)
}
inline void TxFailureItem::set_toaddr(int index, std::string&& value) {
  _impl_.toaddr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TxFailureItem.toaddr)
}
inline void TxFailureItem::set_toaddr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.toaddr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TxFailureItem.toaddr)
}
inline void TxFailureItem::set_toaddr(int index, const char* value, size_t size) {
  _impl_.toaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxFailureItem.toaddr)
}
inline std::string* TxFailureItem::_internal_add_toaddr() {
  return _impl_.toaddr_.Add();
}
inline void TxFailureItem::add_toaddr(const std::string& value) {
  _impl_.toaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TxFailureItem.toaddr)
}
inline void TxFailureItem::add_toaddr(std::string&& value) {
  _impl_.toaddr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TxFailureItem.toaddr)
}
inline void TxFailureItem::add_toaddr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.toaddr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TxFailureItem.toaddr)
}
inline void TxFailureItem::add_toaddr(const char* value, size_t size) {
  _impl_.toaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TxFailureItem.toaddr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxFailureItem::toaddr() const {
  // @@protoc_insertion_point(field_list:TxFailureItem.toaddr)
  return _impl_.toaddr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxFailureItem::mutable_toaddr() {
  // @@protoc_insertion_point(field_mutable_list:TxFailureItem.toaddr)
  return &_impl_.toaddr_;
}

// uint64 amount = 5;
inline void TxFailureItem::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
}
inline uint64_t TxFailureItem::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t TxFailureItem::amount() const {
  // @@protoc_insertion_point(field_get:TxFailureItem.amount)
  return _internal_amount();
}
inline void TxFailureItem::_internal_set_amount(uint64_t value) {
  
  _impl_.amount_ = value;
}
inline void TxFailureItem::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:TxFailureItem.amount)
}

// uint64 time = 6;
inline void TxFailureItem::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t TxFailureItem::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t TxFailureItem::time() const {
  // @@protoc_insertion_point(field_get:TxFailureItem.time)
  return _internal_time();
}
inline void TxFailureItem::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void TxFailureItem::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:TxFailureItem.time)
}

// string detail = 7;
inline void TxFailureItem::clear_detail() {
  _impl_.detail_.ClearToEmpty();
}
inline const std::string& TxFailureItem::detail() const {
  // @@protoc_insertion_point(field_get:TxFailureItem.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxFailureItem::set_detail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxFailureItem.detail)
}
inline std::string* TxFailureItem::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:TxFailureItem.detail)
  return _s;
}
inline const std::string& TxFailureItem::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void TxFailureItem::_internal_set_detail(const std::string& value) {
  
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* TxFailureItem::_internal_mutable_detail() {
  
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* TxFailureItem::release_detail() {
  // @@protoc_insertion_point(field_release:TxFailureItem.detail)
  return _impl_.detail_.Release();
}
inline void TxFailureItem::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxFailureItem.detail)
}

// uint64 gas = 8;
inline void TxFailureItem::clear_gas() {
  _impl_.gas_ = uint64_t{0u};
}
inline uint64_t TxFailureItem::_internal_gas() const {
  return _impl_.gas_;
}
inline uint64_t TxFailureItem::gas() const {
  // @@protoc_insertion_point(field_get:TxFailureItem.gas)
  return _internal_gas();
}
inline void TxFailureItem::_internal_set_gas(uint64_t value) {
  
  _impl_.gas_ = value;
}
inline void TxFailureItem::set_gas(uint64_t value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:TxFailureItem.gas)
}

// repeated uint64 toAmount = 9;
inline int TxFailureItem::_internal_toamount_size() const {
  return _impl_.toamount_.size();
}
inline int TxFailureItem::toamount_size() const {
  return _internal_toamount_size();
}
inline void TxFailureItem::clear_toamount() {
  _impl_.toamount_.Clear();
}
inline uint64_t TxFailureItem::_internal_toamount(int index) const {
  return _impl_.toamount_.Get(index);
}
inline uint64_t TxFailureItem::toamount(int index) const {
  // @@protoc_insertion_point(field_get:TxFailureItem.toAmount)
  return _internal_toamount(index);
}
inline void TxFailureItem::set_toamount(int index, uint64_t value) {
  _impl_.toamount_.Set(index, value);
  // @@protoc_insertion_point(field_set:TxFailureItem.toAmount)
}
inline void TxFailureItem::_internal_add_toamount(uint64_t value) {
  _impl_.toamount_.Add(value);
}
inline void TxFailureItem::add_toamount(uint64_t value) {
  _internal_add_toamount(value);
  // @@protoc_insertion_point(field_add:TxFailureItem.toAmount)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TxFailureItem::_internal_toamount() const {
  return _impl_.toamount_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
TxFailureItem::toamount() const {
  // @@protoc_insertion_point(field_list:TxFailureItem.toAmount)
  return _internal_toamount();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TxFailureItem::_internal_mutable_toamount() {
  return &_impl_.toamount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
TxFailureItem::mutable_toamount() {
  // @@protoc_insertion_point(field_mutable_list:TxFailureItem.toAmount)
  return _internal_mutable_toamount();
}

// .TxType type = 10;
inline void TxFailureItem::clear_type() {
  _impl_.type_ = 0;
}
inline ::TxType TxFailureItem::_internal_type() const {
  return static_cast< ::TxType >(_impl_.type_);
}
inline ::TxType TxFailureItem::type() const {
  // @@protoc_insertion_point(field_get:TxFailureItem.type)
  return _internal_type();
}
inline void TxFailureItem::_internal_set_type(::TxType value) {
  
  _impl_.type_ = value;
}
inline void TxFailureItem::set_type(::TxType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TxFailureItem.type)
}

// -------------------------------------------------------------------

// GetTxFailureListAck

// string version = 1;
inline void GetTxFailureListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetTxFailureListAck::version() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxFailureListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxFailureListAck.version)
}
inline std::string* GetTxFailureListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetTxFailureListAck.version)
  return _s;
}
inline const std::string& GetTxFailureListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetTxFailureListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxFailureListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxFailureListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetTxFailureListAck.version)
  return _impl_.version_.Release();
}
inline void GetTxFailureListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxFailureListAck.version)
}

// int32 code = 2;
inline void GetTxFailureListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetTxFailureListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetTxFailureListAck::code() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListAck.code)
  return _internal_code();
}
inline void GetTxFailureListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetTxFailureListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetTxFailureListAck.code)
}

// string message = 3;
inline void GetTxFailureListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetTxFailureListAck::message() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxFailureListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxFailureListAck.message)
}
inline std::string* GetTxFailureListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetTxFailureListAck.message)
  return _s;
}
inline const std::string& GetTxFailureListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetTxFailureListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxFailureListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxFailureListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetTxFailureListAck.message)
  return _impl_.message_.Release();
}
inline void GetTxFailureListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxFailureListAck.message)
}

// uint32 total = 4;
inline void GetTxFailureListAck::clear_total() {
  _impl_.total_ = 0u;
}
inline uint32_t GetTxFailureListAck::_internal_total() const {
  return _impl_.total_;
}
inline uint32_t GetTxFailureListAck::total() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListAck.total)
  return _internal_total();
}
inline void GetTxFailureListAck::_internal_set_total(uint32_t value) {
  
  _impl_.total_ = value;
}
inline void GetTxFailureListAck::set_total(uint32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:GetTxFailureListAck.total)
}

// repeated .TxFailureItem list = 5;
inline int GetTxFailureListAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetTxFailureListAck::list_size() const {
  return _internal_list_size();
}
inline void GetTxFailureListAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::TxFailureItem* GetTxFailureListAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetTxFailureListAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxFailureItem >*
GetTxFailureListAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetTxFailureListAck.list)
  return &_impl_.list_;
}
inline const ::TxFailureItem& GetTxFailureListAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::TxFailureItem& GetTxFailureListAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetTxFailureListAck.list)
  return _internal_list(index);
}
inline ::TxFailureItem* GetTxFailureListAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::TxFailureItem* GetTxFailureListAck::add_list() {
  ::TxFailureItem* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetTxFailureListAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TxFailureItem >&
GetTxFailureListAck::list() const {
  // @@protoc_insertion_point(field_list:GetTxFailureListAck.list)
  return _impl_.list_;
}

// string lasthash = 6;
inline void GetTxFailureListAck::clear_lasthash() {
  _impl_.lasthash_.ClearToEmpty();
}
inline const std::string& GetTxFailureListAck::lasthash() const {
  // @@protoc_insertion_point(field_get:GetTxFailureListAck.lasthash)
  return _internal_lasthash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTxFailureListAck::set_lasthash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lasthash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTxFailureListAck.lasthash)
}
inline std::string* GetTxFailureListAck::mutable_lasthash() {
  std::string* _s = _internal_mutable_lasthash();
  // @@protoc_insertion_point(field_mutable:GetTxFailureListAck.lasthash)
  return _s;
}
inline const std::string& GetTxFailureListAck::_internal_lasthash() const {
  return _impl_.lasthash_.Get();
}
inline void GetTxFailureListAck::_internal_set_lasthash(const std::string& value) {
  
  _impl_.lasthash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTxFailureListAck::_internal_mutable_lasthash() {
  
  return _impl_.lasthash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTxFailureListAck::release_lasthash() {
  // @@protoc_insertion_point(field_release:GetTxFailureListAck.lasthash)
  return _impl_.lasthash_.Release();
}
inline void GetTxFailureListAck::set_allocated_lasthash(std::string* lasthash) {
  if (lasthash != nullptr) {
    
  } else {
    
  }
  _impl_.lasthash_.SetAllocated(lasthash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lasthash_.IsDefault()) {
    _impl_.lasthash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTxFailureListAck.lasthash)
}

// -------------------------------------------------------------------

// GetUtxoReq

// string version = 1;
inline void GetUtxoReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetUtxoReq::version() const {
  // @@protoc_insertion_point(field_get:GetUtxoReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoReq.version)
}
inline std::string* GetUtxoReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetUtxoReq.version)
  return _s;
}
inline const std::string& GetUtxoReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetUtxoReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoReq::release_version() {
  // @@protoc_insertion_point(field_release:GetUtxoReq.version)
  return _impl_.version_.Release();
}
inline void GetUtxoReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoReq.version)
}

// string address = 2;
inline void GetUtxoReq::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetUtxoReq::address() const {
  // @@protoc_insertion_point(field_get:GetUtxoReq.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoReq::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoReq.address)
}
inline std::string* GetUtxoReq::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:GetUtxoReq.address)
  return _s;
}
inline const std::string& GetUtxoReq::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetUtxoReq::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoReq::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoReq::release_address() {
  // @@protoc_insertion_point(field_release:GetUtxoReq.address)
  return _impl_.address_.Release();
}
inline void GetUtxoReq::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoReq.address)
}

// -------------------------------------------------------------------

// Utxo

// string hash = 1;
inline void Utxo::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& Utxo::hash() const {
  // @@protoc_insertion_point(field_get:Utxo.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Utxo::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Utxo.hash)
}
inline std::string* Utxo::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:Utxo.hash)
  return _s;
}
inline const std::string& Utxo::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void Utxo::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Utxo::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Utxo::release_hash() {
  // @@protoc_insertion_point(field_release:Utxo.hash)
  return _impl_.hash_.Release();
}
inline void Utxo::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Utxo.hash)
}

// uint64 value = 2;
inline void Utxo::clear_value() {
  _impl_.value_ = uint64_t{0u};
}
inline uint64_t Utxo::_internal_value() const {
  return _impl_.value_;
}
inline uint64_t Utxo::value() const {
  // @@protoc_insertion_point(field_get:Utxo.value)
  return _internal_value();
}
inline void Utxo::_internal_set_value(uint64_t value) {
  
  _impl_.value_ = value;
}
inline void Utxo::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Utxo.value)
}

// uint32 n = 3;
inline void Utxo::clear_n() {
  _impl_.n_ = 0u;
}
inline uint32_t Utxo::_internal_n() const {
  return _impl_.n_;
}
inline uint32_t Utxo::n() const {
  // @@protoc_insertion_point(field_get:Utxo.n)
  return _internal_n();
}
inline void Utxo::_internal_set_n(uint32_t value) {
  
  _impl_.n_ = value;
}
inline void Utxo::set_n(uint32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:Utxo.n)
}

// -------------------------------------------------------------------

// GetUtxoAck

// string version = 1;
inline void GetUtxoAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetUtxoAck::version() const {
  // @@protoc_insertion_point(field_get:GetUtxoAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoAck.version)
}
inline std::string* GetUtxoAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetUtxoAck.version)
  return _s;
}
inline const std::string& GetUtxoAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetUtxoAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoAck::release_version() {
  // @@protoc_insertion_point(field_release:GetUtxoAck.version)
  return _impl_.version_.Release();
}
inline void GetUtxoAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoAck.version)
}

// int32 code = 2;
inline void GetUtxoAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetUtxoAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetUtxoAck::code() const {
  // @@protoc_insertion_point(field_get:GetUtxoAck.code)
  return _internal_code();
}
inline void GetUtxoAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetUtxoAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetUtxoAck.code)
}

// string message = 3;
inline void GetUtxoAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetUtxoAck::message() const {
  // @@protoc_insertion_point(field_get:GetUtxoAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoAck.message)
}
inline std::string* GetUtxoAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetUtxoAck.message)
  return _s;
}
inline const std::string& GetUtxoAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetUtxoAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoAck::release_message() {
  // @@protoc_insertion_point(field_release:GetUtxoAck.message)
  return _impl_.message_.Release();
}
inline void GetUtxoAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoAck.message)
}

// string address = 4;
inline void GetUtxoAck::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetUtxoAck::address() const {
  // @@protoc_insertion_point(field_get:GetUtxoAck.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoAck::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoAck.address)
}
inline std::string* GetUtxoAck::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:GetUtxoAck.address)
  return _s;
}
inline const std::string& GetUtxoAck::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetUtxoAck::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoAck::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoAck::release_address() {
  // @@protoc_insertion_point(field_release:GetUtxoAck.address)
  return _impl_.address_.Release();
}
inline void GetUtxoAck::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoAck.address)
}

// repeated .Utxo utxos = 5;
inline int GetUtxoAck::_internal_utxos_size() const {
  return _impl_.utxos_.size();
}
inline int GetUtxoAck::utxos_size() const {
  return _internal_utxos_size();
}
inline void GetUtxoAck::clear_utxos() {
  _impl_.utxos_.Clear();
}
inline ::Utxo* GetUtxoAck::mutable_utxos(int index) {
  // @@protoc_insertion_point(field_mutable:GetUtxoAck.utxos)
  return _impl_.utxos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Utxo >*
GetUtxoAck::mutable_utxos() {
  // @@protoc_insertion_point(field_mutable_list:GetUtxoAck.utxos)
  return &_impl_.utxos_;
}
inline const ::Utxo& GetUtxoAck::_internal_utxos(int index) const {
  return _impl_.utxos_.Get(index);
}
inline const ::Utxo& GetUtxoAck::utxos(int index) const {
  // @@protoc_insertion_point(field_get:GetUtxoAck.utxos)
  return _internal_utxos(index);
}
inline ::Utxo* GetUtxoAck::_internal_add_utxos() {
  return _impl_.utxos_.Add();
}
inline ::Utxo* GetUtxoAck::add_utxos() {
  ::Utxo* _add = _internal_add_utxos();
  // @@protoc_insertion_point(field_add:GetUtxoAck.utxos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Utxo >&
GetUtxoAck::utxos() const {
  // @@protoc_insertion_point(field_list:GetUtxoAck.utxos)
  return _impl_.utxos_;
}

// -------------------------------------------------------------------

// GetAllInvestAddressReq

// string version = 1;
inline void GetAllInvestAddressReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetAllInvestAddressReq::version() const {
  // @@protoc_insertion_point(field_get:GetAllInvestAddressReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllInvestAddressReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllInvestAddressReq.version)
}
inline std::string* GetAllInvestAddressReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetAllInvestAddressReq.version)
  return _s;
}
inline const std::string& GetAllInvestAddressReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetAllInvestAddressReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressReq::release_version() {
  // @@protoc_insertion_point(field_release:GetAllInvestAddressReq.version)
  return _impl_.version_.Release();
}
inline void GetAllInvestAddressReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllInvestAddressReq.version)
}

// string addr = 2;
inline void GetAllInvestAddressReq::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetAllInvestAddressReq::addr() const {
  // @@protoc_insertion_point(field_get:GetAllInvestAddressReq.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllInvestAddressReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllInvestAddressReq.addr)
}
inline std::string* GetAllInvestAddressReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:GetAllInvestAddressReq.addr)
  return _s;
}
inline const std::string& GetAllInvestAddressReq::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void GetAllInvestAddressReq::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressReq::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressReq::release_addr() {
  // @@protoc_insertion_point(field_release:GetAllInvestAddressReq.addr)
  return _impl_.addr_.Release();
}
inline void GetAllInvestAddressReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllInvestAddressReq.addr)
}

// -------------------------------------------------------------------

// InvestAddressItem

// string addr = 1;
inline void InvestAddressItem::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& InvestAddressItem::addr() const {
  // @@protoc_insertion_point(field_get:InvestAddressItem.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvestAddressItem::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InvestAddressItem.addr)
}
inline std::string* InvestAddressItem::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:InvestAddressItem.addr)
  return _s;
}
inline const std::string& InvestAddressItem::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void InvestAddressItem::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* InvestAddressItem::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* InvestAddressItem::release_addr() {
  // @@protoc_insertion_point(field_release:InvestAddressItem.addr)
  return _impl_.addr_.Release();
}
inline void InvestAddressItem::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InvestAddressItem.addr)
}

// uint64 value = 2;
inline void InvestAddressItem::clear_value() {
  _impl_.value_ = uint64_t{0u};
}
inline uint64_t InvestAddressItem::_internal_value() const {
  return _impl_.value_;
}
inline uint64_t InvestAddressItem::value() const {
  // @@protoc_insertion_point(field_get:InvestAddressItem.value)
  return _internal_value();
}
inline void InvestAddressItem::_internal_set_value(uint64_t value) {
  
  _impl_.value_ = value;
}
inline void InvestAddressItem::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:InvestAddressItem.value)
}

// -------------------------------------------------------------------

// GetAllInvestAddressAck

// string version = 1;
inline void GetAllInvestAddressAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetAllInvestAddressAck::version() const {
  // @@protoc_insertion_point(field_get:GetAllInvestAddressAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllInvestAddressAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllInvestAddressAck.version)
}
inline std::string* GetAllInvestAddressAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetAllInvestAddressAck.version)
  return _s;
}
inline const std::string& GetAllInvestAddressAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetAllInvestAddressAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressAck::release_version() {
  // @@protoc_insertion_point(field_release:GetAllInvestAddressAck.version)
  return _impl_.version_.Release();
}
inline void GetAllInvestAddressAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllInvestAddressAck.version)
}

// sint32 code = 2;
inline void GetAllInvestAddressAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetAllInvestAddressAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetAllInvestAddressAck::code() const {
  // @@protoc_insertion_point(field_get:GetAllInvestAddressAck.code)
  return _internal_code();
}
inline void GetAllInvestAddressAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetAllInvestAddressAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetAllInvestAddressAck.code)
}

// string message = 3;
inline void GetAllInvestAddressAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetAllInvestAddressAck::message() const {
  // @@protoc_insertion_point(field_get:GetAllInvestAddressAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllInvestAddressAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllInvestAddressAck.message)
}
inline std::string* GetAllInvestAddressAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetAllInvestAddressAck.message)
  return _s;
}
inline const std::string& GetAllInvestAddressAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetAllInvestAddressAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressAck::release_message() {
  // @@protoc_insertion_point(field_release:GetAllInvestAddressAck.message)
  return _impl_.message_.Release();
}
inline void GetAllInvestAddressAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllInvestAddressAck.message)
}

// string addr = 4;
inline void GetAllInvestAddressAck::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetAllInvestAddressAck::addr() const {
  // @@protoc_insertion_point(field_get:GetAllInvestAddressAck.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllInvestAddressAck::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllInvestAddressAck.addr)
}
inline std::string* GetAllInvestAddressAck::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:GetAllInvestAddressAck.addr)
  return _s;
}
inline const std::string& GetAllInvestAddressAck::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void GetAllInvestAddressAck::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressAck::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllInvestAddressAck::release_addr() {
  // @@protoc_insertion_point(field_release:GetAllInvestAddressAck.addr)
  return _impl_.addr_.Release();
}
inline void GetAllInvestAddressAck::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllInvestAddressAck.addr)
}

// repeated .InvestAddressItem list = 5;
inline int GetAllInvestAddressAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetAllInvestAddressAck::list_size() const {
  return _internal_list_size();
}
inline void GetAllInvestAddressAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::InvestAddressItem* GetAllInvestAddressAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetAllInvestAddressAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestAddressItem >*
GetAllInvestAddressAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetAllInvestAddressAck.list)
  return &_impl_.list_;
}
inline const ::InvestAddressItem& GetAllInvestAddressAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::InvestAddressItem& GetAllInvestAddressAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetAllInvestAddressAck.list)
  return _internal_list(index);
}
inline ::InvestAddressItem* GetAllInvestAddressAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::InvestAddressItem* GetAllInvestAddressAck::add_list() {
  ::InvestAddressItem* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetAllInvestAddressAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::InvestAddressItem >&
GetAllInvestAddressAck::list() const {
  // @@protoc_insertion_point(field_list:GetAllInvestAddressAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// GetAllStakeNodeListReq

// string version = 1;
inline void GetAllStakeNodeListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetAllStakeNodeListReq::version() const {
  // @@protoc_insertion_point(field_get:GetAllStakeNodeListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllStakeNodeListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllStakeNodeListReq.version)
}
inline std::string* GetAllStakeNodeListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetAllStakeNodeListReq.version)
  return _s;
}
inline const std::string& GetAllStakeNodeListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetAllStakeNodeListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllStakeNodeListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllStakeNodeListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetAllStakeNodeListReq.version)
  return _impl_.version_.Release();
}
inline void GetAllStakeNodeListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllStakeNodeListReq.version)
}

// -------------------------------------------------------------------

// StakeNode

// string addr = 1;
inline void StakeNode::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& StakeNode::addr() const {
  // @@protoc_insertion_point(field_get:StakeNode.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeNode::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeNode.addr)
}
inline std::string* StakeNode::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:StakeNode.addr)
  return _s;
}
inline const std::string& StakeNode::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void StakeNode::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeNode::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeNode::release_addr() {
  // @@protoc_insertion_point(field_release:StakeNode.addr)
  return _impl_.addr_.Release();
}
inline void StakeNode::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeNode.addr)
}

// string name = 2;
inline void StakeNode::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StakeNode::name() const {
  // @@protoc_insertion_point(field_get:StakeNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeNode::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeNode.name)
}
inline std::string* StakeNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:StakeNode.name)
  return _s;
}
inline const std::string& StakeNode::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StakeNode::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeNode::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeNode::release_name() {
  // @@protoc_insertion_point(field_release:StakeNode.name)
  return _impl_.name_.Release();
}
inline void StakeNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeNode.name)
}

// string ip = 3;
inline void StakeNode::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& StakeNode::ip() const {
  // @@protoc_insertion_point(field_get:StakeNode.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeNode::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeNode.ip)
}
inline std::string* StakeNode::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:StakeNode.ip)
  return _s;
}
inline const std::string& StakeNode::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void StakeNode::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeNode::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeNode::release_ip() {
  // @@protoc_insertion_point(field_release:StakeNode.ip)
  return _impl_.ip_.Release();
}
inline void StakeNode::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeNode.ip)
}

// bytes identity = 4;
inline void StakeNode::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& StakeNode::identity() const {
  // @@protoc_insertion_point(field_get:StakeNode.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeNode::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeNode.identity)
}
inline std::string* StakeNode::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:StakeNode.identity)
  return _s;
}
inline const std::string& StakeNode::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void StakeNode::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeNode::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeNode::release_identity() {
  // @@protoc_insertion_point(field_release:StakeNode.identity)
  return _impl_.identity_.Release();
}
inline void StakeNode::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeNode.identity)
}

// string logo = 5;
inline void StakeNode::clear_logo() {
  _impl_.logo_.ClearToEmpty();
}
inline const std::string& StakeNode::logo() const {
  // @@protoc_insertion_point(field_get:StakeNode.logo)
  return _internal_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeNode::set_logo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeNode.logo)
}
inline std::string* StakeNode::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:StakeNode.logo)
  return _s;
}
inline const std::string& StakeNode::_internal_logo() const {
  return _impl_.logo_.Get();
}
inline void StakeNode::_internal_set_logo(const std::string& value) {
  
  _impl_.logo_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeNode::_internal_mutable_logo() {
  
  return _impl_.logo_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeNode::release_logo() {
  // @@protoc_insertion_point(field_release:StakeNode.logo)
  return _impl_.logo_.Release();
}
inline void StakeNode::set_allocated_logo(std::string* logo) {
  if (logo != nullptr) {
    
  } else {
    
  }
  _impl_.logo_.SetAllocated(logo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logo_.IsDefault()) {
    _impl_.logo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeNode.logo)
}

// uint64 height = 6;
inline void StakeNode::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t StakeNode::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t StakeNode::height() const {
  // @@protoc_insertion_point(field_get:StakeNode.height)
  return _internal_height();
}
inline void StakeNode::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void StakeNode::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:StakeNode.height)
}

// string version = 7;
inline void StakeNode::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& StakeNode::version() const {
  // @@protoc_insertion_point(field_get:StakeNode.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StakeNode::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StakeNode.version)
}
inline std::string* StakeNode::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:StakeNode.version)
  return _s;
}
inline const std::string& StakeNode::_internal_version() const {
  return _impl_.version_.Get();
}
inline void StakeNode::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* StakeNode::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* StakeNode::release_version() {
  // @@protoc_insertion_point(field_release:StakeNode.version)
  return _impl_.version_.Release();
}
inline void StakeNode::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StakeNode.version)
}

// -------------------------------------------------------------------

// GetAllStakeNodeListAck

// string version = 1;
inline void GetAllStakeNodeListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetAllStakeNodeListAck::version() const {
  // @@protoc_insertion_point(field_get:GetAllStakeNodeListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllStakeNodeListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllStakeNodeListAck.version)
}
inline std::string* GetAllStakeNodeListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetAllStakeNodeListAck.version)
  return _s;
}
inline const std::string& GetAllStakeNodeListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetAllStakeNodeListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllStakeNodeListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllStakeNodeListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetAllStakeNodeListAck.version)
  return _impl_.version_.Release();
}
inline void GetAllStakeNodeListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllStakeNodeListAck.version)
}

// sint32 code = 2;
inline void GetAllStakeNodeListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetAllStakeNodeListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetAllStakeNodeListAck::code() const {
  // @@protoc_insertion_point(field_get:GetAllStakeNodeListAck.code)
  return _internal_code();
}
inline void GetAllStakeNodeListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetAllStakeNodeListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetAllStakeNodeListAck.code)
}

// string message = 3;
inline void GetAllStakeNodeListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetAllStakeNodeListAck::message() const {
  // @@protoc_insertion_point(field_get:GetAllStakeNodeListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAllStakeNodeListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetAllStakeNodeListAck.message)
}
inline std::string* GetAllStakeNodeListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetAllStakeNodeListAck.message)
  return _s;
}
inline const std::string& GetAllStakeNodeListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetAllStakeNodeListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAllStakeNodeListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetAllStakeNodeListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetAllStakeNodeListAck.message)
  return _impl_.message_.Release();
}
inline void GetAllStakeNodeListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetAllStakeNodeListAck.message)
}

// repeated .StakeNode list = 4;
inline int GetAllStakeNodeListAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetAllStakeNodeListAck::list_size() const {
  return _internal_list_size();
}
inline void GetAllStakeNodeListAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::StakeNode* GetAllStakeNodeListAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetAllStakeNodeListAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeNode >*
GetAllStakeNodeListAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetAllStakeNodeListAck.list)
  return &_impl_.list_;
}
inline const ::StakeNode& GetAllStakeNodeListAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::StakeNode& GetAllStakeNodeListAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetAllStakeNodeListAck.list)
  return _internal_list(index);
}
inline ::StakeNode* GetAllStakeNodeListAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::StakeNode* GetAllStakeNodeListAck::add_list() {
  ::StakeNode* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetAllStakeNodeListAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StakeNode >&
GetAllStakeNodeListAck::list() const {
  // @@protoc_insertion_point(field_list:GetAllStakeNodeListAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// GetSignCountListReq

// string version = 1;
inline void GetSignCountListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetSignCountListReq::version() const {
  // @@protoc_insertion_point(field_get:GetSignCountListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSignCountListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetSignCountListReq.version)
}
inline std::string* GetSignCountListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetSignCountListReq.version)
  return _s;
}
inline const std::string& GetSignCountListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetSignCountListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSignCountListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSignCountListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetSignCountListReq.version)
  return _impl_.version_.Release();
}
inline void GetSignCountListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetSignCountListReq.version)
}

// -------------------------------------------------------------------

// SignCount

// string addr = 1;
inline void SignCount::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& SignCount::addr() const {
  // @@protoc_insertion_point(field_get:SignCount.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignCount::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignCount.addr)
}
inline std::string* SignCount::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:SignCount.addr)
  return _s;
}
inline const std::string& SignCount::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void SignCount::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* SignCount::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* SignCount::release_addr() {
  // @@protoc_insertion_point(field_release:SignCount.addr)
  return _impl_.addr_.Release();
}
inline void SignCount::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignCount.addr)
}

// uint32 count = 2;
inline void SignCount::clear_count() {
  _impl_.count_ = 0u;
}
inline uint32_t SignCount::_internal_count() const {
  return _impl_.count_;
}
inline uint32_t SignCount::count() const {
  // @@protoc_insertion_point(field_get:SignCount.count)
  return _internal_count();
}
inline void SignCount::_internal_set_count(uint32_t value) {
  
  _impl_.count_ = value;
}
inline void SignCount::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:SignCount.count)
}

// -------------------------------------------------------------------

// GetSignCountListAck

// string version = 1;
inline void GetSignCountListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetSignCountListAck::version() const {
  // @@protoc_insertion_point(field_get:GetSignCountListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSignCountListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetSignCountListAck.version)
}
inline std::string* GetSignCountListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetSignCountListAck.version)
  return _s;
}
inline const std::string& GetSignCountListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetSignCountListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSignCountListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSignCountListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetSignCountListAck.version)
  return _impl_.version_.Release();
}
inline void GetSignCountListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetSignCountListAck.version)
}

// sint32 code = 2;
inline void GetSignCountListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetSignCountListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetSignCountListAck::code() const {
  // @@protoc_insertion_point(field_get:GetSignCountListAck.code)
  return _internal_code();
}
inline void GetSignCountListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetSignCountListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetSignCountListAck.code)
}

// string message = 3;
inline void GetSignCountListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetSignCountListAck::message() const {
  // @@protoc_insertion_point(field_get:GetSignCountListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSignCountListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetSignCountListAck.message)
}
inline std::string* GetSignCountListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetSignCountListAck.message)
  return _s;
}
inline const std::string& GetSignCountListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetSignCountListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSignCountListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSignCountListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetSignCountListAck.message)
  return _impl_.message_.Release();
}
inline void GetSignCountListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetSignCountListAck.message)
}

// repeated .SignCount list = 4;
inline int GetSignCountListAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetSignCountListAck::list_size() const {
  return _internal_list_size();
}
inline void GetSignCountListAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::SignCount* GetSignCountListAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetSignCountListAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignCount >*
GetSignCountListAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetSignCountListAck.list)
  return &_impl_.list_;
}
inline const ::SignCount& GetSignCountListAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::SignCount& GetSignCountListAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetSignCountListAck.list)
  return _internal_list(index);
}
inline ::SignCount* GetSignCountListAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::SignCount* GetSignCountListAck::add_list() {
  ::SignCount* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetSignCountListAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignCount >&
GetSignCountListAck::list() const {
  // @@protoc_insertion_point(field_list:GetSignCountListAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// GetHeightReq

// string version = 1;
inline void GetHeightReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetHeightReq::version() const {
  // @@protoc_insertion_point(field_get:GetHeightReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetHeightReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetHeightReq.version)
}
inline std::string* GetHeightReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetHeightReq.version)
  return _s;
}
inline const std::string& GetHeightReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetHeightReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetHeightReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetHeightReq::release_version() {
  // @@protoc_insertion_point(field_release:GetHeightReq.version)
  return _impl_.version_.Release();
}
inline void GetHeightReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetHeightReq.version)
}

// -------------------------------------------------------------------

// GetHeightAck

// string version = 1;
inline void GetHeightAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetHeightAck::version() const {
  // @@protoc_insertion_point(field_get:GetHeightAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetHeightAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetHeightAck.version)
}
inline std::string* GetHeightAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetHeightAck.version)
  return _s;
}
inline const std::string& GetHeightAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetHeightAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetHeightAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetHeightAck::release_version() {
  // @@protoc_insertion_point(field_release:GetHeightAck.version)
  return _impl_.version_.Release();
}
inline void GetHeightAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetHeightAck.version)
}

// int32 code = 2;
inline void GetHeightAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetHeightAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetHeightAck::code() const {
  // @@protoc_insertion_point(field_get:GetHeightAck.code)
  return _internal_code();
}
inline void GetHeightAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetHeightAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetHeightAck.code)
}

// string message = 3;
inline void GetHeightAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetHeightAck::message() const {
  // @@protoc_insertion_point(field_get:GetHeightAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetHeightAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetHeightAck.message)
}
inline std::string* GetHeightAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetHeightAck.message)
  return _s;
}
inline const std::string& GetHeightAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetHeightAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetHeightAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetHeightAck::release_message() {
  // @@protoc_insertion_point(field_release:GetHeightAck.message)
  return _impl_.message_.Release();
}
inline void GetHeightAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetHeightAck.message)
}

// uint64 height = 4;
inline void GetHeightAck::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t GetHeightAck::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t GetHeightAck::height() const {
  // @@protoc_insertion_point(field_get:GetHeightAck.height)
  return _internal_height();
}
inline void GetHeightAck::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void GetHeightAck::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:GetHeightAck.height)
}

// -------------------------------------------------------------------

// GetBonusListReq

// string version = 1;
inline void GetBonusListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetBonusListReq::version() const {
  // @@protoc_insertion_point(field_get:GetBonusListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBonusListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBonusListReq.version)
}
inline std::string* GetBonusListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetBonusListReq.version)
  return _s;
}
inline const std::string& GetBonusListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetBonusListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBonusListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBonusListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetBonusListReq.version)
  return _impl_.version_.Release();
}
inline void GetBonusListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBonusListReq.version)
}

// string bonusAddr = 2;
inline void GetBonusListReq::clear_bonusaddr() {
  _impl_.bonusaddr_.ClearToEmpty();
}
inline const std::string& GetBonusListReq::bonusaddr() const {
  // @@protoc_insertion_point(field_get:GetBonusListReq.bonusAddr)
  return _internal_bonusaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBonusListReq::set_bonusaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bonusaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBonusListReq.bonusAddr)
}
inline std::string* GetBonusListReq::mutable_bonusaddr() {
  std::string* _s = _internal_mutable_bonusaddr();
  // @@protoc_insertion_point(field_mutable:GetBonusListReq.bonusAddr)
  return _s;
}
inline const std::string& GetBonusListReq::_internal_bonusaddr() const {
  return _impl_.bonusaddr_.Get();
}
inline void GetBonusListReq::_internal_set_bonusaddr(const std::string& value) {
  
  _impl_.bonusaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBonusListReq::_internal_mutable_bonusaddr() {
  
  return _impl_.bonusaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBonusListReq::release_bonusaddr() {
  // @@protoc_insertion_point(field_release:GetBonusListReq.bonusAddr)
  return _impl_.bonusaddr_.Release();
}
inline void GetBonusListReq::set_allocated_bonusaddr(std::string* bonusaddr) {
  if (bonusaddr != nullptr) {
    
  } else {
    
  }
  _impl_.bonusaddr_.SetAllocated(bonusaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bonusaddr_.IsDefault()) {
    _impl_.bonusaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBonusListReq.bonusAddr)
}

// -------------------------------------------------------------------

// BonusItem

// string addr = 1;
inline void BonusItem::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& BonusItem::addr() const {
  // @@protoc_insertion_point(field_get:BonusItem.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BonusItem::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BonusItem.addr)
}
inline std::string* BonusItem::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:BonusItem.addr)
  return _s;
}
inline const std::string& BonusItem::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void BonusItem::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* BonusItem::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* BonusItem::release_addr() {
  // @@protoc_insertion_point(field_release:BonusItem.addr)
  return _impl_.addr_.Release();
}
inline void BonusItem::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BonusItem.addr)
}

// uint64 value = 2;
inline void BonusItem::clear_value() {
  _impl_.value_ = uint64_t{0u};
}
inline uint64_t BonusItem::_internal_value() const {
  return _impl_.value_;
}
inline uint64_t BonusItem::value() const {
  // @@protoc_insertion_point(field_get:BonusItem.value)
  return _internal_value();
}
inline void BonusItem::_internal_set_value(uint64_t value) {
  
  _impl_.value_ = value;
}
inline void BonusItem::set_value(uint64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:BonusItem.value)
}

// -------------------------------------------------------------------

// GetBonusListAck

// string version = 1;
inline void GetBonusListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetBonusListAck::version() const {
  // @@protoc_insertion_point(field_get:GetBonusListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBonusListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBonusListAck.version)
}
inline std::string* GetBonusListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetBonusListAck.version)
  return _s;
}
inline const std::string& GetBonusListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetBonusListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBonusListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBonusListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetBonusListAck.version)
  return _impl_.version_.Release();
}
inline void GetBonusListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBonusListAck.version)
}

// int32 code = 2;
inline void GetBonusListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetBonusListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetBonusListAck::code() const {
  // @@protoc_insertion_point(field_get:GetBonusListAck.code)
  return _internal_code();
}
inline void GetBonusListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetBonusListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetBonusListAck.code)
}

// string message = 3;
inline void GetBonusListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetBonusListAck::message() const {
  // @@protoc_insertion_point(field_get:GetBonusListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBonusListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBonusListAck.message)
}
inline std::string* GetBonusListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetBonusListAck.message)
  return _s;
}
inline const std::string& GetBonusListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetBonusListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBonusListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBonusListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetBonusListAck.message)
  return _impl_.message_.Release();
}
inline void GetBonusListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBonusListAck.message)
}

// string bonusAddr = 4;
inline void GetBonusListAck::clear_bonusaddr() {
  _impl_.bonusaddr_.ClearToEmpty();
}
inline const std::string& GetBonusListAck::bonusaddr() const {
  // @@protoc_insertion_point(field_get:GetBonusListAck.bonusAddr)
  return _internal_bonusaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBonusListAck::set_bonusaddr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bonusaddr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBonusListAck.bonusAddr)
}
inline std::string* GetBonusListAck::mutable_bonusaddr() {
  std::string* _s = _internal_mutable_bonusaddr();
  // @@protoc_insertion_point(field_mutable:GetBonusListAck.bonusAddr)
  return _s;
}
inline const std::string& GetBonusListAck::_internal_bonusaddr() const {
  return _impl_.bonusaddr_.Get();
}
inline void GetBonusListAck::_internal_set_bonusaddr(const std::string& value) {
  
  _impl_.bonusaddr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetBonusListAck::_internal_mutable_bonusaddr() {
  
  return _impl_.bonusaddr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetBonusListAck::release_bonusaddr() {
  // @@protoc_insertion_point(field_release:GetBonusListAck.bonusAddr)
  return _impl_.bonusaddr_.Release();
}
inline void GetBonusListAck::set_allocated_bonusaddr(std::string* bonusaddr) {
  if (bonusaddr != nullptr) {
    
  } else {
    
  }
  _impl_.bonusaddr_.SetAllocated(bonusaddr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bonusaddr_.IsDefault()) {
    _impl_.bonusaddr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBonusListAck.bonusAddr)
}

// repeated .BonusItem list = 5;
inline int GetBonusListAck::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int GetBonusListAck::list_size() const {
  return _internal_list_size();
}
inline void GetBonusListAck::clear_list() {
  _impl_.list_.Clear();
}
inline ::BonusItem* GetBonusListAck::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GetBonusListAck.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BonusItem >*
GetBonusListAck::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GetBonusListAck.list)
  return &_impl_.list_;
}
inline const ::BonusItem& GetBonusListAck::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::BonusItem& GetBonusListAck::list(int index) const {
  // @@protoc_insertion_point(field_get:GetBonusListAck.list)
  return _internal_list(index);
}
inline ::BonusItem* GetBonusListAck::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::BonusItem* GetBonusListAck::add_list() {
  ::BonusItem* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GetBonusListAck.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BonusItem >&
GetBonusListAck::list() const {
  // @@protoc_insertion_point(field_list:GetBonusListAck.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// MultiSignTxReq

// string version = 1;
inline void MultiSignTxReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& MultiSignTxReq::version() const {
  // @@protoc_insertion_point(field_get:MultiSignTxReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiSignTxReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiSignTxReq.version)
}
inline std::string* MultiSignTxReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:MultiSignTxReq.version)
  return _s;
}
inline const std::string& MultiSignTxReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void MultiSignTxReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MultiSignTxReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* MultiSignTxReq::release_version() {
  // @@protoc_insertion_point(field_release:MultiSignTxReq.version)
  return _impl_.version_.Release();
}
inline void MultiSignTxReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiSignTxReq.version)
}

// uint64 height = 2;
inline void MultiSignTxReq::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t MultiSignTxReq::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t MultiSignTxReq::height() const {
  // @@protoc_insertion_point(field_get:MultiSignTxReq.height)
  return _internal_height();
}
inline void MultiSignTxReq::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void MultiSignTxReq::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:MultiSignTxReq.height)
}

// bytes txRaw = 3;
inline void MultiSignTxReq::clear_txraw() {
  _impl_.txraw_.ClearToEmpty();
}
inline const std::string& MultiSignTxReq::txraw() const {
  // @@protoc_insertion_point(field_get:MultiSignTxReq.txRaw)
  return _internal_txraw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiSignTxReq::set_txraw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txraw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiSignTxReq.txRaw)
}
inline std::string* MultiSignTxReq::mutable_txraw() {
  std::string* _s = _internal_mutable_txraw();
  // @@protoc_insertion_point(field_mutable:MultiSignTxReq.txRaw)
  return _s;
}
inline const std::string& MultiSignTxReq::_internal_txraw() const {
  return _impl_.txraw_.Get();
}
inline void MultiSignTxReq::_internal_set_txraw(const std::string& value) {
  
  _impl_.txraw_.Set(value, GetArenaForAllocation());
}
inline std::string* MultiSignTxReq::_internal_mutable_txraw() {
  
  return _impl_.txraw_.Mutable(GetArenaForAllocation());
}
inline std::string* MultiSignTxReq::release_txraw() {
  // @@protoc_insertion_point(field_release:MultiSignTxReq.txRaw)
  return _impl_.txraw_.Release();
}
inline void MultiSignTxReq::set_allocated_txraw(std::string* txraw) {
  if (txraw != nullptr) {
    
  } else {
    
  }
  _impl_.txraw_.SetAllocated(txraw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txraw_.IsDefault()) {
    _impl_.txraw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiSignTxReq.txRaw)
}

// -------------------------------------------------------------------

// MultiSignTxAck

// string version = 1;
inline void MultiSignTxAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& MultiSignTxAck::version() const {
  // @@protoc_insertion_point(field_get:MultiSignTxAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiSignTxAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiSignTxAck.version)
}
inline std::string* MultiSignTxAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:MultiSignTxAck.version)
  return _s;
}
inline const std::string& MultiSignTxAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void MultiSignTxAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* MultiSignTxAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* MultiSignTxAck::release_version() {
  // @@protoc_insertion_point(field_release:MultiSignTxAck.version)
  return _impl_.version_.Release();
}
inline void MultiSignTxAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiSignTxAck.version)
}

// int32 code = 2;
inline void MultiSignTxAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t MultiSignTxAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t MultiSignTxAck::code() const {
  // @@protoc_insertion_point(field_get:MultiSignTxAck.code)
  return _internal_code();
}
inline void MultiSignTxAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void MultiSignTxAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:MultiSignTxAck.code)
}

// string message = 3;
inline void MultiSignTxAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MultiSignTxAck::message() const {
  // @@protoc_insertion_point(field_get:MultiSignTxAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiSignTxAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiSignTxAck.message)
}
inline std::string* MultiSignTxAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:MultiSignTxAck.message)
  return _s;
}
inline const std::string& MultiSignTxAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MultiSignTxAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MultiSignTxAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MultiSignTxAck::release_message() {
  // @@protoc_insertion_point(field_release:MultiSignTxAck.message)
  return _impl_.message_.Release();
}
inline void MultiSignTxAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiSignTxAck.message)
}

// bytes txRaw = 4;
inline void MultiSignTxAck::clear_txraw() {
  _impl_.txraw_.ClearToEmpty();
}
inline const std::string& MultiSignTxAck::txraw() const {
  // @@protoc_insertion_point(field_get:MultiSignTxAck.txRaw)
  return _internal_txraw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiSignTxAck::set_txraw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txraw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MultiSignTxAck.txRaw)
}
inline std::string* MultiSignTxAck::mutable_txraw() {
  std::string* _s = _internal_mutable_txraw();
  // @@protoc_insertion_point(field_mutable:MultiSignTxAck.txRaw)
  return _s;
}
inline const std::string& MultiSignTxAck::_internal_txraw() const {
  return _impl_.txraw_.Get();
}
inline void MultiSignTxAck::_internal_set_txraw(const std::string& value) {
  
  _impl_.txraw_.Set(value, GetArenaForAllocation());
}
inline std::string* MultiSignTxAck::_internal_mutable_txraw() {
  
  return _impl_.txraw_.Mutable(GetArenaForAllocation());
}
inline std::string* MultiSignTxAck::release_txraw() {
  // @@protoc_insertion_point(field_release:MultiSignTxAck.txRaw)
  return _impl_.txraw_.Release();
}
inline void MultiSignTxAck::set_allocated_txraw(std::string* txraw) {
  if (txraw != nullptr) {
    
  } else {
    
  }
  _impl_.txraw_.SetAllocated(txraw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txraw_.IsDefault()) {
    _impl_.txraw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MultiSignTxAck.txRaw)
}

// -------------------------------------------------------------------

// GetTransactionStatusListReq

// string version = 1;
inline void GetTransactionStatusListReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetTransactionStatusListReq::version() const {
  // @@protoc_insertion_point(field_get:GetTransactionStatusListReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionStatusListReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTransactionStatusListReq.version)
}
inline std::string* GetTransactionStatusListReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetTransactionStatusListReq.version)
  return _s;
}
inline const std::string& GetTransactionStatusListReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetTransactionStatusListReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListReq::release_version() {
  // @@protoc_insertion_point(field_release:GetTransactionStatusListReq.version)
  return _impl_.version_.Release();
}
inline void GetTransactionStatusListReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTransactionStatusListReq.version)
}

// string txhash = 2;
inline void GetTransactionStatusListReq::clear_txhash() {
  _impl_.txhash_.ClearToEmpty();
}
inline const std::string& GetTransactionStatusListReq::txhash() const {
  // @@protoc_insertion_point(field_get:GetTransactionStatusListReq.txhash)
  return _internal_txhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionStatusListReq::set_txhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTransactionStatusListReq.txhash)
}
inline std::string* GetTransactionStatusListReq::mutable_txhash() {
  std::string* _s = _internal_mutable_txhash();
  // @@protoc_insertion_point(field_mutable:GetTransactionStatusListReq.txhash)
  return _s;
}
inline const std::string& GetTransactionStatusListReq::_internal_txhash() const {
  return _impl_.txhash_.Get();
}
inline void GetTransactionStatusListReq::_internal_set_txhash(const std::string& value) {
  
  _impl_.txhash_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListReq::_internal_mutable_txhash() {
  
  return _impl_.txhash_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListReq::release_txhash() {
  // @@protoc_insertion_point(field_release:GetTransactionStatusListReq.txhash)
  return _impl_.txhash_.Release();
}
inline void GetTransactionStatusListReq::set_allocated_txhash(std::string* txhash) {
  if (txhash != nullptr) {
    
  } else {
    
  }
  _impl_.txhash_.SetAllocated(txhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txhash_.IsDefault()) {
    _impl_.txhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTransactionStatusListReq.txhash)
}

// -------------------------------------------------------------------

// OtherStatusItem

// string othernodetime = 1;
inline void OtherStatusItem::clear_othernodetime() {
  _impl_.othernodetime_.ClearToEmpty();
}
inline const std::string& OtherStatusItem::othernodetime() const {
  // @@protoc_insertion_point(field_get:OtherStatusItem.othernodetime)
  return _internal_othernodetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OtherStatusItem::set_othernodetime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.othernodetime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OtherStatusItem.othernodetime)
}
inline std::string* OtherStatusItem::mutable_othernodetime() {
  std::string* _s = _internal_mutable_othernodetime();
  // @@protoc_insertion_point(field_mutable:OtherStatusItem.othernodetime)
  return _s;
}
inline const std::string& OtherStatusItem::_internal_othernodetime() const {
  return _impl_.othernodetime_.Get();
}
inline void OtherStatusItem::_internal_set_othernodetime(const std::string& value) {
  
  _impl_.othernodetime_.Set(value, GetArenaForAllocation());
}
inline std::string* OtherStatusItem::_internal_mutable_othernodetime() {
  
  return _impl_.othernodetime_.Mutable(GetArenaForAllocation());
}
inline std::string* OtherStatusItem::release_othernodetime() {
  // @@protoc_insertion_point(field_release:OtherStatusItem.othernodetime)
  return _impl_.othernodetime_.Release();
}
inline void OtherStatusItem::set_allocated_othernodetime(std::string* othernodetime) {
  if (othernodetime != nullptr) {
    
  } else {
    
  }
  _impl_.othernodetime_.SetAllocated(othernodetime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.othernodetime_.IsDefault()) {
    _impl_.othernodetime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OtherStatusItem.othernodetime)
}

// int32 othernodecode = 2;
inline void OtherStatusItem::clear_othernodecode() {
  _impl_.othernodecode_ = 0;
}
inline int32_t OtherStatusItem::_internal_othernodecode() const {
  return _impl_.othernodecode_;
}
inline int32_t OtherStatusItem::othernodecode() const {
  // @@protoc_insertion_point(field_get:OtherStatusItem.othernodecode)
  return _internal_othernodecode();
}
inline void OtherStatusItem::_internal_set_othernodecode(int32_t value) {
  
  _impl_.othernodecode_ = value;
}
inline void OtherStatusItem::set_othernodecode(int32_t value) {
  _internal_set_othernodecode(value);
  // @@protoc_insertion_point(field_set:OtherStatusItem.othernodecode)
}

// string othernodemessage = 3;
inline void OtherStatusItem::clear_othernodemessage() {
  _impl_.othernodemessage_.ClearToEmpty();
}
inline const std::string& OtherStatusItem::othernodemessage() const {
  // @@protoc_insertion_point(field_get:OtherStatusItem.othernodemessage)
  return _internal_othernodemessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OtherStatusItem::set_othernodemessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.othernodemessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OtherStatusItem.othernodemessage)
}
inline std::string* OtherStatusItem::mutable_othernodemessage() {
  std::string* _s = _internal_mutable_othernodemessage();
  // @@protoc_insertion_point(field_mutable:OtherStatusItem.othernodemessage)
  return _s;
}
inline const std::string& OtherStatusItem::_internal_othernodemessage() const {
  return _impl_.othernodemessage_.Get();
}
inline void OtherStatusItem::_internal_set_othernodemessage(const std::string& value) {
  
  _impl_.othernodemessage_.Set(value, GetArenaForAllocation());
}
inline std::string* OtherStatusItem::_internal_mutable_othernodemessage() {
  
  return _impl_.othernodemessage_.Mutable(GetArenaForAllocation());
}
inline std::string* OtherStatusItem::release_othernodemessage() {
  // @@protoc_insertion_point(field_release:OtherStatusItem.othernodemessage)
  return _impl_.othernodemessage_.Release();
}
inline void OtherStatusItem::set_allocated_othernodemessage(std::string* othernodemessage) {
  if (othernodemessage != nullptr) {
    
  } else {
    
  }
  _impl_.othernodemessage_.SetAllocated(othernodemessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.othernodemessage_.IsDefault()) {
    _impl_.othernodemessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:OtherStatusItem.othernodemessage)
}

// -------------------------------------------------------------------

// SelfVerifyStatusItem

// string verifyothernodetime = 1;
inline void SelfVerifyStatusItem::clear_verifyothernodetime() {
  _impl_.verifyothernodetime_.ClearToEmpty();
}
inline const std::string& SelfVerifyStatusItem::verifyothernodetime() const {
  // @@protoc_insertion_point(field_get:SelfVerifyStatusItem.verifyothernodetime)
  return _internal_verifyothernodetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelfVerifyStatusItem::set_verifyothernodetime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verifyothernodetime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SelfVerifyStatusItem.verifyothernodetime)
}
inline std::string* SelfVerifyStatusItem::mutable_verifyothernodetime() {
  std::string* _s = _internal_mutable_verifyothernodetime();
  // @@protoc_insertion_point(field_mutable:SelfVerifyStatusItem.verifyothernodetime)
  return _s;
}
inline const std::string& SelfVerifyStatusItem::_internal_verifyothernodetime() const {
  return _impl_.verifyothernodetime_.Get();
}
inline void SelfVerifyStatusItem::_internal_set_verifyothernodetime(const std::string& value) {
  
  _impl_.verifyothernodetime_.Set(value, GetArenaForAllocation());
}
inline std::string* SelfVerifyStatusItem::_internal_mutable_verifyothernodetime() {
  
  return _impl_.verifyothernodetime_.Mutable(GetArenaForAllocation());
}
inline std::string* SelfVerifyStatusItem::release_verifyothernodetime() {
  // @@protoc_insertion_point(field_release:SelfVerifyStatusItem.verifyothernodetime)
  return _impl_.verifyothernodetime_.Release();
}
inline void SelfVerifyStatusItem::set_allocated_verifyothernodetime(std::string* verifyothernodetime) {
  if (verifyothernodetime != nullptr) {
    
  } else {
    
  }
  _impl_.verifyothernodetime_.SetAllocated(verifyothernodetime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifyothernodetime_.IsDefault()) {
    _impl_.verifyothernodetime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SelfVerifyStatusItem.verifyothernodetime)
}

// int32 verifyothernodecode = 2;
inline void SelfVerifyStatusItem::clear_verifyothernodecode() {
  _impl_.verifyothernodecode_ = 0;
}
inline int32_t SelfVerifyStatusItem::_internal_verifyothernodecode() const {
  return _impl_.verifyothernodecode_;
}
inline int32_t SelfVerifyStatusItem::verifyothernodecode() const {
  // @@protoc_insertion_point(field_get:SelfVerifyStatusItem.verifyothernodecode)
  return _internal_verifyothernodecode();
}
inline void SelfVerifyStatusItem::_internal_set_verifyothernodecode(int32_t value) {
  
  _impl_.verifyothernodecode_ = value;
}
inline void SelfVerifyStatusItem::set_verifyothernodecode(int32_t value) {
  _internal_set_verifyothernodecode(value);
  // @@protoc_insertion_point(field_set:SelfVerifyStatusItem.verifyothernodecode)
}

// string verifyothernodemessage = 3;
inline void SelfVerifyStatusItem::clear_verifyothernodemessage() {
  _impl_.verifyothernodemessage_.ClearToEmpty();
}
inline const std::string& SelfVerifyStatusItem::verifyothernodemessage() const {
  // @@protoc_insertion_point(field_get:SelfVerifyStatusItem.verifyothernodemessage)
  return _internal_verifyothernodemessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelfVerifyStatusItem::set_verifyothernodemessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.verifyothernodemessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SelfVerifyStatusItem.verifyothernodemessage)
}
inline std::string* SelfVerifyStatusItem::mutable_verifyothernodemessage() {
  std::string* _s = _internal_mutable_verifyothernodemessage();
  // @@protoc_insertion_point(field_mutable:SelfVerifyStatusItem.verifyothernodemessage)
  return _s;
}
inline const std::string& SelfVerifyStatusItem::_internal_verifyothernodemessage() const {
  return _impl_.verifyothernodemessage_.Get();
}
inline void SelfVerifyStatusItem::_internal_set_verifyothernodemessage(const std::string& value) {
  
  _impl_.verifyothernodemessage_.Set(value, GetArenaForAllocation());
}
inline std::string* SelfVerifyStatusItem::_internal_mutable_verifyothernodemessage() {
  
  return _impl_.verifyothernodemessage_.Mutable(GetArenaForAllocation());
}
inline std::string* SelfVerifyStatusItem::release_verifyothernodemessage() {
  // @@protoc_insertion_point(field_release:SelfVerifyStatusItem.verifyothernodemessage)
  return _impl_.verifyothernodemessage_.Release();
}
inline void SelfVerifyStatusItem::set_allocated_verifyothernodemessage(std::string* verifyothernodemessage) {
  if (verifyothernodemessage != nullptr) {
    
  } else {
    
  }
  _impl_.verifyothernodemessage_.SetAllocated(verifyothernodemessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.verifyothernodemessage_.IsDefault()) {
    _impl_.verifyothernodemessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SelfVerifyStatusItem.verifyothernodemessage)
}

// -------------------------------------------------------------------

// TransactionStatusItem

// string initiatortime = 1;
inline void TransactionStatusItem::clear_initiatortime() {
  _impl_.initiatortime_.ClearToEmpty();
}
inline const std::string& TransactionStatusItem::initiatortime() const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.initiatortime)
  return _internal_initiatortime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStatusItem::set_initiatortime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.initiatortime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransactionStatusItem.initiatortime)
}
inline std::string* TransactionStatusItem::mutable_initiatortime() {
  std::string* _s = _internal_mutable_initiatortime();
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.initiatortime)
  return _s;
}
inline const std::string& TransactionStatusItem::_internal_initiatortime() const {
  return _impl_.initiatortime_.Get();
}
inline void TransactionStatusItem::_internal_set_initiatortime(const std::string& value) {
  
  _impl_.initiatortime_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::_internal_mutable_initiatortime() {
  
  return _impl_.initiatortime_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::release_initiatortime() {
  // @@protoc_insertion_point(field_release:TransactionStatusItem.initiatortime)
  return _impl_.initiatortime_.Release();
}
inline void TransactionStatusItem::set_allocated_initiatortime(std::string* initiatortime) {
  if (initiatortime != nullptr) {
    
  } else {
    
  }
  _impl_.initiatortime_.SetAllocated(initiatortime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initiatortime_.IsDefault()) {
    _impl_.initiatortime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TransactionStatusItem.initiatortime)
}

// int32 selfcode = 2;
inline void TransactionStatusItem::clear_selfcode() {
  _impl_.selfcode_ = 0;
}
inline int32_t TransactionStatusItem::_internal_selfcode() const {
  return _impl_.selfcode_;
}
inline int32_t TransactionStatusItem::selfcode() const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.selfcode)
  return _internal_selfcode();
}
inline void TransactionStatusItem::_internal_set_selfcode(int32_t value) {
  
  _impl_.selfcode_ = value;
}
inline void TransactionStatusItem::set_selfcode(int32_t value) {
  _internal_set_selfcode(value);
  // @@protoc_insertion_point(field_set:TransactionStatusItem.selfcode)
}

// string initiatormessage = 3;
inline void TransactionStatusItem::clear_initiatormessage() {
  _impl_.initiatormessage_.ClearToEmpty();
}
inline const std::string& TransactionStatusItem::initiatormessage() const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.initiatormessage)
  return _internal_initiatormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStatusItem::set_initiatormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.initiatormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransactionStatusItem.initiatormessage)
}
inline std::string* TransactionStatusItem::mutable_initiatormessage() {
  std::string* _s = _internal_mutable_initiatormessage();
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.initiatormessage)
  return _s;
}
inline const std::string& TransactionStatusItem::_internal_initiatormessage() const {
  return _impl_.initiatormessage_.Get();
}
inline void TransactionStatusItem::_internal_set_initiatormessage(const std::string& value) {
  
  _impl_.initiatormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::_internal_mutable_initiatormessage() {
  
  return _impl_.initiatormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::release_initiatormessage() {
  // @@protoc_insertion_point(field_release:TransactionStatusItem.initiatormessage)
  return _impl_.initiatormessage_.Release();
}
inline void TransactionStatusItem::set_allocated_initiatormessage(std::string* initiatormessage) {
  if (initiatormessage != nullptr) {
    
  } else {
    
  }
  _impl_.initiatormessage_.SetAllocated(initiatormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.initiatormessage_.IsDefault()) {
    _impl_.initiatormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TransactionStatusItem.initiatormessage)
}

// repeated .OtherStatusItem Othernode = 4;
inline int TransactionStatusItem::_internal_othernode_size() const {
  return _impl_.othernode_.size();
}
inline int TransactionStatusItem::othernode_size() const {
  return _internal_othernode_size();
}
inline void TransactionStatusItem::clear_othernode() {
  _impl_.othernode_.Clear();
}
inline ::OtherStatusItem* TransactionStatusItem::mutable_othernode(int index) {
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.Othernode)
  return _impl_.othernode_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OtherStatusItem >*
TransactionStatusItem::mutable_othernode() {
  // @@protoc_insertion_point(field_mutable_list:TransactionStatusItem.Othernode)
  return &_impl_.othernode_;
}
inline const ::OtherStatusItem& TransactionStatusItem::_internal_othernode(int index) const {
  return _impl_.othernode_.Get(index);
}
inline const ::OtherStatusItem& TransactionStatusItem::othernode(int index) const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.Othernode)
  return _internal_othernode(index);
}
inline ::OtherStatusItem* TransactionStatusItem::_internal_add_othernode() {
  return _impl_.othernode_.Add();
}
inline ::OtherStatusItem* TransactionStatusItem::add_othernode() {
  ::OtherStatusItem* _add = _internal_add_othernode();
  // @@protoc_insertion_point(field_add:TransactionStatusItem.Othernode)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OtherStatusItem >&
TransactionStatusItem::othernode() const {
  // @@protoc_insertion_point(field_list:TransactionStatusItem.Othernode)
  return _impl_.othernode_;
}

// repeated .SelfVerifyStatusItem verifyothernode = 5;
inline int TransactionStatusItem::_internal_verifyothernode_size() const {
  return _impl_.verifyothernode_.size();
}
inline int TransactionStatusItem::verifyothernode_size() const {
  return _internal_verifyothernode_size();
}
inline void TransactionStatusItem::clear_verifyothernode() {
  _impl_.verifyothernode_.Clear();
}
inline ::SelfVerifyStatusItem* TransactionStatusItem::mutable_verifyothernode(int index) {
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.verifyothernode)
  return _impl_.verifyothernode_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SelfVerifyStatusItem >*
TransactionStatusItem::mutable_verifyothernode() {
  // @@protoc_insertion_point(field_mutable_list:TransactionStatusItem.verifyothernode)
  return &_impl_.verifyothernode_;
}
inline const ::SelfVerifyStatusItem& TransactionStatusItem::_internal_verifyothernode(int index) const {
  return _impl_.verifyothernode_.Get(index);
}
inline const ::SelfVerifyStatusItem& TransactionStatusItem::verifyothernode(int index) const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.verifyothernode)
  return _internal_verifyothernode(index);
}
inline ::SelfVerifyStatusItem* TransactionStatusItem::_internal_add_verifyothernode() {
  return _impl_.verifyothernode_.Add();
}
inline ::SelfVerifyStatusItem* TransactionStatusItem::add_verifyothernode() {
  ::SelfVerifyStatusItem* _add = _internal_add_verifyothernode();
  // @@protoc_insertion_point(field_add:TransactionStatusItem.verifyothernode)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SelfVerifyStatusItem >&
TransactionStatusItem::verifyothernode() const {
  // @@protoc_insertion_point(field_list:TransactionStatusItem.verifyothernode)
  return _impl_.verifyothernode_;
}

// string composetime = 6;
inline void TransactionStatusItem::clear_composetime() {
  _impl_.composetime_.ClearToEmpty();
}
inline const std::string& TransactionStatusItem::composetime() const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.composetime)
  return _internal_composetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStatusItem::set_composetime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.composetime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransactionStatusItem.composetime)
}
inline std::string* TransactionStatusItem::mutable_composetime() {
  std::string* _s = _internal_mutable_composetime();
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.composetime)
  return _s;
}
inline const std::string& TransactionStatusItem::_internal_composetime() const {
  return _impl_.composetime_.Get();
}
inline void TransactionStatusItem::_internal_set_composetime(const std::string& value) {
  
  _impl_.composetime_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::_internal_mutable_composetime() {
  
  return _impl_.composetime_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::release_composetime() {
  // @@protoc_insertion_point(field_release:TransactionStatusItem.composetime)
  return _impl_.composetime_.Release();
}
inline void TransactionStatusItem::set_allocated_composetime(std::string* composetime) {
  if (composetime != nullptr) {
    
  } else {
    
  }
  _impl_.composetime_.SetAllocated(composetime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.composetime_.IsDefault()) {
    _impl_.composetime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TransactionStatusItem.composetime)
}

// string selfaddblocktime = 7;
inline void TransactionStatusItem::clear_selfaddblocktime() {
  _impl_.selfaddblocktime_.ClearToEmpty();
}
inline const std::string& TransactionStatusItem::selfaddblocktime() const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.selfaddblocktime)
  return _internal_selfaddblocktime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStatusItem::set_selfaddblocktime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.selfaddblocktime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransactionStatusItem.selfaddblocktime)
}
inline std::string* TransactionStatusItem::mutable_selfaddblocktime() {
  std::string* _s = _internal_mutable_selfaddblocktime();
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.selfaddblocktime)
  return _s;
}
inline const std::string& TransactionStatusItem::_internal_selfaddblocktime() const {
  return _impl_.selfaddblocktime_.Get();
}
inline void TransactionStatusItem::_internal_set_selfaddblocktime(const std::string& value) {
  
  _impl_.selfaddblocktime_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::_internal_mutable_selfaddblocktime() {
  
  return _impl_.selfaddblocktime_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::release_selfaddblocktime() {
  // @@protoc_insertion_point(field_release:TransactionStatusItem.selfaddblocktime)
  return _impl_.selfaddblocktime_.Release();
}
inline void TransactionStatusItem::set_allocated_selfaddblocktime(std::string* selfaddblocktime) {
  if (selfaddblocktime != nullptr) {
    
  } else {
    
  }
  _impl_.selfaddblocktime_.SetAllocated(selfaddblocktime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selfaddblocktime_.IsDefault()) {
    _impl_.selfaddblocktime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TransactionStatusItem.selfaddblocktime)
}

// string selfeaddblockmessage = 8;
inline void TransactionStatusItem::clear_selfeaddblockmessage() {
  _impl_.selfeaddblockmessage_.ClearToEmpty();
}
inline const std::string& TransactionStatusItem::selfeaddblockmessage() const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.selfeaddblockmessage)
  return _internal_selfeaddblockmessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStatusItem::set_selfeaddblockmessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.selfeaddblockmessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransactionStatusItem.selfeaddblockmessage)
}
inline std::string* TransactionStatusItem::mutable_selfeaddblockmessage() {
  std::string* _s = _internal_mutable_selfeaddblockmessage();
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.selfeaddblockmessage)
  return _s;
}
inline const std::string& TransactionStatusItem::_internal_selfeaddblockmessage() const {
  return _impl_.selfeaddblockmessage_.Get();
}
inline void TransactionStatusItem::_internal_set_selfeaddblockmessage(const std::string& value) {
  
  _impl_.selfeaddblockmessage_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::_internal_mutable_selfeaddblockmessage() {
  
  return _impl_.selfeaddblockmessage_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::release_selfeaddblockmessage() {
  // @@protoc_insertion_point(field_release:TransactionStatusItem.selfeaddblockmessage)
  return _impl_.selfeaddblockmessage_.Release();
}
inline void TransactionStatusItem::set_allocated_selfeaddblockmessage(std::string* selfeaddblockmessage) {
  if (selfeaddblockmessage != nullptr) {
    
  } else {
    
  }
  _impl_.selfeaddblockmessage_.SetAllocated(selfeaddblockmessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.selfeaddblockmessage_.IsDefault()) {
    _impl_.selfeaddblockmessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TransactionStatusItem.selfeaddblockmessage)
}

// string removependingtime = 9;
inline void TransactionStatusItem::clear_removependingtime() {
  _impl_.removependingtime_.ClearToEmpty();
}
inline const std::string& TransactionStatusItem::removependingtime() const {
  // @@protoc_insertion_point(field_get:TransactionStatusItem.removependingtime)
  return _internal_removependingtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionStatusItem::set_removependingtime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.removependingtime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransactionStatusItem.removependingtime)
}
inline std::string* TransactionStatusItem::mutable_removependingtime() {
  std::string* _s = _internal_mutable_removependingtime();
  // @@protoc_insertion_point(field_mutable:TransactionStatusItem.removependingtime)
  return _s;
}
inline const std::string& TransactionStatusItem::_internal_removependingtime() const {
  return _impl_.removependingtime_.Get();
}
inline void TransactionStatusItem::_internal_set_removependingtime(const std::string& value) {
  
  _impl_.removependingtime_.Set(value, GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::_internal_mutable_removependingtime() {
  
  return _impl_.removependingtime_.Mutable(GetArenaForAllocation());
}
inline std::string* TransactionStatusItem::release_removependingtime() {
  // @@protoc_insertion_point(field_release:TransactionStatusItem.removependingtime)
  return _impl_.removependingtime_.Release();
}
inline void TransactionStatusItem::set_allocated_removependingtime(std::string* removependingtime) {
  if (removependingtime != nullptr) {
    
  } else {
    
  }
  _impl_.removependingtime_.SetAllocated(removependingtime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.removependingtime_.IsDefault()) {
    _impl_.removependingtime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TransactionStatusItem.removependingtime)
}

// -------------------------------------------------------------------

// GetTransactionStatusListAck

// string version = 1;
inline void GetTransactionStatusListAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetTransactionStatusListAck::version() const {
  // @@protoc_insertion_point(field_get:GetTransactionStatusListAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionStatusListAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTransactionStatusListAck.version)
}
inline std::string* GetTransactionStatusListAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetTransactionStatusListAck.version)
  return _s;
}
inline const std::string& GetTransactionStatusListAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetTransactionStatusListAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListAck::release_version() {
  // @@protoc_insertion_point(field_release:GetTransactionStatusListAck.version)
  return _impl_.version_.Release();
}
inline void GetTransactionStatusListAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTransactionStatusListAck.version)
}

// int32 code = 2;
inline void GetTransactionStatusListAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetTransactionStatusListAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetTransactionStatusListAck::code() const {
  // @@protoc_insertion_point(field_get:GetTransactionStatusListAck.code)
  return _internal_code();
}
inline void GetTransactionStatusListAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetTransactionStatusListAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetTransactionStatusListAck.code)
}

// string message = 3;
inline void GetTransactionStatusListAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetTransactionStatusListAck::message() const {
  // @@protoc_insertion_point(field_get:GetTransactionStatusListAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionStatusListAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetTransactionStatusListAck.message)
}
inline std::string* GetTransactionStatusListAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetTransactionStatusListAck.message)
  return _s;
}
inline const std::string& GetTransactionStatusListAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetTransactionStatusListAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTransactionStatusListAck::release_message() {
  // @@protoc_insertion_point(field_release:GetTransactionStatusListAck.message)
  return _impl_.message_.Release();
}
inline void GetTransactionStatusListAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetTransactionStatusListAck.message)
}

// .TransactionStatusItem list = 5;
inline bool GetTransactionStatusListAck::_internal_has_list() const {
  return this != internal_default_instance() && _impl_.list_ != nullptr;
}
inline bool GetTransactionStatusListAck::has_list() const {
  return _internal_has_list();
}
inline void GetTransactionStatusListAck::clear_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.list_ != nullptr) {
    delete _impl_.list_;
  }
  _impl_.list_ = nullptr;
}
inline const ::TransactionStatusItem& GetTransactionStatusListAck::_internal_list() const {
  const ::TransactionStatusItem* p = _impl_.list_;
  return p != nullptr ? *p : reinterpret_cast<const ::TransactionStatusItem&>(
      ::_TransactionStatusItem_default_instance_);
}
inline const ::TransactionStatusItem& GetTransactionStatusListAck::list() const {
  // @@protoc_insertion_point(field_get:GetTransactionStatusListAck.list)
  return _internal_list();
}
inline void GetTransactionStatusListAck::unsafe_arena_set_allocated_list(
    ::TransactionStatusItem* list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.list_);
  }
  _impl_.list_ = list;
  if (list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GetTransactionStatusListAck.list)
}
inline ::TransactionStatusItem* GetTransactionStatusListAck::release_list() {
  
  ::TransactionStatusItem* temp = _impl_.list_;
  _impl_.list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TransactionStatusItem* GetTransactionStatusListAck::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_release:GetTransactionStatusListAck.list)
  
  ::TransactionStatusItem* temp = _impl_.list_;
  _impl_.list_ = nullptr;
  return temp;
}
inline ::TransactionStatusItem* GetTransactionStatusListAck::_internal_mutable_list() {
  
  if (_impl_.list_ == nullptr) {
    auto* p = CreateMaybeMessage<::TransactionStatusItem>(GetArenaForAllocation());
    _impl_.list_ = p;
  }
  return _impl_.list_;
}
inline ::TransactionStatusItem* GetTransactionStatusListAck::mutable_list() {
  ::TransactionStatusItem* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:GetTransactionStatusListAck.list)
  return _msg;
}
inline void GetTransactionStatusListAck::set_allocated_list(::TransactionStatusItem* list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.list_;
  }
  if (list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(list);
    if (message_arena != submessage_arena) {
      list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.list_ = list;
  // @@protoc_insertion_point(field_set_allocated:GetTransactionStatusListAck.list)
}

// -------------------------------------------------------------------

// SuccessRate

// string hash = 1;
inline void SuccessRate::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& SuccessRate::hash() const {
  // @@protoc_insertion_point(field_get:SuccessRate.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SuccessRate::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SuccessRate.hash)
}
inline std::string* SuccessRate::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:SuccessRate.hash)
  return _s;
}
inline const std::string& SuccessRate::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void SuccessRate::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SuccessRate::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SuccessRate::release_hash() {
  // @@protoc_insertion_point(field_release:SuccessRate.hash)
  return _impl_.hash_.Release();
}
inline void SuccessRate::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SuccessRate.hash)
}

// double rate = 2;
inline void SuccessRate::clear_rate() {
  _impl_.rate_ = 0;
}
inline double SuccessRate::_internal_rate() const {
  return _impl_.rate_;
}
inline double SuccessRate::rate() const {
  // @@protoc_insertion_point(field_get:SuccessRate.rate)
  return _internal_rate();
}
inline void SuccessRate::_internal_set_rate(double value) {
  
  _impl_.rate_ = value;
}
inline void SuccessRate::set_rate(double value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:SuccessRate.rate)
}

// -------------------------------------------------------------------

// ConfirmTransactionReq

// string version = 1;
inline void ConfirmTransactionReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionReq::version() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.version)
}
inline std::string* ConfirmTransactionReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionReq.version)
  return _s;
}
inline const std::string& ConfirmTransactionReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ConfirmTransactionReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::release_version() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionReq.version)
  return _impl_.version_.Release();
}
inline void ConfirmTransactionReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionReq.version)
}

// repeated string txhash = 2;
inline int ConfirmTransactionReq::_internal_txhash_size() const {
  return _impl_.txhash_.size();
}
inline int ConfirmTransactionReq::txhash_size() const {
  return _internal_txhash_size();
}
inline void ConfirmTransactionReq::clear_txhash() {
  _impl_.txhash_.Clear();
}
inline std::string* ConfirmTransactionReq::add_txhash() {
  std::string* _s = _internal_add_txhash();
  // @@protoc_insertion_point(field_add_mutable:ConfirmTransactionReq.txhash)
  return _s;
}
inline const std::string& ConfirmTransactionReq::_internal_txhash(int index) const {
  return _impl_.txhash_.Get(index);
}
inline const std::string& ConfirmTransactionReq::txhash(int index) const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.txhash)
  return _internal_txhash(index);
}
inline std::string* ConfirmTransactionReq::mutable_txhash(int index) {
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionReq.txhash)
  return _impl_.txhash_.Mutable(index);
}
inline void ConfirmTransactionReq::set_txhash(int index, const std::string& value) {
  _impl_.txhash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.txhash)
}
inline void ConfirmTransactionReq::set_txhash(int index, std::string&& value) {
  _impl_.txhash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.txhash)
}
inline void ConfirmTransactionReq::set_txhash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txhash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ConfirmTransactionReq.txhash)
}
inline void ConfirmTransactionReq::set_txhash(int index, const char* value, size_t size) {
  _impl_.txhash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ConfirmTransactionReq.txhash)
}
inline std::string* ConfirmTransactionReq::_internal_add_txhash() {
  return _impl_.txhash_.Add();
}
inline void ConfirmTransactionReq::add_txhash(const std::string& value) {
  _impl_.txhash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ConfirmTransactionReq.txhash)
}
inline void ConfirmTransactionReq::add_txhash(std::string&& value) {
  _impl_.txhash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ConfirmTransactionReq.txhash)
}
inline void ConfirmTransactionReq::add_txhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txhash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ConfirmTransactionReq.txhash)
}
inline void ConfirmTransactionReq::add_txhash(const char* value, size_t size) {
  _impl_.txhash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ConfirmTransactionReq.txhash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfirmTransactionReq::txhash() const {
  // @@protoc_insertion_point(field_list:ConfirmTransactionReq.txhash)
  return _impl_.txhash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfirmTransactionReq::mutable_txhash() {
  // @@protoc_insertion_point(field_mutable_list:ConfirmTransactionReq.txhash)
  return &_impl_.txhash_;
}

// uint64 time = 3;
inline void ConfirmTransactionReq::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t ConfirmTransactionReq::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t ConfirmTransactionReq::time() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.time)
  return _internal_time();
}
inline void ConfirmTransactionReq::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void ConfirmTransactionReq::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.time)
}

// uint64 height = 4;
inline void ConfirmTransactionReq::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t ConfirmTransactionReq::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t ConfirmTransactionReq::height() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.height)
  return _internal_height();
}
inline void ConfirmTransactionReq::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void ConfirmTransactionReq::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.height)
}

// -------------------------------------------------------------------

// ConfirmTransactionAck

// string version = 1;
inline void ConfirmTransactionAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionAck::version() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.version)
}
inline std::string* ConfirmTransactionAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.version)
  return _s;
}
inline const std::string& ConfirmTransactionAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ConfirmTransactionAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::release_version() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionAck.version)
  return _impl_.version_.Release();
}
inline void ConfirmTransactionAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionAck.version)
}

// int32 code = 2;
inline void ConfirmTransactionAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t ConfirmTransactionAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t ConfirmTransactionAck::code() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.code)
  return _internal_code();
}
inline void ConfirmTransactionAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void ConfirmTransactionAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.code)
}

// string message = 3;
inline void ConfirmTransactionAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionAck::message() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.message)
}
inline std::string* ConfirmTransactionAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.message)
  return _s;
}
inline const std::string& ConfirmTransactionAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ConfirmTransactionAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::release_message() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionAck.message)
  return _impl_.message_.Release();
}
inline void ConfirmTransactionAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionAck.message)
}

// uint64 time = 4;
inline void ConfirmTransactionAck::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t ConfirmTransactionAck::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t ConfirmTransactionAck::time() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.time)
  return _internal_time();
}
inline void ConfirmTransactionAck::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void ConfirmTransactionAck::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.time)
}

// repeated .SuccessRate percentage = 5;
inline int ConfirmTransactionAck::_internal_percentage_size() const {
  return _impl_.percentage_.size();
}
inline int ConfirmTransactionAck::percentage_size() const {
  return _internal_percentage_size();
}
inline void ConfirmTransactionAck::clear_percentage() {
  _impl_.percentage_.Clear();
}
inline ::SuccessRate* ConfirmTransactionAck::mutable_percentage(int index) {
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.percentage)
  return _impl_.percentage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SuccessRate >*
ConfirmTransactionAck::mutable_percentage() {
  // @@protoc_insertion_point(field_mutable_list:ConfirmTransactionAck.percentage)
  return &_impl_.percentage_;
}
inline const ::SuccessRate& ConfirmTransactionAck::_internal_percentage(int index) const {
  return _impl_.percentage_.Get(index);
}
inline const ::SuccessRate& ConfirmTransactionAck::percentage(int index) const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.percentage)
  return _internal_percentage(index);
}
inline ::SuccessRate* ConfirmTransactionAck::_internal_add_percentage() {
  return _impl_.percentage_.Add();
}
inline ::SuccessRate* ConfirmTransactionAck::add_percentage() {
  ::SuccessRate* _add = _internal_add_percentage();
  // @@protoc_insertion_point(field_add:ConfirmTransactionAck.percentage)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SuccessRate >&
ConfirmTransactionAck::percentage() const {
  // @@protoc_insertion_point(field_list:ConfirmTransactionAck.percentage)
  return _impl_.percentage_;
}

// uint32 send_size = 6;
inline void ConfirmTransactionAck::clear_send_size() {
  _impl_.send_size_ = 0u;
}
inline uint32_t ConfirmTransactionAck::_internal_send_size() const {
  return _impl_.send_size_;
}
inline uint32_t ConfirmTransactionAck::send_size() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.send_size)
  return _internal_send_size();
}
inline void ConfirmTransactionAck::_internal_set_send_size(uint32_t value) {
  
  _impl_.send_size_ = value;
}
inline void ConfirmTransactionAck::set_send_size(uint32_t value) {
  _internal_set_send_size(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.send_size)
}

// uint32 received_size = 7;
inline void ConfirmTransactionAck::clear_received_size() {
  _impl_.received_size_ = 0u;
}
inline uint32_t ConfirmTransactionAck::_internal_received_size() const {
  return _impl_.received_size_;
}
inline uint32_t ConfirmTransactionAck::received_size() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.received_size)
  return _internal_received_size();
}
inline void ConfirmTransactionAck::_internal_set_received_size(uint32_t value) {
  
  _impl_.received_size_ = value;
}
inline void ConfirmTransactionAck::set_received_size(uint32_t value) {
  _internal_set_received_size(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.received_size)
}

// bytes tx = 8;
inline void ConfirmTransactionAck::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionAck::tx() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionAck::set_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.tx)
}
inline std::string* ConfirmTransactionAck::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.tx)
  return _s;
}
inline const std::string& ConfirmTransactionAck::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void ConfirmTransactionAck::_internal_set_tx(const std::string& value) {
  
  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::_internal_mutable_tx() {
  
  return _impl_.tx_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::release_tx() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionAck.tx)
  return _impl_.tx_.Release();
}
inline void ConfirmTransactionAck::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  _impl_.tx_.SetAllocated(tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_.IsDefault()) {
    _impl_.tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionAck.tx)
}

// -------------------------------------------------------------------

// CorresHash

// string hash = 1;
inline void CorresHash::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& CorresHash::hash() const {
  // @@protoc_insertion_point(field_get:CorresHash.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CorresHash::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CorresHash.hash)
}
inline std::string* CorresHash::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:CorresHash.hash)
  return _s;
}
inline const std::string& CorresHash::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void CorresHash::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* CorresHash::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* CorresHash::release_hash() {
  // @@protoc_insertion_point(field_release:CorresHash.hash)
  return _impl_.hash_.Release();
}
inline void CorresHash::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CorresHash.hash)
}

// uint32 flag = 2;
inline void CorresHash::clear_flag() {
  _impl_.flag_ = 0u;
}
inline uint32_t CorresHash::_internal_flag() const {
  return _impl_.flag_;
}
inline uint32_t CorresHash::flag() const {
  // @@protoc_insertion_point(field_get:CorresHash.flag)
  return _internal_flag();
}
inline void CorresHash::_internal_set_flag(uint32_t value) {
  
  _impl_.flag_ = value;
}
inline void CorresHash::set_flag(uint32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:CorresHash.flag)
}

// -------------------------------------------------------------------

// CheckTxReq

// string version = 1;
inline void CheckTxReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& CheckTxReq::version() const {
  // @@protoc_insertion_point(field_get:CheckTxReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckTxReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckTxReq.version)
}
inline std::string* CheckTxReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:CheckTxReq.version)
  return _s;
}
inline const std::string& CheckTxReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void CheckTxReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckTxReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckTxReq::release_version() {
  // @@protoc_insertion_point(field_release:CheckTxReq.version)
  return _impl_.version_.Release();
}
inline void CheckTxReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CheckTxReq.version)
}

// repeated string txhash = 2;
inline int CheckTxReq::_internal_txhash_size() const {
  return _impl_.txhash_.size();
}
inline int CheckTxReq::txhash_size() const {
  return _internal_txhash_size();
}
inline void CheckTxReq::clear_txhash() {
  _impl_.txhash_.Clear();
}
inline std::string* CheckTxReq::add_txhash() {
  std::string* _s = _internal_add_txhash();
  // @@protoc_insertion_point(field_add_mutable:CheckTxReq.txhash)
  return _s;
}
inline const std::string& CheckTxReq::_internal_txhash(int index) const {
  return _impl_.txhash_.Get(index);
}
inline const std::string& CheckTxReq::txhash(int index) const {
  // @@protoc_insertion_point(field_get:CheckTxReq.txhash)
  return _internal_txhash(index);
}
inline std::string* CheckTxReq::mutable_txhash(int index) {
  // @@protoc_insertion_point(field_mutable:CheckTxReq.txhash)
  return _impl_.txhash_.Mutable(index);
}
inline void CheckTxReq::set_txhash(int index, const std::string& value) {
  _impl_.txhash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CheckTxReq.txhash)
}
inline void CheckTxReq::set_txhash(int index, std::string&& value) {
  _impl_.txhash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CheckTxReq.txhash)
}
inline void CheckTxReq::set_txhash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txhash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CheckTxReq.txhash)
}
inline void CheckTxReq::set_txhash(int index, const char* value, size_t size) {
  _impl_.txhash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CheckTxReq.txhash)
}
inline std::string* CheckTxReq::_internal_add_txhash() {
  return _impl_.txhash_.Add();
}
inline void CheckTxReq::add_txhash(const std::string& value) {
  _impl_.txhash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CheckTxReq.txhash)
}
inline void CheckTxReq::add_txhash(std::string&& value) {
  _impl_.txhash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CheckTxReq.txhash)
}
inline void CheckTxReq::add_txhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.txhash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CheckTxReq.txhash)
}
inline void CheckTxReq::add_txhash(const char* value, size_t size) {
  _impl_.txhash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CheckTxReq.txhash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CheckTxReq::txhash() const {
  // @@protoc_insertion_point(field_list:CheckTxReq.txhash)
  return _impl_.txhash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CheckTxReq::mutable_txhash() {
  // @@protoc_insertion_point(field_mutable_list:CheckTxReq.txhash)
  return &_impl_.txhash_;
}

// string msg_id = 3;
inline void CheckTxReq::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& CheckTxReq::msg_id() const {
  // @@protoc_insertion_point(field_get:CheckTxReq.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckTxReq::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckTxReq.msg_id)
}
inline std::string* CheckTxReq::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:CheckTxReq.msg_id)
  return _s;
}
inline const std::string& CheckTxReq::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void CheckTxReq::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckTxReq::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckTxReq::release_msg_id() {
  // @@protoc_insertion_point(field_release:CheckTxReq.msg_id)
  return _impl_.msg_id_.Release();
}
inline void CheckTxReq::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CheckTxReq.msg_id)
}

// uint32 isresponse = 4;
inline void CheckTxReq::clear_isresponse() {
  _impl_.isresponse_ = 0u;
}
inline uint32_t CheckTxReq::_internal_isresponse() const {
  return _impl_.isresponse_;
}
inline uint32_t CheckTxReq::isresponse() const {
  // @@protoc_insertion_point(field_get:CheckTxReq.isresponse)
  return _internal_isresponse();
}
inline void CheckTxReq::_internal_set_isresponse(uint32_t value) {
  
  _impl_.isresponse_ = value;
}
inline void CheckTxReq::set_isresponse(uint32_t value) {
  _internal_set_isresponse(value);
  // @@protoc_insertion_point(field_set:CheckTxReq.isresponse)
}

// -------------------------------------------------------------------

// GetUtxoHashReq

// string version = 1;
inline void GetUtxoHashReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetUtxoHashReq::version() const {
  // @@protoc_insertion_point(field_get:GetUtxoHashReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoHashReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoHashReq.version)
}
inline std::string* GetUtxoHashReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetUtxoHashReq.version)
  return _s;
}
inline const std::string& GetUtxoHashReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetUtxoHashReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoHashReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoHashReq::release_version() {
  // @@protoc_insertion_point(field_release:GetUtxoHashReq.version)
  return _impl_.version_.Release();
}
inline void GetUtxoHashReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoHashReq.version)
}

// repeated string utxoHash = 2;
inline int GetUtxoHashReq::_internal_utxohash_size() const {
  return _impl_.utxohash_.size();
}
inline int GetUtxoHashReq::utxohash_size() const {
  return _internal_utxohash_size();
}
inline void GetUtxoHashReq::clear_utxohash() {
  _impl_.utxohash_.Clear();
}
inline std::string* GetUtxoHashReq::add_utxohash() {
  std::string* _s = _internal_add_utxohash();
  // @@protoc_insertion_point(field_add_mutable:GetUtxoHashReq.utxoHash)
  return _s;
}
inline const std::string& GetUtxoHashReq::_internal_utxohash(int index) const {
  return _impl_.utxohash_.Get(index);
}
inline const std::string& GetUtxoHashReq::utxohash(int index) const {
  // @@protoc_insertion_point(field_get:GetUtxoHashReq.utxoHash)
  return _internal_utxohash(index);
}
inline std::string* GetUtxoHashReq::mutable_utxohash(int index) {
  // @@protoc_insertion_point(field_mutable:GetUtxoHashReq.utxoHash)
  return _impl_.utxohash_.Mutable(index);
}
inline void GetUtxoHashReq::set_utxohash(int index, const std::string& value) {
  _impl_.utxohash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:GetUtxoHashReq.utxoHash)
}
inline void GetUtxoHashReq::set_utxohash(int index, std::string&& value) {
  _impl_.utxohash_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:GetUtxoHashReq.utxoHash)
}
inline void GetUtxoHashReq::set_utxohash(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utxohash_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GetUtxoHashReq.utxoHash)
}
inline void GetUtxoHashReq::set_utxohash(int index, const char* value, size_t size) {
  _impl_.utxohash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetUtxoHashReq.utxoHash)
}
inline std::string* GetUtxoHashReq::_internal_add_utxohash() {
  return _impl_.utxohash_.Add();
}
inline void GetUtxoHashReq::add_utxohash(const std::string& value) {
  _impl_.utxohash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GetUtxoHashReq.utxoHash)
}
inline void GetUtxoHashReq::add_utxohash(std::string&& value) {
  _impl_.utxohash_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:GetUtxoHashReq.utxoHash)
}
inline void GetUtxoHashReq::add_utxohash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.utxohash_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GetUtxoHashReq.utxoHash)
}
inline void GetUtxoHashReq::add_utxohash(const char* value, size_t size) {
  _impl_.utxohash_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GetUtxoHashReq.utxoHash)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetUtxoHashReq::utxohash() const {
  // @@protoc_insertion_point(field_list:GetUtxoHashReq.utxoHash)
  return _impl_.utxohash_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetUtxoHashReq::mutable_utxohash() {
  // @@protoc_insertion_point(field_mutable_list:GetUtxoHashReq.utxoHash)
  return &_impl_.utxohash_;
}

// string msg_id = 3;
inline void GetUtxoHashReq::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& GetUtxoHashReq::msg_id() const {
  // @@protoc_insertion_point(field_get:GetUtxoHashReq.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoHashReq::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoHashReq.msg_id)
}
inline std::string* GetUtxoHashReq::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:GetUtxoHashReq.msg_id)
  return _s;
}
inline const std::string& GetUtxoHashReq::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void GetUtxoHashReq::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoHashReq::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoHashReq::release_msg_id() {
  // @@protoc_insertion_point(field_release:GetUtxoHashReq.msg_id)
  return _impl_.msg_id_.Release();
}
inline void GetUtxoHashReq::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoHashReq.msg_id)
}

// -------------------------------------------------------------------

// GetUtxoHashAck

// string version = 1;
inline void GetUtxoHashAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetUtxoHashAck::version() const {
  // @@protoc_insertion_point(field_get:GetUtxoHashAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoHashAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoHashAck.version)
}
inline std::string* GetUtxoHashAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetUtxoHashAck.version)
  return _s;
}
inline const std::string& GetUtxoHashAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetUtxoHashAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoHashAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoHashAck::release_version() {
  // @@protoc_insertion_point(field_release:GetUtxoHashAck.version)
  return _impl_.version_.Release();
}
inline void GetUtxoHashAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoHashAck.version)
}

// repeated .CorresHash flaghash = 2;
inline int GetUtxoHashAck::_internal_flaghash_size() const {
  return _impl_.flaghash_.size();
}
inline int GetUtxoHashAck::flaghash_size() const {
  return _internal_flaghash_size();
}
inline void GetUtxoHashAck::clear_flaghash() {
  _impl_.flaghash_.Clear();
}
inline ::CorresHash* GetUtxoHashAck::mutable_flaghash(int index) {
  // @@protoc_insertion_point(field_mutable:GetUtxoHashAck.flaghash)
  return _impl_.flaghash_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >*
GetUtxoHashAck::mutable_flaghash() {
  // @@protoc_insertion_point(field_mutable_list:GetUtxoHashAck.flaghash)
  return &_impl_.flaghash_;
}
inline const ::CorresHash& GetUtxoHashAck::_internal_flaghash(int index) const {
  return _impl_.flaghash_.Get(index);
}
inline const ::CorresHash& GetUtxoHashAck::flaghash(int index) const {
  // @@protoc_insertion_point(field_get:GetUtxoHashAck.flaghash)
  return _internal_flaghash(index);
}
inline ::CorresHash* GetUtxoHashAck::_internal_add_flaghash() {
  return _impl_.flaghash_.Add();
}
inline ::CorresHash* GetUtxoHashAck::add_flaghash() {
  ::CorresHash* _add = _internal_add_flaghash();
  // @@protoc_insertion_point(field_add:GetUtxoHashAck.flaghash)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >&
GetUtxoHashAck::flaghash() const {
  // @@protoc_insertion_point(field_list:GetUtxoHashAck.flaghash)
  return _impl_.flaghash_;
}

// string msg_id = 3;
inline void GetUtxoHashAck::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& GetUtxoHashAck::msg_id() const {
  // @@protoc_insertion_point(field_get:GetUtxoHashAck.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoHashAck::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoHashAck.msg_id)
}
inline std::string* GetUtxoHashAck::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:GetUtxoHashAck.msg_id)
  return _s;
}
inline const std::string& GetUtxoHashAck::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void GetUtxoHashAck::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoHashAck::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoHashAck::release_msg_id() {
  // @@protoc_insertion_point(field_release:GetUtxoHashAck.msg_id)
  return _impl_.msg_id_.Release();
}
inline void GetUtxoHashAck::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoHashAck.msg_id)
}

// string base58addr = 4;
inline void GetUtxoHashAck::clear_base58addr() {
  _impl_.base58addr_.ClearToEmpty();
}
inline const std::string& GetUtxoHashAck::base58addr() const {
  // @@protoc_insertion_point(field_get:GetUtxoHashAck.base58addr)
  return _internal_base58addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUtxoHashAck::set_base58addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.base58addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetUtxoHashAck.base58addr)
}
inline std::string* GetUtxoHashAck::mutable_base58addr() {
  std::string* _s = _internal_mutable_base58addr();
  // @@protoc_insertion_point(field_mutable:GetUtxoHashAck.base58addr)
  return _s;
}
inline const std::string& GetUtxoHashAck::_internal_base58addr() const {
  return _impl_.base58addr_.Get();
}
inline void GetUtxoHashAck::_internal_set_base58addr(const std::string& value) {
  
  _impl_.base58addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUtxoHashAck::_internal_mutable_base58addr() {
  
  return _impl_.base58addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUtxoHashAck::release_base58addr() {
  // @@protoc_insertion_point(field_release:GetUtxoHashAck.base58addr)
  return _impl_.base58addr_.Release();
}
inline void GetUtxoHashAck::set_allocated_base58addr(std::string* base58addr) {
  if (base58addr != nullptr) {
    
  } else {
    
  }
  _impl_.base58addr_.SetAllocated(base58addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.base58addr_.IsDefault()) {
    _impl_.base58addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetUtxoHashAck.base58addr)
}

// -------------------------------------------------------------------

// CheckTxAck

// string version = 1;
inline void CheckTxAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& CheckTxAck::version() const {
  // @@protoc_insertion_point(field_get:CheckTxAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckTxAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckTxAck.version)
}
inline std::string* CheckTxAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:CheckTxAck.version)
  return _s;
}
inline const std::string& CheckTxAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void CheckTxAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckTxAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckTxAck::release_version() {
  // @@protoc_insertion_point(field_release:CheckTxAck.version)
  return _impl_.version_.Release();
}
inline void CheckTxAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CheckTxAck.version)
}

// repeated .CorresHash flaghash = 2;
inline int CheckTxAck::_internal_flaghash_size() const {
  return _impl_.flaghash_.size();
}
inline int CheckTxAck::flaghash_size() const {
  return _internal_flaghash_size();
}
inline void CheckTxAck::clear_flaghash() {
  _impl_.flaghash_.Clear();
}
inline ::CorresHash* CheckTxAck::mutable_flaghash(int index) {
  // @@protoc_insertion_point(field_mutable:CheckTxAck.flaghash)
  return _impl_.flaghash_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >*
CheckTxAck::mutable_flaghash() {
  // @@protoc_insertion_point(field_mutable_list:CheckTxAck.flaghash)
  return &_impl_.flaghash_;
}
inline const ::CorresHash& CheckTxAck::_internal_flaghash(int index) const {
  return _impl_.flaghash_.Get(index);
}
inline const ::CorresHash& CheckTxAck::flaghash(int index) const {
  // @@protoc_insertion_point(field_get:CheckTxAck.flaghash)
  return _internal_flaghash(index);
}
inline ::CorresHash* CheckTxAck::_internal_add_flaghash() {
  return _impl_.flaghash_.Add();
}
inline ::CorresHash* CheckTxAck::add_flaghash() {
  ::CorresHash* _add = _internal_add_flaghash();
  // @@protoc_insertion_point(field_add:CheckTxAck.flaghash)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CorresHash >&
CheckTxAck::flaghash() const {
  // @@protoc_insertion_point(field_list:CheckTxAck.flaghash)
  return _impl_.flaghash_;
}

// string msg_id = 3;
inline void CheckTxAck::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& CheckTxAck::msg_id() const {
  // @@protoc_insertion_point(field_get:CheckTxAck.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckTxAck::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckTxAck.msg_id)
}
inline std::string* CheckTxAck::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:CheckTxAck.msg_id)
  return _s;
}
inline const std::string& CheckTxAck::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void CheckTxAck::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckTxAck::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckTxAck::release_msg_id() {
  // @@protoc_insertion_point(field_release:CheckTxAck.msg_id)
  return _impl_.msg_id_.Release();
}
inline void CheckTxAck::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CheckTxAck.msg_id)
}

// string addr = 4;
inline void CheckTxAck::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& CheckTxAck::addr() const {
  // @@protoc_insertion_point(field_get:CheckTxAck.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckTxAck::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckTxAck.addr)
}
inline std::string* CheckTxAck::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:CheckTxAck.addr)
  return _s;
}
inline const std::string& CheckTxAck::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void CheckTxAck::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckTxAck::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckTxAck::release_addr() {
  // @@protoc_insertion_point(field_release:CheckTxAck.addr)
  return _impl_.addr_.Release();
}
inline void CheckTxAck::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CheckTxAck.addr)
}

// bytes tx = 5;
inline void CheckTxAck::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& CheckTxAck::tx() const {
  // @@protoc_insertion_point(field_get:CheckTxAck.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckTxAck::set_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckTxAck.tx)
}
inline std::string* CheckTxAck::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:CheckTxAck.tx)
  return _s;
}
inline const std::string& CheckTxAck::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void CheckTxAck::_internal_set_tx(const std::string& value) {
  
  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckTxAck::_internal_mutable_tx() {
  
  return _impl_.tx_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckTxAck::release_tx() {
  // @@protoc_insertion_point(field_release:CheckTxAck.tx)
  return _impl_.tx_.Release();
}
inline void CheckTxAck::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  _impl_.tx_.SetAllocated(tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_.IsDefault()) {
    _impl_.tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CheckTxAck.tx)
}

// -------------------------------------------------------------------

// GetRestInvestAmountReq

// string version = 1;
inline void GetRestInvestAmountReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetRestInvestAmountReq::version() const {
  // @@protoc_insertion_point(field_get:GetRestInvestAmountReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRestInvestAmountReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetRestInvestAmountReq.version)
}
inline std::string* GetRestInvestAmountReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetRestInvestAmountReq.version)
  return _s;
}
inline const std::string& GetRestInvestAmountReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetRestInvestAmountReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountReq::release_version() {
  // @@protoc_insertion_point(field_release:GetRestInvestAmountReq.version)
  return _impl_.version_.Release();
}
inline void GetRestInvestAmountReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetRestInvestAmountReq.version)
}

// string addr = 2;
inline void GetRestInvestAmountReq::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetRestInvestAmountReq::addr() const {
  // @@protoc_insertion_point(field_get:GetRestInvestAmountReq.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRestInvestAmountReq::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetRestInvestAmountReq.addr)
}
inline std::string* GetRestInvestAmountReq::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:GetRestInvestAmountReq.addr)
  return _s;
}
inline const std::string& GetRestInvestAmountReq::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void GetRestInvestAmountReq::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountReq::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountReq::release_addr() {
  // @@protoc_insertion_point(field_release:GetRestInvestAmountReq.addr)
  return _impl_.addr_.Release();
}
inline void GetRestInvestAmountReq::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetRestInvestAmountReq.addr)
}

// -------------------------------------------------------------------

// GetRestInvestAmountAck

// string version = 1;
inline void GetRestInvestAmountAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GetRestInvestAmountAck::version() const {
  // @@protoc_insertion_point(field_get:GetRestInvestAmountAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRestInvestAmountAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetRestInvestAmountAck.version)
}
inline std::string* GetRestInvestAmountAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:GetRestInvestAmountAck.version)
  return _s;
}
inline const std::string& GetRestInvestAmountAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GetRestInvestAmountAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountAck::release_version() {
  // @@protoc_insertion_point(field_release:GetRestInvestAmountAck.version)
  return _impl_.version_.Release();
}
inline void GetRestInvestAmountAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetRestInvestAmountAck.version)
}

// int32 code = 2;
inline void GetRestInvestAmountAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t GetRestInvestAmountAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t GetRestInvestAmountAck::code() const {
  // @@protoc_insertion_point(field_get:GetRestInvestAmountAck.code)
  return _internal_code();
}
inline void GetRestInvestAmountAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void GetRestInvestAmountAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:GetRestInvestAmountAck.code)
}

// string message = 3;
inline void GetRestInvestAmountAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetRestInvestAmountAck::message() const {
  // @@protoc_insertion_point(field_get:GetRestInvestAmountAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRestInvestAmountAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetRestInvestAmountAck.message)
}
inline std::string* GetRestInvestAmountAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:GetRestInvestAmountAck.message)
  return _s;
}
inline const std::string& GetRestInvestAmountAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetRestInvestAmountAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountAck::release_message() {
  // @@protoc_insertion_point(field_release:GetRestInvestAmountAck.message)
  return _impl_.message_.Release();
}
inline void GetRestInvestAmountAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetRestInvestAmountAck.message)
}

// uint64 amount = 4;
inline void GetRestInvestAmountAck::clear_amount() {
  _impl_.amount_ = uint64_t{0u};
}
inline uint64_t GetRestInvestAmountAck::_internal_amount() const {
  return _impl_.amount_;
}
inline uint64_t GetRestInvestAmountAck::amount() const {
  // @@protoc_insertion_point(field_get:GetRestInvestAmountAck.amount)
  return _internal_amount();
}
inline void GetRestInvestAmountAck::_internal_set_amount(uint64_t value) {
  
  _impl_.amount_ = value;
}
inline void GetRestInvestAmountAck::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:GetRestInvestAmountAck.amount)
}

// string addr = 5;
inline void GetRestInvestAmountAck::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& GetRestInvestAmountAck::addr() const {
  // @@protoc_insertion_point(field_get:GetRestInvestAmountAck.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRestInvestAmountAck::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetRestInvestAmountAck.addr)
}
inline std::string* GetRestInvestAmountAck::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:GetRestInvestAmountAck.addr)
  return _s;
}
inline const std::string& GetRestInvestAmountAck::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void GetRestInvestAmountAck::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountAck::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRestInvestAmountAck::release_addr() {
  // @@protoc_insertion_point(field_release:GetRestInvestAmountAck.addr)
  return _impl_.addr_.Release();
}
inline void GetRestInvestAmountAck::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetRestInvestAmountAck.addr)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::TxType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TxType>() {
  return ::TxType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_interface_2eproto
