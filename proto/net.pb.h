// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "sign.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_net_2eproto;
class BroadcastMsgReq;
struct BroadcastMsgReqDefaultTypeInternal;
extern BroadcastMsgReqDefaultTypeInternal _BroadcastMsgReq_default_instance_;
class EchoAck;
struct EchoAckDefaultTypeInternal;
extern EchoAckDefaultTypeInternal _EchoAck_default_instance_;
class EchoReq;
struct EchoReqDefaultTypeInternal;
extern EchoReqDefaultTypeInternal _EchoReq_default_instance_;
class NodeAddrChangedReq;
struct NodeAddrChangedReqDefaultTypeInternal;
extern NodeAddrChangedReqDefaultTypeInternal _NodeAddrChangedReq_default_instance_;
class NodeHeightChangedReq;
struct NodeHeightChangedReqDefaultTypeInternal;
extern NodeHeightChangedReqDefaultTypeInternal _NodeHeightChangedReq_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NodeSign;
struct NodeSignDefaultTypeInternal;
extern NodeSignDefaultTypeInternal _NodeSign_default_instance_;
class PingReq;
struct PingReqDefaultTypeInternal;
extern PingReqDefaultTypeInternal _PingReq_default_instance_;
class PongReq;
struct PongReqDefaultTypeInternal;
extern PongReqDefaultTypeInternal _PongReq_default_instance_;
class PrintMsgReq;
struct PrintMsgReqDefaultTypeInternal;
extern PrintMsgReqDefaultTypeInternal _PrintMsgReq_default_instance_;
class RegisterNodeAck;
struct RegisterNodeAckDefaultTypeInternal;
extern RegisterNodeAckDefaultTypeInternal _RegisterNodeAck_default_instance_;
class RegisterNodeReq;
struct RegisterNodeReqDefaultTypeInternal;
extern RegisterNodeReqDefaultTypeInternal _RegisterNodeReq_default_instance_;
class SyncNodeAck;
struct SyncNodeAckDefaultTypeInternal;
extern SyncNodeAckDefaultTypeInternal _SyncNodeAck_default_instance_;
class SyncNodeReq;
struct SyncNodeReqDefaultTypeInternal;
extern SyncNodeReqDefaultTypeInternal _SyncNodeReq_default_instance_;
class TestNetAck;
struct TestNetAckDefaultTypeInternal;
extern TestNetAckDefaultTypeInternal _TestNetAck_default_instance_;
class TestNetReq;
struct TestNetReqDefaultTypeInternal;
extern TestNetReqDefaultTypeInternal _TestNetReq_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BroadcastMsgReq* Arena::CreateMaybeMessage<::BroadcastMsgReq>(Arena*);
template<> ::EchoAck* Arena::CreateMaybeMessage<::EchoAck>(Arena*);
template<> ::EchoReq* Arena::CreateMaybeMessage<::EchoReq>(Arena*);
template<> ::NodeAddrChangedReq* Arena::CreateMaybeMessage<::NodeAddrChangedReq>(Arena*);
template<> ::NodeHeightChangedReq* Arena::CreateMaybeMessage<::NodeHeightChangedReq>(Arena*);
template<> ::NodeInfo* Arena::CreateMaybeMessage<::NodeInfo>(Arena*);
template<> ::NodeSign* Arena::CreateMaybeMessage<::NodeSign>(Arena*);
template<> ::PingReq* Arena::CreateMaybeMessage<::PingReq>(Arena*);
template<> ::PongReq* Arena::CreateMaybeMessage<::PongReq>(Arena*);
template<> ::PrintMsgReq* Arena::CreateMaybeMessage<::PrintMsgReq>(Arena*);
template<> ::RegisterNodeAck* Arena::CreateMaybeMessage<::RegisterNodeAck>(Arena*);
template<> ::RegisterNodeReq* Arena::CreateMaybeMessage<::RegisterNodeReq>(Arena*);
template<> ::SyncNodeAck* Arena::CreateMaybeMessage<::SyncNodeAck>(Arena*);
template<> ::SyncNodeReq* Arena::CreateMaybeMessage<::SyncNodeReq>(Arena*);
template<> ::TestNetAck* Arena::CreateMaybeMessage<::TestNetAck>(Arena*);
template<> ::TestNetReq* Arena::CreateMaybeMessage<::TestNetReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class PrintMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PrintMsgReq) */ {
 public:
  inline PrintMsgReq() : PrintMsgReq(nullptr) {}
  ~PrintMsgReq() override;
  explicit PROTOBUF_CONSTEXPR PrintMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrintMsgReq(const PrintMsgReq& from);
  PrintMsgReq(PrintMsgReq&& from) noexcept
    : PrintMsgReq() {
    *this = ::std::move(from);
  }

  inline PrintMsgReq& operator=(const PrintMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrintMsgReq& operator=(PrintMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrintMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrintMsgReq* internal_default_instance() {
    return reinterpret_cast<const PrintMsgReq*>(
               &_PrintMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PrintMsgReq& a, PrintMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PrintMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrintMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrintMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrintMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrintMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrintMsgReq& from) {
    PrintMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrintMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PrintMsgReq";
  }
  protected:
  explicit PrintMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PrintMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() override;
  explicit PROTOBUF_CONSTEXPR NodeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeInfo(const NodeInfo& from);
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeInfo& from) {
    NodeInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NodeInfo";
  }
  protected:
  explicit NodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubFieldNumber = 1,
    kSignFieldNumber = 2,
    kIdentityFieldNumber = 3,
    kAddrFieldNumber = 4,
    kPublicAddrFieldNumber = 5,
    kNameFieldNumber = 6,
    kLogoFieldNumber = 7,
    kVersionFieldNumber = 14,
    kListenIpFieldNumber = 8,
    kListenPortFieldNumber = 9,
    kPublicIpFieldNumber = 10,
    kPublicPortFieldNumber = 11,
    kTimeStampFieldNumber = 13,
    kHeightFieldNumber = 12,
  };
  // bytes pub = 1;
  void clear_pub();
  const std::string& pub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub();
  PROTOBUF_NODISCARD std::string* release_pub();
  void set_allocated_pub(std::string* pub);
  private:
  const std::string& _internal_pub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub(const std::string& value);
  std::string* _internal_mutable_pub();
  public:

  // bytes sign = 2;
  void clear_sign();
  const std::string& sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign();
  PROTOBUF_NODISCARD std::string* release_sign();
  void set_allocated_sign(std::string* sign);
  private:
  const std::string& _internal_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign(const std::string& value);
  std::string* _internal_mutable_sign();
  public:

  // bytes identity = 3;
  void clear_identity();
  const std::string& identity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identity();
  PROTOBUF_NODISCARD std::string* release_identity();
  void set_allocated_identity(std::string* identity);
  private:
  const std::string& _internal_identity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identity(const std::string& value);
  std::string* _internal_mutable_identity();
  public:

  // string addr = 4;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // string public_addr = 5;
  void clear_public_addr();
  const std::string& public_addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_addr();
  PROTOBUF_NODISCARD std::string* release_public_addr();
  void set_allocated_public_addr(std::string* public_addr);
  private:
  const std::string& _internal_public_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_addr(const std::string& value);
  std::string* _internal_mutable_public_addr();
  public:

  // string name = 6;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string logo = 7;
  void clear_logo();
  const std::string& logo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logo();
  PROTOBUF_NODISCARD std::string* release_logo();
  void set_allocated_logo(std::string* logo);
  private:
  const std::string& _internal_logo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logo(const std::string& value);
  std::string* _internal_mutable_logo();
  public:

  // string version = 14;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint32 listen_ip = 8;
  void clear_listen_ip();
  uint32_t listen_ip() const;
  void set_listen_ip(uint32_t value);
  private:
  uint32_t _internal_listen_ip() const;
  void _internal_set_listen_ip(uint32_t value);
  public:

  // uint32 listen_port = 9;
  void clear_listen_port();
  uint32_t listen_port() const;
  void set_listen_port(uint32_t value);
  private:
  uint32_t _internal_listen_port() const;
  void _internal_set_listen_port(uint32_t value);
  public:

  // uint32 public_ip = 10;
  void clear_public_ip();
  uint32_t public_ip() const;
  void set_public_ip(uint32_t value);
  private:
  uint32_t _internal_public_ip() const;
  void _internal_set_public_ip(uint32_t value);
  public:

  // uint32 public_port = 11;
  void clear_public_port();
  uint32_t public_port() const;
  void set_public_port(uint32_t value);
  private:
  uint32_t _internal_public_port() const;
  void _internal_set_public_port(uint32_t value);
  public:

  // uint64 time_stamp = 13;
  void clear_time_stamp();
  uint64_t time_stamp() const;
  void set_time_stamp(uint64_t value);
  private:
  uint64_t _internal_time_stamp() const;
  void _internal_set_time_stamp(uint64_t value);
  public:

  // uint32 height = 12;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NodeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_addr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    uint32_t listen_ip_;
    uint32_t listen_port_;
    uint32_t public_ip_;
    uint32_t public_port_;
    uint64_t time_stamp_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class RegisterNodeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterNodeReq) */ {
 public:
  inline RegisterNodeReq() : RegisterNodeReq(nullptr) {}
  ~RegisterNodeReq() override;
  explicit PROTOBUF_CONSTEXPR RegisterNodeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterNodeReq(const RegisterNodeReq& from);
  RegisterNodeReq(RegisterNodeReq&& from) noexcept
    : RegisterNodeReq() {
    *this = ::std::move(from);
  }

  inline RegisterNodeReq& operator=(const RegisterNodeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNodeReq& operator=(RegisterNodeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNodeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterNodeReq* internal_default_instance() {
    return reinterpret_cast<const RegisterNodeReq*>(
               &_RegisterNodeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterNodeReq& a, RegisterNodeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterNodeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNodeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNodeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterNodeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterNodeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterNodeReq& from) {
    RegisterNodeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterNodeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterNodeReq";
  }
  protected:
  explicit RegisterNodeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgIdFieldNumber = 3,
    kMynodeFieldNumber = 1,
    kIsGetNodelistFieldNumber = 2,
  };
  // string msg_id = 3;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // .NodeInfo mynode = 1;
  bool has_mynode() const;
  private:
  bool _internal_has_mynode() const;
  public:
  void clear_mynode();
  const ::NodeInfo& mynode() const;
  PROTOBUF_NODISCARD ::NodeInfo* release_mynode();
  ::NodeInfo* mutable_mynode();
  void set_allocated_mynode(::NodeInfo* mynode);
  private:
  const ::NodeInfo& _internal_mynode() const;
  ::NodeInfo* _internal_mutable_mynode();
  public:
  void unsafe_arena_set_allocated_mynode(
      ::NodeInfo* mynode);
  ::NodeInfo* unsafe_arena_release_mynode();

  // bool is_get_nodelist = 2;
  void clear_is_get_nodelist();
  bool is_get_nodelist() const;
  void set_is_get_nodelist(bool value);
  private:
  bool _internal_is_get_nodelist() const;
  void _internal_set_is_get_nodelist(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RegisterNodeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    ::NodeInfo* mynode_;
    bool is_get_nodelist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class RegisterNodeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterNodeAck) */ {
 public:
  inline RegisterNodeAck() : RegisterNodeAck(nullptr) {}
  ~RegisterNodeAck() override;
  explicit PROTOBUF_CONSTEXPR RegisterNodeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterNodeAck(const RegisterNodeAck& from);
  RegisterNodeAck(RegisterNodeAck&& from) noexcept
    : RegisterNodeAck() {
    *this = ::std::move(from);
  }

  inline RegisterNodeAck& operator=(const RegisterNodeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNodeAck& operator=(RegisterNodeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNodeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterNodeAck* internal_default_instance() {
    return reinterpret_cast<const RegisterNodeAck*>(
               &_RegisterNodeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterNodeAck& a, RegisterNodeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterNodeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNodeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNodeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterNodeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterNodeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterNodeAck& from) {
    RegisterNodeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterNodeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterNodeAck";
  }
  protected:
  explicit RegisterNodeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kMsgIdFieldNumber = 2,
    kFromIpFieldNumber = 3,
    kFromPortFieldNumber = 4,
    kFdFieldNumber = 5,
  };
  // repeated .NodeInfo nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::NodeInfo* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >*
      mutable_nodes();
  private:
  const ::NodeInfo& _internal_nodes(int index) const;
  ::NodeInfo* _internal_add_nodes();
  public:
  const ::NodeInfo& nodes(int index) const;
  ::NodeInfo* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >&
      nodes() const;

  // string msg_id = 2;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // uint32 from_ip = 3;
  void clear_from_ip();
  uint32_t from_ip() const;
  void set_from_ip(uint32_t value);
  private:
  uint32_t _internal_from_ip() const;
  void _internal_set_from_ip(uint32_t value);
  public:

  // uint32 from_port = 4;
  void clear_from_port();
  uint32_t from_port() const;
  void set_from_port(uint32_t value);
  private:
  uint32_t _internal_from_port() const;
  void _internal_set_from_port(uint32_t value);
  public:

  // uint32 fd = 5;
  void clear_fd();
  uint32_t fd() const;
  void set_fd(uint32_t value);
  private:
  uint32_t _internal_fd() const;
  void _internal_set_fd(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RegisterNodeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo > nodes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    uint32_t from_ip_;
    uint32_t from_port_;
    uint32_t fd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class SyncNodeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SyncNodeReq) */ {
 public:
  inline SyncNodeReq() : SyncNodeReq(nullptr) {}
  ~SyncNodeReq() override;
  explicit PROTOBUF_CONSTEXPR SyncNodeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncNodeReq(const SyncNodeReq& from);
  SyncNodeReq(SyncNodeReq&& from) noexcept
    : SyncNodeReq() {
    *this = ::std::move(from);
  }

  inline SyncNodeReq& operator=(const SyncNodeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncNodeReq& operator=(SyncNodeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncNodeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncNodeReq* internal_default_instance() {
    return reinterpret_cast<const SyncNodeReq*>(
               &_SyncNodeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SyncNodeReq& a, SyncNodeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncNodeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncNodeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncNodeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncNodeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncNodeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncNodeReq& from) {
    SyncNodeReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncNodeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SyncNodeReq";
  }
  protected:
  explicit SyncNodeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kMsgIdFieldNumber = 3,
  };
  // string ids = 1;
  void clear_ids();
  const std::string& ids() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ids(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ids();
  PROTOBUF_NODISCARD std::string* release_ids();
  void set_allocated_ids(std::string* ids);
  private:
  const std::string& _internal_ids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ids(const std::string& value);
  std::string* _internal_mutable_ids();
  public:

  // string msg_id = 3;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // @@protoc_insertion_point(class_scope:SyncNodeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class SyncNodeAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SyncNodeAck) */ {
 public:
  inline SyncNodeAck() : SyncNodeAck(nullptr) {}
  ~SyncNodeAck() override;
  explicit PROTOBUF_CONSTEXPR SyncNodeAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncNodeAck(const SyncNodeAck& from);
  SyncNodeAck(SyncNodeAck&& from) noexcept
    : SyncNodeAck() {
    *this = ::std::move(from);
  }

  inline SyncNodeAck& operator=(const SyncNodeAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncNodeAck& operator=(SyncNodeAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncNodeAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncNodeAck* internal_default_instance() {
    return reinterpret_cast<const SyncNodeAck*>(
               &_SyncNodeAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SyncNodeAck& a, SyncNodeAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncNodeAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncNodeAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncNodeAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncNodeAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncNodeAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncNodeAck& from) {
    SyncNodeAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncNodeAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SyncNodeAck";
  }
  protected:
  explicit SyncNodeAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kIdsFieldNumber = 3,
    kMsgIdFieldNumber = 4,
    kSignFieldNumber = 2,
  };
  // repeated .NodeInfo nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::NodeInfo* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >*
      mutable_nodes();
  private:
  const ::NodeInfo& _internal_nodes(int index) const;
  ::NodeInfo* _internal_add_nodes();
  public:
  const ::NodeInfo& nodes(int index) const;
  ::NodeInfo* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >&
      nodes() const;

  // string ids = 3;
  void clear_ids();
  const std::string& ids() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ids(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ids();
  PROTOBUF_NODISCARD std::string* release_ids();
  void set_allocated_ids(std::string* ids);
  private:
  const std::string& _internal_ids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ids(const std::string& value);
  std::string* _internal_mutable_ids();
  public:

  // string msg_id = 4;
  void clear_msg_id();
  const std::string& msg_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_id();
  PROTOBUF_NODISCARD std::string* release_msg_id();
  void set_allocated_msg_id(std::string* msg_id);
  private:
  const std::string& _internal_msg_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_id(const std::string& value);
  std::string* _internal_mutable_msg_id();
  public:

  // .CSign sign = 2;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::CSign& sign() const;
  PROTOBUF_NODISCARD ::CSign* release_sign();
  ::CSign* mutable_sign();
  void set_allocated_sign(::CSign* sign);
  private:
  const ::CSign& _internal_sign() const;
  ::CSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::CSign* sign);
  ::CSign* unsafe_arena_release_sign();

  // @@protoc_insertion_point(class_scope:SyncNodeAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo > nodes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_id_;
    ::CSign* sign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class BroadcastMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BroadcastMsgReq) */ {
 public:
  inline BroadcastMsgReq() : BroadcastMsgReq(nullptr) {}
  ~BroadcastMsgReq() override;
  explicit PROTOBUF_CONSTEXPR BroadcastMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastMsgReq(const BroadcastMsgReq& from);
  BroadcastMsgReq(BroadcastMsgReq&& from) noexcept
    : BroadcastMsgReq() {
    *this = ::std::move(from);
  }

  inline BroadcastMsgReq& operator=(const BroadcastMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastMsgReq& operator=(BroadcastMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastMsgReq* internal_default_instance() {
    return reinterpret_cast<const BroadcastMsgReq*>(
               &_BroadcastMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BroadcastMsgReq& a, BroadcastMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastMsgReq& from) {
    BroadcastMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BroadcastMsgReq";
  }
  protected:
  explicit BroadcastMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kFromFieldNumber = 1,
    kPriorityFieldNumber = 3,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .NodeInfo from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::NodeInfo& from() const;
  PROTOBUF_NODISCARD ::NodeInfo* release_from();
  ::NodeInfo* mutable_from();
  void set_allocated_from(::NodeInfo* from);
  private:
  const ::NodeInfo& _internal_from() const;
  ::NodeInfo* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::NodeInfo* from);
  ::NodeInfo* unsafe_arena_release_from();

  // uint32 priority = 3;
  void clear_priority();
  uint32_t priority() const;
  void set_priority(uint32_t value);
  private:
  uint32_t _internal_priority() const;
  void _internal_set_priority(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:BroadcastMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::NodeInfo* from_;
    uint32_t priority_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class PingReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PingReq) */ {
 public:
  inline PingReq() : PingReq(nullptr) {}
  ~PingReq() override;
  explicit PROTOBUF_CONSTEXPR PingReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingReq(const PingReq& from);
  PingReq(PingReq&& from) noexcept
    : PingReq() {
    *this = ::std::move(from);
  }

  inline PingReq& operator=(const PingReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingReq& operator=(PingReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingReq* internal_default_instance() {
    return reinterpret_cast<const PingReq*>(
               &_PingReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PingReq& a, PingReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PingReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingReq& from) {
    PingReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PingReq";
  }
  protected:
  explicit PingReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:PingReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class PongReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PongReq) */ {
 public:
  inline PongReq() : PongReq(nullptr) {}
  ~PongReq() override;
  explicit PROTOBUF_CONSTEXPR PongReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PongReq(const PongReq& from);
  PongReq(PongReq&& from) noexcept
    : PongReq() {
    *this = ::std::move(from);
  }

  inline PongReq& operator=(const PongReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PongReq& operator=(PongReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PongReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PongReq* internal_default_instance() {
    return reinterpret_cast<const PongReq*>(
               &_PongReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PongReq& a, PongReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PongReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PongReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PongReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PongReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PongReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PongReq& from) {
    PongReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PongReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PongReq";
  }
  protected:
  explicit PongReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:PongReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class EchoReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EchoReq) */ {
 public:
  inline EchoReq() : EchoReq(nullptr) {}
  ~EchoReq() override;
  explicit PROTOBUF_CONSTEXPR EchoReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EchoReq(const EchoReq& from);
  EchoReq(EchoReq&& from) noexcept
    : EchoReq() {
    *this = ::std::move(from);
  }

  inline EchoReq& operator=(const EchoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EchoReq& operator=(EchoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EchoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EchoReq* internal_default_instance() {
    return reinterpret_cast<const EchoReq*>(
               &_EchoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EchoReq& a, EchoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EchoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EchoReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EchoReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EchoReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EchoReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EchoReq& from) {
    EchoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EchoReq";
  }
  protected:
  explicit EchoReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:EchoReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class EchoAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EchoAck) */ {
 public:
  inline EchoAck() : EchoAck(nullptr) {}
  ~EchoAck() override;
  explicit PROTOBUF_CONSTEXPR EchoAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EchoAck(const EchoAck& from);
  EchoAck(EchoAck&& from) noexcept
    : EchoAck() {
    *this = ::std::move(from);
  }

  inline EchoAck& operator=(const EchoAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EchoAck& operator=(EchoAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EchoAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const EchoAck* internal_default_instance() {
    return reinterpret_cast<const EchoAck*>(
               &_EchoAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EchoAck& a, EchoAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EchoAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EchoAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EchoAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EchoAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EchoAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EchoAck& from) {
    EchoAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EchoAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EchoAck";
  }
  protected:
  explicit EchoAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:EchoAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class NodeHeightChangedReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NodeHeightChangedReq) */ {
 public:
  inline NodeHeightChangedReq() : NodeHeightChangedReq(nullptr) {}
  ~NodeHeightChangedReq() override;
  explicit PROTOBUF_CONSTEXPR NodeHeightChangedReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeHeightChangedReq(const NodeHeightChangedReq& from);
  NodeHeightChangedReq(NodeHeightChangedReq&& from) noexcept
    : NodeHeightChangedReq() {
    *this = ::std::move(from);
  }

  inline NodeHeightChangedReq& operator=(const NodeHeightChangedReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeHeightChangedReq& operator=(NodeHeightChangedReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeHeightChangedReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeHeightChangedReq* internal_default_instance() {
    return reinterpret_cast<const NodeHeightChangedReq*>(
               &_NodeHeightChangedReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NodeHeightChangedReq& a, NodeHeightChangedReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeHeightChangedReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeHeightChangedReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeHeightChangedReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeHeightChangedReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeHeightChangedReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeHeightChangedReq& from) {
    NodeHeightChangedReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeHeightChangedReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NodeHeightChangedReq";
  }
  protected:
  explicit NodeHeightChangedReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSignFieldNumber = 3,
    kHeightFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .CSign sign = 3;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::CSign& sign() const;
  PROTOBUF_NODISCARD ::CSign* release_sign();
  ::CSign* mutable_sign();
  void set_allocated_sign(::CSign* sign);
  private:
  const ::CSign& _internal_sign() const;
  ::CSign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::CSign* sign);
  ::CSign* unsafe_arena_release_sign();

  // uint32 height = 2;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NodeHeightChangedReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::CSign* sign_;
    uint32_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class NodeSign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NodeSign) */ {
 public:
  inline NodeSign() : NodeSign(nullptr) {}
  ~NodeSign() override;
  explicit PROTOBUF_CONSTEXPR NodeSign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeSign(const NodeSign& from);
  NodeSign(NodeSign&& from) noexcept
    : NodeSign() {
    *this = ::std::move(from);
  }

  inline NodeSign& operator=(const NodeSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeSign& operator=(NodeSign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeSign* internal_default_instance() {
    return reinterpret_cast<const NodeSign*>(
               &_NodeSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NodeSign& a, NodeSign& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeSign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeSign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeSign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeSign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeSign& from) {
    NodeSign::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeSign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NodeSign";
  }
  protected:
  explicit NodeSign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignFieldNumber = 1,
    kPubFieldNumber = 2,
  };
  // bytes sign = 1;
  void clear_sign();
  const std::string& sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign();
  PROTOBUF_NODISCARD std::string* release_sign();
  void set_allocated_sign(std::string* sign);
  private:
  const std::string& _internal_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign(const std::string& value);
  std::string* _internal_mutable_sign();
  public:

  // bytes pub = 2;
  void clear_pub();
  const std::string& pub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub();
  PROTOBUF_NODISCARD std::string* release_pub();
  void set_allocated_pub(std::string* pub);
  private:
  const std::string& _internal_pub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub(const std::string& value);
  std::string* _internal_mutable_pub();
  public:

  // @@protoc_insertion_point(class_scope:NodeSign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class NodeAddrChangedReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NodeAddrChangedReq) */ {
 public:
  inline NodeAddrChangedReq() : NodeAddrChangedReq(nullptr) {}
  ~NodeAddrChangedReq() override;
  explicit PROTOBUF_CONSTEXPR NodeAddrChangedReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeAddrChangedReq(const NodeAddrChangedReq& from);
  NodeAddrChangedReq(NodeAddrChangedReq&& from) noexcept
    : NodeAddrChangedReq() {
    *this = ::std::move(from);
  }

  inline NodeAddrChangedReq& operator=(const NodeAddrChangedReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeAddrChangedReq& operator=(NodeAddrChangedReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeAddrChangedReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeAddrChangedReq* internal_default_instance() {
    return reinterpret_cast<const NodeAddrChangedReq*>(
               &_NodeAddrChangedReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(NodeAddrChangedReq& a, NodeAddrChangedReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeAddrChangedReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeAddrChangedReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeAddrChangedReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeAddrChangedReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeAddrChangedReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeAddrChangedReq& from) {
    NodeAddrChangedReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeAddrChangedReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NodeAddrChangedReq";
  }
  protected:
  explicit NodeAddrChangedReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kOldSignFieldNumber = 2,
    kNewSignFieldNumber = 3,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .NodeSign oldSign = 2;
  bool has_oldsign() const;
  private:
  bool _internal_has_oldsign() const;
  public:
  void clear_oldsign();
  const ::NodeSign& oldsign() const;
  PROTOBUF_NODISCARD ::NodeSign* release_oldsign();
  ::NodeSign* mutable_oldsign();
  void set_allocated_oldsign(::NodeSign* oldsign);
  private:
  const ::NodeSign& _internal_oldsign() const;
  ::NodeSign* _internal_mutable_oldsign();
  public:
  void unsafe_arena_set_allocated_oldsign(
      ::NodeSign* oldsign);
  ::NodeSign* unsafe_arena_release_oldsign();

  // .NodeSign newSign = 3;
  bool has_newsign() const;
  private:
  bool _internal_has_newsign() const;
  public:
  void clear_newsign();
  const ::NodeSign& newsign() const;
  PROTOBUF_NODISCARD ::NodeSign* release_newsign();
  ::NodeSign* mutable_newsign();
  void set_allocated_newsign(::NodeSign* newsign);
  private:
  const ::NodeSign& _internal_newsign() const;
  ::NodeSign* _internal_mutable_newsign();
  public:
  void unsafe_arena_set_allocated_newsign(
      ::NodeSign* newsign);
  ::NodeSign* unsafe_arena_release_newsign();

  // @@protoc_insertion_point(class_scope:NodeAddrChangedReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::NodeSign* oldsign_;
    ::NodeSign* newsign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class TestNetAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TestNetAck) */ {
 public:
  inline TestNetAck() : TestNetAck(nullptr) {}
  ~TestNetAck() override;
  explicit PROTOBUF_CONSTEXPR TestNetAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestNetAck(const TestNetAck& from);
  TestNetAck(TestNetAck&& from) noexcept
    : TestNetAck() {
    *this = ::std::move(from);
  }

  inline TestNetAck& operator=(const TestNetAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestNetAck& operator=(TestNetAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestNetAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestNetAck* internal_default_instance() {
    return reinterpret_cast<const TestNetAck*>(
               &_TestNetAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TestNetAck& a, TestNetAck& b) {
    a.Swap(&b);
  }
  inline void Swap(TestNetAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestNetAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestNetAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestNetAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestNetAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestNetAck& from) {
    TestNetAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestNetAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TestNetAck";
  }
  protected:
  explicit TestNetAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kHashFieldNumber = 2,
    kIdFieldNumber = 4,
    kTimeFieldNumber = 3,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 time = 3;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TestNetAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// -------------------------------------------------------------------

class TestNetReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TestNetReq) */ {
 public:
  inline TestNetReq() : TestNetReq(nullptr) {}
  ~TestNetReq() override;
  explicit PROTOBUF_CONSTEXPR TestNetReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestNetReq(const TestNetReq& from);
  TestNetReq(TestNetReq&& from) noexcept
    : TestNetReq() {
    *this = ::std::move(from);
  }

  inline TestNetReq& operator=(const TestNetReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestNetReq& operator=(TestNetReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestNetReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestNetReq* internal_default_instance() {
    return reinterpret_cast<const TestNetReq*>(
               &_TestNetReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TestNetReq& a, TestNetReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TestNetReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestNetReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestNetReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestNetReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestNetReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TestNetReq& from) {
    TestNetReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestNetReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TestNetReq";
  }
  protected:
  explicit TestNetReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kHashFieldNumber = 2,
    kIdFieldNumber = 4,
    kTimeFieldNumber = 3,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // string id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 time = 3;
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TestNetReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    uint64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PrintMsgReq

// string data = 1;
inline void PrintMsgReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& PrintMsgReq::data() const {
  // @@protoc_insertion_point(field_get:PrintMsgReq.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrintMsgReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PrintMsgReq.data)
}
inline std::string* PrintMsgReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:PrintMsgReq.data)
  return _s;
}
inline const std::string& PrintMsgReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void PrintMsgReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* PrintMsgReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* PrintMsgReq::release_data() {
  // @@protoc_insertion_point(field_release:PrintMsgReq.data)
  return _impl_.data_.Release();
}
inline void PrintMsgReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PrintMsgReq.data)
}

// int32 type = 2;
inline void PrintMsgReq::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t PrintMsgReq::_internal_type() const {
  return _impl_.type_;
}
inline int32_t PrintMsgReq::type() const {
  // @@protoc_insertion_point(field_get:PrintMsgReq.type)
  return _internal_type();
}
inline void PrintMsgReq::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void PrintMsgReq::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:PrintMsgReq.type)
}

// -------------------------------------------------------------------

// NodeInfo

// bytes pub = 1;
inline void NodeInfo::clear_pub() {
  _impl_.pub_.ClearToEmpty();
}
inline const std::string& NodeInfo::pub() const {
  // @@protoc_insertion_point(field_get:NodeInfo.pub)
  return _internal_pub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_pub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pub_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.pub)
}
inline std::string* NodeInfo::mutable_pub() {
  std::string* _s = _internal_mutable_pub();
  // @@protoc_insertion_point(field_mutable:NodeInfo.pub)
  return _s;
}
inline const std::string& NodeInfo::_internal_pub() const {
  return _impl_.pub_.Get();
}
inline void NodeInfo::_internal_set_pub(const std::string& value) {
  
  _impl_.pub_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_pub() {
  
  return _impl_.pub_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_pub() {
  // @@protoc_insertion_point(field_release:NodeInfo.pub)
  return _impl_.pub_.Release();
}
inline void NodeInfo::set_allocated_pub(std::string* pub) {
  if (pub != nullptr) {
    
  } else {
    
  }
  _impl_.pub_.SetAllocated(pub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pub_.IsDefault()) {
    _impl_.pub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.pub)
}

// bytes sign = 2;
inline void NodeInfo::clear_sign() {
  _impl_.sign_.ClearToEmpty();
}
inline const std::string& NodeInfo::sign() const {
  // @@protoc_insertion_point(field_get:NodeInfo.sign)
  return _internal_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_sign(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.sign)
}
inline std::string* NodeInfo::mutable_sign() {
  std::string* _s = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:NodeInfo.sign)
  return _s;
}
inline const std::string& NodeInfo::_internal_sign() const {
  return _impl_.sign_.Get();
}
inline void NodeInfo::_internal_set_sign(const std::string& value) {
  
  _impl_.sign_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_sign() {
  
  return _impl_.sign_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_sign() {
  // @@protoc_insertion_point(field_release:NodeInfo.sign)
  return _impl_.sign_.Release();
}
inline void NodeInfo::set_allocated_sign(std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  _impl_.sign_.SetAllocated(sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_.IsDefault()) {
    _impl_.sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.sign)
}

// bytes identity = 3;
inline void NodeInfo::clear_identity() {
  _impl_.identity_.ClearToEmpty();
}
inline const std::string& NodeInfo::identity() const {
  // @@protoc_insertion_point(field_get:NodeInfo.identity)
  return _internal_identity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_identity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identity_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.identity)
}
inline std::string* NodeInfo::mutable_identity() {
  std::string* _s = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:NodeInfo.identity)
  return _s;
}
inline const std::string& NodeInfo::_internal_identity() const {
  return _impl_.identity_.Get();
}
inline void NodeInfo::_internal_set_identity(const std::string& value) {
  
  _impl_.identity_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_identity() {
  
  return _impl_.identity_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_identity() {
  // @@protoc_insertion_point(field_release:NodeInfo.identity)
  return _impl_.identity_.Release();
}
inline void NodeInfo::set_allocated_identity(std::string* identity) {
  if (identity != nullptr) {
    
  } else {
    
  }
  _impl_.identity_.SetAllocated(identity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identity_.IsDefault()) {
    _impl_.identity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.identity)
}

// string addr = 4;
inline void NodeInfo::clear_addr() {
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& NodeInfo::addr() const {
  // @@protoc_insertion_point(field_get:NodeInfo.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.addr)
}
inline std::string* NodeInfo::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:NodeInfo.addr)
  return _s;
}
inline const std::string& NodeInfo::_internal_addr() const {
  return _impl_.addr_.Get();
}
inline void NodeInfo::_internal_set_addr(const std::string& value) {
  
  _impl_.addr_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_addr() {
  
  return _impl_.addr_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_addr() {
  // @@protoc_insertion_point(field_release:NodeInfo.addr)
  return _impl_.addr_.Release();
}
inline void NodeInfo::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  _impl_.addr_.SetAllocated(addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.addr_.IsDefault()) {
    _impl_.addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.addr)
}

// string public_addr = 5;
inline void NodeInfo::clear_public_addr() {
  _impl_.public_addr_.ClearToEmpty();
}
inline const std::string& NodeInfo::public_addr() const {
  // @@protoc_insertion_point(field_get:NodeInfo.public_addr)
  return _internal_public_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_public_addr(ArgT0&& arg0, ArgT... args) {
 
 _impl_.public_addr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.public_addr)
}
inline std::string* NodeInfo::mutable_public_addr() {
  std::string* _s = _internal_mutable_public_addr();
  // @@protoc_insertion_point(field_mutable:NodeInfo.public_addr)
  return _s;
}
inline const std::string& NodeInfo::_internal_public_addr() const {
  return _impl_.public_addr_.Get();
}
inline void NodeInfo::_internal_set_public_addr(const std::string& value) {
  
  _impl_.public_addr_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_public_addr() {
  
  return _impl_.public_addr_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_public_addr() {
  // @@protoc_insertion_point(field_release:NodeInfo.public_addr)
  return _impl_.public_addr_.Release();
}
inline void NodeInfo::set_allocated_public_addr(std::string* public_addr) {
  if (public_addr != nullptr) {
    
  } else {
    
  }
  _impl_.public_addr_.SetAllocated(public_addr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.public_addr_.IsDefault()) {
    _impl_.public_addr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.public_addr)
}

// string name = 6;
inline void NodeInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeInfo::name() const {
  // @@protoc_insertion_point(field_get:NodeInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.name)
}
inline std::string* NodeInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NodeInfo.name)
  return _s;
}
inline const std::string& NodeInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NodeInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_name() {
  // @@protoc_insertion_point(field_release:NodeInfo.name)
  return _impl_.name_.Release();
}
inline void NodeInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.name)
}

// string logo = 7;
inline void NodeInfo::clear_logo() {
  _impl_.logo_.ClearToEmpty();
}
inline const std::string& NodeInfo::logo() const {
  // @@protoc_insertion_point(field_get:NodeInfo.logo)
  return _internal_logo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_logo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.logo)
}
inline std::string* NodeInfo::mutable_logo() {
  std::string* _s = _internal_mutable_logo();
  // @@protoc_insertion_point(field_mutable:NodeInfo.logo)
  return _s;
}
inline const std::string& NodeInfo::_internal_logo() const {
  return _impl_.logo_.Get();
}
inline void NodeInfo::_internal_set_logo(const std::string& value) {
  
  _impl_.logo_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_logo() {
  
  return _impl_.logo_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_logo() {
  // @@protoc_insertion_point(field_release:NodeInfo.logo)
  return _impl_.logo_.Release();
}
inline void NodeInfo::set_allocated_logo(std::string* logo) {
  if (logo != nullptr) {
    
  } else {
    
  }
  _impl_.logo_.SetAllocated(logo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logo_.IsDefault()) {
    _impl_.logo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.logo)
}

// uint32 listen_ip = 8;
inline void NodeInfo::clear_listen_ip() {
  _impl_.listen_ip_ = 0u;
}
inline uint32_t NodeInfo::_internal_listen_ip() const {
  return _impl_.listen_ip_;
}
inline uint32_t NodeInfo::listen_ip() const {
  // @@protoc_insertion_point(field_get:NodeInfo.listen_ip)
  return _internal_listen_ip();
}
inline void NodeInfo::_internal_set_listen_ip(uint32_t value) {
  
  _impl_.listen_ip_ = value;
}
inline void NodeInfo::set_listen_ip(uint32_t value) {
  _internal_set_listen_ip(value);
  // @@protoc_insertion_point(field_set:NodeInfo.listen_ip)
}

// uint32 listen_port = 9;
inline void NodeInfo::clear_listen_port() {
  _impl_.listen_port_ = 0u;
}
inline uint32_t NodeInfo::_internal_listen_port() const {
  return _impl_.listen_port_;
}
inline uint32_t NodeInfo::listen_port() const {
  // @@protoc_insertion_point(field_get:NodeInfo.listen_port)
  return _internal_listen_port();
}
inline void NodeInfo::_internal_set_listen_port(uint32_t value) {
  
  _impl_.listen_port_ = value;
}
inline void NodeInfo::set_listen_port(uint32_t value) {
  _internal_set_listen_port(value);
  // @@protoc_insertion_point(field_set:NodeInfo.listen_port)
}

// uint32 public_ip = 10;
inline void NodeInfo::clear_public_ip() {
  _impl_.public_ip_ = 0u;
}
inline uint32_t NodeInfo::_internal_public_ip() const {
  return _impl_.public_ip_;
}
inline uint32_t NodeInfo::public_ip() const {
  // @@protoc_insertion_point(field_get:NodeInfo.public_ip)
  return _internal_public_ip();
}
inline void NodeInfo::_internal_set_public_ip(uint32_t value) {
  
  _impl_.public_ip_ = value;
}
inline void NodeInfo::set_public_ip(uint32_t value) {
  _internal_set_public_ip(value);
  // @@protoc_insertion_point(field_set:NodeInfo.public_ip)
}

// uint32 public_port = 11;
inline void NodeInfo::clear_public_port() {
  _impl_.public_port_ = 0u;
}
inline uint32_t NodeInfo::_internal_public_port() const {
  return _impl_.public_port_;
}
inline uint32_t NodeInfo::public_port() const {
  // @@protoc_insertion_point(field_get:NodeInfo.public_port)
  return _internal_public_port();
}
inline void NodeInfo::_internal_set_public_port(uint32_t value) {
  
  _impl_.public_port_ = value;
}
inline void NodeInfo::set_public_port(uint32_t value) {
  _internal_set_public_port(value);
  // @@protoc_insertion_point(field_set:NodeInfo.public_port)
}

// uint32 height = 12;
inline void NodeInfo::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t NodeInfo::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t NodeInfo::height() const {
  // @@protoc_insertion_point(field_get:NodeInfo.height)
  return _internal_height();
}
inline void NodeInfo::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void NodeInfo::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:NodeInfo.height)
}

// uint64 time_stamp = 13;
inline void NodeInfo::clear_time_stamp() {
  _impl_.time_stamp_ = uint64_t{0u};
}
inline uint64_t NodeInfo::_internal_time_stamp() const {
  return _impl_.time_stamp_;
}
inline uint64_t NodeInfo::time_stamp() const {
  // @@protoc_insertion_point(field_get:NodeInfo.time_stamp)
  return _internal_time_stamp();
}
inline void NodeInfo::_internal_set_time_stamp(uint64_t value) {
  
  _impl_.time_stamp_ = value;
}
inline void NodeInfo::set_time_stamp(uint64_t value) {
  _internal_set_time_stamp(value);
  // @@protoc_insertion_point(field_set:NodeInfo.time_stamp)
}

// string version = 14;
inline void NodeInfo::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& NodeInfo::version() const {
  // @@protoc_insertion_point(field_get:NodeInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeInfo.version)
}
inline std::string* NodeInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:NodeInfo.version)
  return _s;
}
inline const std::string& NodeInfo::_internal_version() const {
  return _impl_.version_.Get();
}
inline void NodeInfo::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeInfo::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeInfo::release_version() {
  // @@protoc_insertion_point(field_release:NodeInfo.version)
  return _impl_.version_.Release();
}
inline void NodeInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeInfo.version)
}

// -------------------------------------------------------------------

// RegisterNodeReq

// .NodeInfo mynode = 1;
inline bool RegisterNodeReq::_internal_has_mynode() const {
  return this != internal_default_instance() && _impl_.mynode_ != nullptr;
}
inline bool RegisterNodeReq::has_mynode() const {
  return _internal_has_mynode();
}
inline void RegisterNodeReq::clear_mynode() {
  if (GetArenaForAllocation() == nullptr && _impl_.mynode_ != nullptr) {
    delete _impl_.mynode_;
  }
  _impl_.mynode_ = nullptr;
}
inline const ::NodeInfo& RegisterNodeReq::_internal_mynode() const {
  const ::NodeInfo* p = _impl_.mynode_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeInfo&>(
      ::_NodeInfo_default_instance_);
}
inline const ::NodeInfo& RegisterNodeReq::mynode() const {
  // @@protoc_insertion_point(field_get:RegisterNodeReq.mynode)
  return _internal_mynode();
}
inline void RegisterNodeReq::unsafe_arena_set_allocated_mynode(
    ::NodeInfo* mynode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mynode_);
  }
  _impl_.mynode_ = mynode;
  if (mynode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RegisterNodeReq.mynode)
}
inline ::NodeInfo* RegisterNodeReq::release_mynode() {
  
  ::NodeInfo* temp = _impl_.mynode_;
  _impl_.mynode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NodeInfo* RegisterNodeReq::unsafe_arena_release_mynode() {
  // @@protoc_insertion_point(field_release:RegisterNodeReq.mynode)
  
  ::NodeInfo* temp = _impl_.mynode_;
  _impl_.mynode_ = nullptr;
  return temp;
}
inline ::NodeInfo* RegisterNodeReq::_internal_mutable_mynode() {
  
  if (_impl_.mynode_ == nullptr) {
    auto* p = CreateMaybeMessage<::NodeInfo>(GetArenaForAllocation());
    _impl_.mynode_ = p;
  }
  return _impl_.mynode_;
}
inline ::NodeInfo* RegisterNodeReq::mutable_mynode() {
  ::NodeInfo* _msg = _internal_mutable_mynode();
  // @@protoc_insertion_point(field_mutable:RegisterNodeReq.mynode)
  return _msg;
}
inline void RegisterNodeReq::set_allocated_mynode(::NodeInfo* mynode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mynode_;
  }
  if (mynode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mynode);
    if (message_arena != submessage_arena) {
      mynode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mynode, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mynode_ = mynode;
  // @@protoc_insertion_point(field_set_allocated:RegisterNodeReq.mynode)
}

// bool is_get_nodelist = 2;
inline void RegisterNodeReq::clear_is_get_nodelist() {
  _impl_.is_get_nodelist_ = false;
}
inline bool RegisterNodeReq::_internal_is_get_nodelist() const {
  return _impl_.is_get_nodelist_;
}
inline bool RegisterNodeReq::is_get_nodelist() const {
  // @@protoc_insertion_point(field_get:RegisterNodeReq.is_get_nodelist)
  return _internal_is_get_nodelist();
}
inline void RegisterNodeReq::_internal_set_is_get_nodelist(bool value) {
  
  _impl_.is_get_nodelist_ = value;
}
inline void RegisterNodeReq::set_is_get_nodelist(bool value) {
  _internal_set_is_get_nodelist(value);
  // @@protoc_insertion_point(field_set:RegisterNodeReq.is_get_nodelist)
}

// string msg_id = 3;
inline void RegisterNodeReq::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& RegisterNodeReq::msg_id() const {
  // @@protoc_insertion_point(field_get:RegisterNodeReq.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNodeReq::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegisterNodeReq.msg_id)
}
inline std::string* RegisterNodeReq::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:RegisterNodeReq.msg_id)
  return _s;
}
inline const std::string& RegisterNodeReq::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void RegisterNodeReq::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterNodeReq::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterNodeReq::release_msg_id() {
  // @@protoc_insertion_point(field_release:RegisterNodeReq.msg_id)
  return _impl_.msg_id_.Release();
}
inline void RegisterNodeReq::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RegisterNodeReq.msg_id)
}

// -------------------------------------------------------------------

// RegisterNodeAck

// repeated .NodeInfo nodes = 1;
inline int RegisterNodeAck::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int RegisterNodeAck::nodes_size() const {
  return _internal_nodes_size();
}
inline void RegisterNodeAck::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::NodeInfo* RegisterNodeAck::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:RegisterNodeAck.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >*
RegisterNodeAck::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:RegisterNodeAck.nodes)
  return &_impl_.nodes_;
}
inline const ::NodeInfo& RegisterNodeAck::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::NodeInfo& RegisterNodeAck::nodes(int index) const {
  // @@protoc_insertion_point(field_get:RegisterNodeAck.nodes)
  return _internal_nodes(index);
}
inline ::NodeInfo* RegisterNodeAck::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::NodeInfo* RegisterNodeAck::add_nodes() {
  ::NodeInfo* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:RegisterNodeAck.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >&
RegisterNodeAck::nodes() const {
  // @@protoc_insertion_point(field_list:RegisterNodeAck.nodes)
  return _impl_.nodes_;
}

// string msg_id = 2;
inline void RegisterNodeAck::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& RegisterNodeAck::msg_id() const {
  // @@protoc_insertion_point(field_get:RegisterNodeAck.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNodeAck::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegisterNodeAck.msg_id)
}
inline std::string* RegisterNodeAck::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:RegisterNodeAck.msg_id)
  return _s;
}
inline const std::string& RegisterNodeAck::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void RegisterNodeAck::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterNodeAck::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterNodeAck::release_msg_id() {
  // @@protoc_insertion_point(field_release:RegisterNodeAck.msg_id)
  return _impl_.msg_id_.Release();
}
inline void RegisterNodeAck::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RegisterNodeAck.msg_id)
}

// uint32 from_ip = 3;
inline void RegisterNodeAck::clear_from_ip() {
  _impl_.from_ip_ = 0u;
}
inline uint32_t RegisterNodeAck::_internal_from_ip() const {
  return _impl_.from_ip_;
}
inline uint32_t RegisterNodeAck::from_ip() const {
  // @@protoc_insertion_point(field_get:RegisterNodeAck.from_ip)
  return _internal_from_ip();
}
inline void RegisterNodeAck::_internal_set_from_ip(uint32_t value) {
  
  _impl_.from_ip_ = value;
}
inline void RegisterNodeAck::set_from_ip(uint32_t value) {
  _internal_set_from_ip(value);
  // @@protoc_insertion_point(field_set:RegisterNodeAck.from_ip)
}

// uint32 from_port = 4;
inline void RegisterNodeAck::clear_from_port() {
  _impl_.from_port_ = 0u;
}
inline uint32_t RegisterNodeAck::_internal_from_port() const {
  return _impl_.from_port_;
}
inline uint32_t RegisterNodeAck::from_port() const {
  // @@protoc_insertion_point(field_get:RegisterNodeAck.from_port)
  return _internal_from_port();
}
inline void RegisterNodeAck::_internal_set_from_port(uint32_t value) {
  
  _impl_.from_port_ = value;
}
inline void RegisterNodeAck::set_from_port(uint32_t value) {
  _internal_set_from_port(value);
  // @@protoc_insertion_point(field_set:RegisterNodeAck.from_port)
}

// uint32 fd = 5;
inline void RegisterNodeAck::clear_fd() {
  _impl_.fd_ = 0u;
}
inline uint32_t RegisterNodeAck::_internal_fd() const {
  return _impl_.fd_;
}
inline uint32_t RegisterNodeAck::fd() const {
  // @@protoc_insertion_point(field_get:RegisterNodeAck.fd)
  return _internal_fd();
}
inline void RegisterNodeAck::_internal_set_fd(uint32_t value) {
  
  _impl_.fd_ = value;
}
inline void RegisterNodeAck::set_fd(uint32_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:RegisterNodeAck.fd)
}

// -------------------------------------------------------------------

// SyncNodeReq

// string ids = 1;
inline void SyncNodeReq::clear_ids() {
  _impl_.ids_.ClearToEmpty();
}
inline const std::string& SyncNodeReq::ids() const {
  // @@protoc_insertion_point(field_get:SyncNodeReq.ids)
  return _internal_ids();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncNodeReq::set_ids(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ids_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SyncNodeReq.ids)
}
inline std::string* SyncNodeReq::mutable_ids() {
  std::string* _s = _internal_mutable_ids();
  // @@protoc_insertion_point(field_mutable:SyncNodeReq.ids)
  return _s;
}
inline const std::string& SyncNodeReq::_internal_ids() const {
  return _impl_.ids_.Get();
}
inline void SyncNodeReq::_internal_set_ids(const std::string& value) {
  
  _impl_.ids_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncNodeReq::_internal_mutable_ids() {
  
  return _impl_.ids_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncNodeReq::release_ids() {
  // @@protoc_insertion_point(field_release:SyncNodeReq.ids)
  return _impl_.ids_.Release();
}
inline void SyncNodeReq::set_allocated_ids(std::string* ids) {
  if (ids != nullptr) {
    
  } else {
    
  }
  _impl_.ids_.SetAllocated(ids, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ids_.IsDefault()) {
    _impl_.ids_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SyncNodeReq.ids)
}

// string msg_id = 3;
inline void SyncNodeReq::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& SyncNodeReq::msg_id() const {
  // @@protoc_insertion_point(field_get:SyncNodeReq.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncNodeReq::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SyncNodeReq.msg_id)
}
inline std::string* SyncNodeReq::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:SyncNodeReq.msg_id)
  return _s;
}
inline const std::string& SyncNodeReq::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void SyncNodeReq::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncNodeReq::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncNodeReq::release_msg_id() {
  // @@protoc_insertion_point(field_release:SyncNodeReq.msg_id)
  return _impl_.msg_id_.Release();
}
inline void SyncNodeReq::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SyncNodeReq.msg_id)
}

// -------------------------------------------------------------------

// SyncNodeAck

// repeated .NodeInfo nodes = 1;
inline int SyncNodeAck::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int SyncNodeAck::nodes_size() const {
  return _internal_nodes_size();
}
inline void SyncNodeAck::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::NodeInfo* SyncNodeAck::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:SyncNodeAck.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >*
SyncNodeAck::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:SyncNodeAck.nodes)
  return &_impl_.nodes_;
}
inline const ::NodeInfo& SyncNodeAck::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::NodeInfo& SyncNodeAck::nodes(int index) const {
  // @@protoc_insertion_point(field_get:SyncNodeAck.nodes)
  return _internal_nodes(index);
}
inline ::NodeInfo* SyncNodeAck::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::NodeInfo* SyncNodeAck::add_nodes() {
  ::NodeInfo* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:SyncNodeAck.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NodeInfo >&
SyncNodeAck::nodes() const {
  // @@protoc_insertion_point(field_list:SyncNodeAck.nodes)
  return _impl_.nodes_;
}

// .CSign sign = 2;
inline bool SyncNodeAck::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool SyncNodeAck::has_sign() const {
  return _internal_has_sign();
}
inline const ::CSign& SyncNodeAck::_internal_sign() const {
  const ::CSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSign&>(
      ::_CSign_default_instance_);
}
inline const ::CSign& SyncNodeAck::sign() const {
  // @@protoc_insertion_point(field_get:SyncNodeAck.sign)
  return _internal_sign();
}
inline void SyncNodeAck::unsafe_arena_set_allocated_sign(
    ::CSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SyncNodeAck.sign)
}
inline ::CSign* SyncNodeAck::release_sign() {
  
  ::CSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSign* SyncNodeAck::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:SyncNodeAck.sign)
  
  ::CSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::CSign* SyncNodeAck::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::CSign* SyncNodeAck::mutable_sign() {
  ::CSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:SyncNodeAck.sign)
  return _msg;
}
inline void SyncNodeAck::set_allocated_sign(::CSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:SyncNodeAck.sign)
}

// string ids = 3;
inline void SyncNodeAck::clear_ids() {
  _impl_.ids_.ClearToEmpty();
}
inline const std::string& SyncNodeAck::ids() const {
  // @@protoc_insertion_point(field_get:SyncNodeAck.ids)
  return _internal_ids();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncNodeAck::set_ids(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ids_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SyncNodeAck.ids)
}
inline std::string* SyncNodeAck::mutable_ids() {
  std::string* _s = _internal_mutable_ids();
  // @@protoc_insertion_point(field_mutable:SyncNodeAck.ids)
  return _s;
}
inline const std::string& SyncNodeAck::_internal_ids() const {
  return _impl_.ids_.Get();
}
inline void SyncNodeAck::_internal_set_ids(const std::string& value) {
  
  _impl_.ids_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncNodeAck::_internal_mutable_ids() {
  
  return _impl_.ids_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncNodeAck::release_ids() {
  // @@protoc_insertion_point(field_release:SyncNodeAck.ids)
  return _impl_.ids_.Release();
}
inline void SyncNodeAck::set_allocated_ids(std::string* ids) {
  if (ids != nullptr) {
    
  } else {
    
  }
  _impl_.ids_.SetAllocated(ids, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ids_.IsDefault()) {
    _impl_.ids_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SyncNodeAck.ids)
}

// string msg_id = 4;
inline void SyncNodeAck::clear_msg_id() {
  _impl_.msg_id_.ClearToEmpty();
}
inline const std::string& SyncNodeAck::msg_id() const {
  // @@protoc_insertion_point(field_get:SyncNodeAck.msg_id)
  return _internal_msg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncNodeAck::set_msg_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SyncNodeAck.msg_id)
}
inline std::string* SyncNodeAck::mutable_msg_id() {
  std::string* _s = _internal_mutable_msg_id();
  // @@protoc_insertion_point(field_mutable:SyncNodeAck.msg_id)
  return _s;
}
inline const std::string& SyncNodeAck::_internal_msg_id() const {
  return _impl_.msg_id_.Get();
}
inline void SyncNodeAck::_internal_set_msg_id(const std::string& value) {
  
  _impl_.msg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncNodeAck::_internal_mutable_msg_id() {
  
  return _impl_.msg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncNodeAck::release_msg_id() {
  // @@protoc_insertion_point(field_release:SyncNodeAck.msg_id)
  return _impl_.msg_id_.Release();
}
inline void SyncNodeAck::set_allocated_msg_id(std::string* msg_id) {
  if (msg_id != nullptr) {
    
  } else {
    
  }
  _impl_.msg_id_.SetAllocated(msg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_id_.IsDefault()) {
    _impl_.msg_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SyncNodeAck.msg_id)
}

// -------------------------------------------------------------------

// BroadcastMsgReq

// .NodeInfo from = 1;
inline bool BroadcastMsgReq::_internal_has_from() const {
  return this != internal_default_instance() && _impl_.from_ != nullptr;
}
inline bool BroadcastMsgReq::has_from() const {
  return _internal_has_from();
}
inline void BroadcastMsgReq::clear_from() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
}
inline const ::NodeInfo& BroadcastMsgReq::_internal_from() const {
  const ::NodeInfo* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeInfo&>(
      ::_NodeInfo_default_instance_);
}
inline const ::NodeInfo& BroadcastMsgReq::from() const {
  // @@protoc_insertion_point(field_get:BroadcastMsgReq.from)
  return _internal_from();
}
inline void BroadcastMsgReq::unsafe_arena_set_allocated_from(
    ::NodeInfo* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BroadcastMsgReq.from)
}
inline ::NodeInfo* BroadcastMsgReq::release_from() {
  
  ::NodeInfo* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NodeInfo* BroadcastMsgReq::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:BroadcastMsgReq.from)
  
  ::NodeInfo* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::NodeInfo* BroadcastMsgReq::_internal_mutable_from() {
  
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::NodeInfo>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::NodeInfo* BroadcastMsgReq::mutable_from() {
  ::NodeInfo* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:BroadcastMsgReq.from)
  return _msg;
}
inline void BroadcastMsgReq::set_allocated_from(::NodeInfo* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:BroadcastMsgReq.from)
}

// bytes data = 2;
inline void BroadcastMsgReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& BroadcastMsgReq::data() const {
  // @@protoc_insertion_point(field_get:BroadcastMsgReq.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BroadcastMsgReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BroadcastMsgReq.data)
}
inline std::string* BroadcastMsgReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:BroadcastMsgReq.data)
  return _s;
}
inline const std::string& BroadcastMsgReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void BroadcastMsgReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastMsgReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* BroadcastMsgReq::release_data() {
  // @@protoc_insertion_point(field_release:BroadcastMsgReq.data)
  return _impl_.data_.Release();
}
inline void BroadcastMsgReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BroadcastMsgReq.data)
}

// uint32 priority = 3;
inline void BroadcastMsgReq::clear_priority() {
  _impl_.priority_ = 0u;
}
inline uint32_t BroadcastMsgReq::_internal_priority() const {
  return _impl_.priority_;
}
inline uint32_t BroadcastMsgReq::priority() const {
  // @@protoc_insertion_point(field_get:BroadcastMsgReq.priority)
  return _internal_priority();
}
inline void BroadcastMsgReq::_internal_set_priority(uint32_t value) {
  
  _impl_.priority_ = value;
}
inline void BroadcastMsgReq::set_priority(uint32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:BroadcastMsgReq.priority)
}

// -------------------------------------------------------------------

// PingReq

// string id = 1;
inline void PingReq::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PingReq::id() const {
  // @@protoc_insertion_point(field_get:PingReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PingReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PingReq.id)
}
inline std::string* PingReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PingReq.id)
  return _s;
}
inline const std::string& PingReq::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PingReq::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PingReq::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PingReq::release_id() {
  // @@protoc_insertion_point(field_release:PingReq.id)
  return _impl_.id_.Release();
}
inline void PingReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PingReq.id)
}

// -------------------------------------------------------------------

// PongReq

// string id = 1;
inline void PongReq::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PongReq::id() const {
  // @@protoc_insertion_point(field_get:PongReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PongReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PongReq.id)
}
inline std::string* PongReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PongReq.id)
  return _s;
}
inline const std::string& PongReq::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PongReq::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PongReq::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PongReq::release_id() {
  // @@protoc_insertion_point(field_release:PongReq.id)
  return _impl_.id_.Release();
}
inline void PongReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PongReq.id)
}

// -------------------------------------------------------------------

// EchoReq

// string id = 1;
inline void EchoReq::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& EchoReq::id() const {
  // @@protoc_insertion_point(field_get:EchoReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EchoReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EchoReq.id)
}
inline std::string* EchoReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:EchoReq.id)
  return _s;
}
inline const std::string& EchoReq::_internal_id() const {
  return _impl_.id_.Get();
}
inline void EchoReq::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* EchoReq::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* EchoReq::release_id() {
  // @@protoc_insertion_point(field_release:EchoReq.id)
  return _impl_.id_.Release();
}
inline void EchoReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EchoReq.id)
}

// string message = 2;
inline void EchoReq::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& EchoReq::message() const {
  // @@protoc_insertion_point(field_get:EchoReq.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EchoReq::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EchoReq.message)
}
inline std::string* EchoReq::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:EchoReq.message)
  return _s;
}
inline const std::string& EchoReq::_internal_message() const {
  return _impl_.message_.Get();
}
inline void EchoReq::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* EchoReq::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* EchoReq::release_message() {
  // @@protoc_insertion_point(field_release:EchoReq.message)
  return _impl_.message_.Release();
}
inline void EchoReq::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EchoReq.message)
}

// -------------------------------------------------------------------

// EchoAck

// string id = 1;
inline void EchoAck::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& EchoAck::id() const {
  // @@protoc_insertion_point(field_get:EchoAck.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EchoAck::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EchoAck.id)
}
inline std::string* EchoAck::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:EchoAck.id)
  return _s;
}
inline const std::string& EchoAck::_internal_id() const {
  return _impl_.id_.Get();
}
inline void EchoAck::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* EchoAck::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* EchoAck::release_id() {
  // @@protoc_insertion_point(field_release:EchoAck.id)
  return _impl_.id_.Release();
}
inline void EchoAck::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EchoAck.id)
}

// string message = 2;
inline void EchoAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& EchoAck::message() const {
  // @@protoc_insertion_point(field_get:EchoAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EchoAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:EchoAck.message)
}
inline std::string* EchoAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:EchoAck.message)
  return _s;
}
inline const std::string& EchoAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void EchoAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* EchoAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* EchoAck::release_message() {
  // @@protoc_insertion_point(field_release:EchoAck.message)
  return _impl_.message_.Release();
}
inline void EchoAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:EchoAck.message)
}

// -------------------------------------------------------------------

// NodeHeightChangedReq

// string id = 1;
inline void NodeHeightChangedReq::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& NodeHeightChangedReq::id() const {
  // @@protoc_insertion_point(field_get:NodeHeightChangedReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeHeightChangedReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeHeightChangedReq.id)
}
inline std::string* NodeHeightChangedReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:NodeHeightChangedReq.id)
  return _s;
}
inline const std::string& NodeHeightChangedReq::_internal_id() const {
  return _impl_.id_.Get();
}
inline void NodeHeightChangedReq::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeHeightChangedReq::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeHeightChangedReq::release_id() {
  // @@protoc_insertion_point(field_release:NodeHeightChangedReq.id)
  return _impl_.id_.Release();
}
inline void NodeHeightChangedReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeHeightChangedReq.id)
}

// uint32 height = 2;
inline void NodeHeightChangedReq::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t NodeHeightChangedReq::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t NodeHeightChangedReq::height() const {
  // @@protoc_insertion_point(field_get:NodeHeightChangedReq.height)
  return _internal_height();
}
inline void NodeHeightChangedReq::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void NodeHeightChangedReq::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:NodeHeightChangedReq.height)
}

// .CSign sign = 3;
inline bool NodeHeightChangedReq::_internal_has_sign() const {
  return this != internal_default_instance() && _impl_.sign_ != nullptr;
}
inline bool NodeHeightChangedReq::has_sign() const {
  return _internal_has_sign();
}
inline const ::CSign& NodeHeightChangedReq::_internal_sign() const {
  const ::CSign* p = _impl_.sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSign&>(
      ::_CSign_default_instance_);
}
inline const ::CSign& NodeHeightChangedReq::sign() const {
  // @@protoc_insertion_point(field_get:NodeHeightChangedReq.sign)
  return _internal_sign();
}
inline void NodeHeightChangedReq::unsafe_arena_set_allocated_sign(
    ::CSign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  _impl_.sign_ = sign;
  if (sign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeHeightChangedReq.sign)
}
inline ::CSign* NodeHeightChangedReq::release_sign() {
  
  ::CSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSign* NodeHeightChangedReq::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:NodeHeightChangedReq.sign)
  
  ::CSign* temp = _impl_.sign_;
  _impl_.sign_ = nullptr;
  return temp;
}
inline ::CSign* NodeHeightChangedReq::_internal_mutable_sign() {
  
  if (_impl_.sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSign>(GetArenaForAllocation());
    _impl_.sign_ = p;
  }
  return _impl_.sign_;
}
inline ::CSign* NodeHeightChangedReq::mutable_sign() {
  ::CSign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:NodeHeightChangedReq.sign)
  return _msg;
}
inline void NodeHeightChangedReq::set_allocated_sign(::CSign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sign_);
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign));
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:NodeHeightChangedReq.sign)
}

// -------------------------------------------------------------------

// NodeSign

// bytes sign = 1;
inline void NodeSign::clear_sign() {
  _impl_.sign_.ClearToEmpty();
}
inline const std::string& NodeSign::sign() const {
  // @@protoc_insertion_point(field_get:NodeSign.sign)
  return _internal_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeSign::set_sign(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeSign.sign)
}
inline std::string* NodeSign::mutable_sign() {
  std::string* _s = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:NodeSign.sign)
  return _s;
}
inline const std::string& NodeSign::_internal_sign() const {
  return _impl_.sign_.Get();
}
inline void NodeSign::_internal_set_sign(const std::string& value) {
  
  _impl_.sign_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeSign::_internal_mutable_sign() {
  
  return _impl_.sign_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeSign::release_sign() {
  // @@protoc_insertion_point(field_release:NodeSign.sign)
  return _impl_.sign_.Release();
}
inline void NodeSign::set_allocated_sign(std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  _impl_.sign_.SetAllocated(sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_.IsDefault()) {
    _impl_.sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeSign.sign)
}

// bytes pub = 2;
inline void NodeSign::clear_pub() {
  _impl_.pub_.ClearToEmpty();
}
inline const std::string& NodeSign::pub() const {
  // @@protoc_insertion_point(field_get:NodeSign.pub)
  return _internal_pub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeSign::set_pub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pub_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeSign.pub)
}
inline std::string* NodeSign::mutable_pub() {
  std::string* _s = _internal_mutable_pub();
  // @@protoc_insertion_point(field_mutable:NodeSign.pub)
  return _s;
}
inline const std::string& NodeSign::_internal_pub() const {
  return _impl_.pub_.Get();
}
inline void NodeSign::_internal_set_pub(const std::string& value) {
  
  _impl_.pub_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeSign::_internal_mutable_pub() {
  
  return _impl_.pub_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeSign::release_pub() {
  // @@protoc_insertion_point(field_release:NodeSign.pub)
  return _impl_.pub_.Release();
}
inline void NodeSign::set_allocated_pub(std::string* pub) {
  if (pub != nullptr) {
    
  } else {
    
  }
  _impl_.pub_.SetAllocated(pub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pub_.IsDefault()) {
    _impl_.pub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeSign.pub)
}

// -------------------------------------------------------------------

// NodeAddrChangedReq

// string version = 1;
inline void NodeAddrChangedReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& NodeAddrChangedReq::version() const {
  // @@protoc_insertion_point(field_get:NodeAddrChangedReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAddrChangedReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NodeAddrChangedReq.version)
}
inline std::string* NodeAddrChangedReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:NodeAddrChangedReq.version)
  return _s;
}
inline const std::string& NodeAddrChangedReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void NodeAddrChangedReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAddrChangedReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAddrChangedReq::release_version() {
  // @@protoc_insertion_point(field_release:NodeAddrChangedReq.version)
  return _impl_.version_.Release();
}
inline void NodeAddrChangedReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NodeAddrChangedReq.version)
}

// .NodeSign oldSign = 2;
inline bool NodeAddrChangedReq::_internal_has_oldsign() const {
  return this != internal_default_instance() && _impl_.oldsign_ != nullptr;
}
inline bool NodeAddrChangedReq::has_oldsign() const {
  return _internal_has_oldsign();
}
inline void NodeAddrChangedReq::clear_oldsign() {
  if (GetArenaForAllocation() == nullptr && _impl_.oldsign_ != nullptr) {
    delete _impl_.oldsign_;
  }
  _impl_.oldsign_ = nullptr;
}
inline const ::NodeSign& NodeAddrChangedReq::_internal_oldsign() const {
  const ::NodeSign* p = _impl_.oldsign_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeSign&>(
      ::_NodeSign_default_instance_);
}
inline const ::NodeSign& NodeAddrChangedReq::oldsign() const {
  // @@protoc_insertion_point(field_get:NodeAddrChangedReq.oldSign)
  return _internal_oldsign();
}
inline void NodeAddrChangedReq::unsafe_arena_set_allocated_oldsign(
    ::NodeSign* oldsign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.oldsign_);
  }
  _impl_.oldsign_ = oldsign;
  if (oldsign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeAddrChangedReq.oldSign)
}
inline ::NodeSign* NodeAddrChangedReq::release_oldsign() {
  
  ::NodeSign* temp = _impl_.oldsign_;
  _impl_.oldsign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NodeSign* NodeAddrChangedReq::unsafe_arena_release_oldsign() {
  // @@protoc_insertion_point(field_release:NodeAddrChangedReq.oldSign)
  
  ::NodeSign* temp = _impl_.oldsign_;
  _impl_.oldsign_ = nullptr;
  return temp;
}
inline ::NodeSign* NodeAddrChangedReq::_internal_mutable_oldsign() {
  
  if (_impl_.oldsign_ == nullptr) {
    auto* p = CreateMaybeMessage<::NodeSign>(GetArenaForAllocation());
    _impl_.oldsign_ = p;
  }
  return _impl_.oldsign_;
}
inline ::NodeSign* NodeAddrChangedReq::mutable_oldsign() {
  ::NodeSign* _msg = _internal_mutable_oldsign();
  // @@protoc_insertion_point(field_mutable:NodeAddrChangedReq.oldSign)
  return _msg;
}
inline void NodeAddrChangedReq::set_allocated_oldsign(::NodeSign* oldsign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.oldsign_;
  }
  if (oldsign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(oldsign);
    if (message_arena != submessage_arena) {
      oldsign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, oldsign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.oldsign_ = oldsign;
  // @@protoc_insertion_point(field_set_allocated:NodeAddrChangedReq.oldSign)
}

// .NodeSign newSign = 3;
inline bool NodeAddrChangedReq::_internal_has_newsign() const {
  return this != internal_default_instance() && _impl_.newsign_ != nullptr;
}
inline bool NodeAddrChangedReq::has_newsign() const {
  return _internal_has_newsign();
}
inline void NodeAddrChangedReq::clear_newsign() {
  if (GetArenaForAllocation() == nullptr && _impl_.newsign_ != nullptr) {
    delete _impl_.newsign_;
  }
  _impl_.newsign_ = nullptr;
}
inline const ::NodeSign& NodeAddrChangedReq::_internal_newsign() const {
  const ::NodeSign* p = _impl_.newsign_;
  return p != nullptr ? *p : reinterpret_cast<const ::NodeSign&>(
      ::_NodeSign_default_instance_);
}
inline const ::NodeSign& NodeAddrChangedReq::newsign() const {
  // @@protoc_insertion_point(field_get:NodeAddrChangedReq.newSign)
  return _internal_newsign();
}
inline void NodeAddrChangedReq::unsafe_arena_set_allocated_newsign(
    ::NodeSign* newsign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newsign_);
  }
  _impl_.newsign_ = newsign;
  if (newsign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:NodeAddrChangedReq.newSign)
}
inline ::NodeSign* NodeAddrChangedReq::release_newsign() {
  
  ::NodeSign* temp = _impl_.newsign_;
  _impl_.newsign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NodeSign* NodeAddrChangedReq::unsafe_arena_release_newsign() {
  // @@protoc_insertion_point(field_release:NodeAddrChangedReq.newSign)
  
  ::NodeSign* temp = _impl_.newsign_;
  _impl_.newsign_ = nullptr;
  return temp;
}
inline ::NodeSign* NodeAddrChangedReq::_internal_mutable_newsign() {
  
  if (_impl_.newsign_ == nullptr) {
    auto* p = CreateMaybeMessage<::NodeSign>(GetArenaForAllocation());
    _impl_.newsign_ = p;
  }
  return _impl_.newsign_;
}
inline ::NodeSign* NodeAddrChangedReq::mutable_newsign() {
  ::NodeSign* _msg = _internal_mutable_newsign();
  // @@protoc_insertion_point(field_mutable:NodeAddrChangedReq.newSign)
  return _msg;
}
inline void NodeAddrChangedReq::set_allocated_newsign(::NodeSign* newsign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.newsign_;
  }
  if (newsign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(newsign);
    if (message_arena != submessage_arena) {
      newsign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newsign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.newsign_ = newsign;
  // @@protoc_insertion_point(field_set_allocated:NodeAddrChangedReq.newSign)
}

// -------------------------------------------------------------------

// TestNetAck

// string data = 1;
inline void TestNetAck::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TestNetAck::data() const {
  // @@protoc_insertion_point(field_get:TestNetAck.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestNetAck::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TestNetAck.data)
}
inline std::string* TestNetAck::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:TestNetAck.data)
  return _s;
}
inline const std::string& TestNetAck::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TestNetAck::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TestNetAck::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TestNetAck::release_data() {
  // @@protoc_insertion_point(field_release:TestNetAck.data)
  return _impl_.data_.Release();
}
inline void TestNetAck::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TestNetAck.data)
}

// string hash = 2;
inline void TestNetAck::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& TestNetAck::hash() const {
  // @@protoc_insertion_point(field_get:TestNetAck.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestNetAck::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TestNetAck.hash)
}
inline std::string* TestNetAck::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:TestNetAck.hash)
  return _s;
}
inline const std::string& TestNetAck::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void TestNetAck::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TestNetAck::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* TestNetAck::release_hash() {
  // @@protoc_insertion_point(field_release:TestNetAck.hash)
  return _impl_.hash_.Release();
}
inline void TestNetAck::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TestNetAck.hash)
}

// uint64 time = 3;
inline void TestNetAck::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t TestNetAck::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t TestNetAck::time() const {
  // @@protoc_insertion_point(field_get:TestNetAck.time)
  return _internal_time();
}
inline void TestNetAck::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void TestNetAck::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:TestNetAck.time)
}

// string id = 4;
inline void TestNetAck::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TestNetAck::id() const {
  // @@protoc_insertion_point(field_get:TestNetAck.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestNetAck::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TestNetAck.id)
}
inline std::string* TestNetAck::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:TestNetAck.id)
  return _s;
}
inline const std::string& TestNetAck::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TestNetAck::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TestNetAck::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TestNetAck::release_id() {
  // @@protoc_insertion_point(field_release:TestNetAck.id)
  return _impl_.id_.Release();
}
inline void TestNetAck::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TestNetAck.id)
}

// -------------------------------------------------------------------

// TestNetReq

// string data = 1;
inline void TestNetReq::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& TestNetReq::data() const {
  // @@protoc_insertion_point(field_get:TestNetReq.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestNetReq::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TestNetReq.data)
}
inline std::string* TestNetReq::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:TestNetReq.data)
  return _s;
}
inline const std::string& TestNetReq::_internal_data() const {
  return _impl_.data_.Get();
}
inline void TestNetReq::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* TestNetReq::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* TestNetReq::release_data() {
  // @@protoc_insertion_point(field_release:TestNetReq.data)
  return _impl_.data_.Release();
}
inline void TestNetReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TestNetReq.data)
}

// string hash = 2;
inline void TestNetReq::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& TestNetReq::hash() const {
  // @@protoc_insertion_point(field_get:TestNetReq.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestNetReq::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TestNetReq.hash)
}
inline std::string* TestNetReq::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:TestNetReq.hash)
  return _s;
}
inline const std::string& TestNetReq::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void TestNetReq::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TestNetReq::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* TestNetReq::release_hash() {
  // @@protoc_insertion_point(field_release:TestNetReq.hash)
  return _impl_.hash_.Release();
}
inline void TestNetReq::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TestNetReq.hash)
}

// uint64 time = 3;
inline void TestNetReq::clear_time() {
  _impl_.time_ = uint64_t{0u};
}
inline uint64_t TestNetReq::_internal_time() const {
  return _impl_.time_;
}
inline uint64_t TestNetReq::time() const {
  // @@protoc_insertion_point(field_get:TestNetReq.time)
  return _internal_time();
}
inline void TestNetReq::_internal_set_time(uint64_t value) {
  
  _impl_.time_ = value;
}
inline void TestNetReq::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:TestNetReq.time)
}

// string id = 4;
inline void TestNetReq::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TestNetReq::id() const {
  // @@protoc_insertion_point(field_get:TestNetReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TestNetReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TestNetReq.id)
}
inline std::string* TestNetReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:TestNetReq.id)
  return _s;
}
inline const std::string& TestNetReq::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TestNetReq::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TestNetReq::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TestNetReq::release_id() {
  // @@protoc_insertion_point(field_release:TestNetReq.id)
  return _impl_.id_.Release();
}
inline void TestNetReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TestNetReq.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_2eproto
